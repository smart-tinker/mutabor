--- START OF FILE mutabor.txt ---

Directory structure:
./
├── api/
│   ├── db/
│   │   ├── changelog/
│   │   │   ├── db.changelog-add-user-role.xml
│   │   │   ├── db.changelog-initial.xml
│   │   │   └── db.changelog-master.xml
│   │   └── seeds/
│   │       └── 01_create_admin_user.js
│   ├── Dockerfile
│   ├── Dockerfile.dev
│   ├── Dockerfile.test
│   ├── .dockerignore
│   ├── .env
│   ├── .env.dev
│   ├── .env.example
│   ├── .env.test
│   ├── .gitignore
│   ├── jest.config.js
│   ├── knexfile.js
│   ├── liquibase.properties
│   ├── package.json
│   ├── package-lock.json
│   ├── src/
│   │   ├── ai/
│   │   │   ├── ai.controller.ts
│   │   │   ├── ai.module.ts
│   │   │   ├── ai.service.ts
│   │   │   └── dto/
│   │   │       ├── ai-settings.dto.ts
│   │   │       ├── assist-request.dto.ts
│   │   │       └── update-ai-settings.dto.ts
│   │   ├── app.controller.spec.ts
│   │   ├── app.controller.ts
│   │   ├── app.module.ts
│   │   ├── auth/
│   │   │   ├── auth.controller.ts
│   │   │   ├── auth.module.ts
│   │   │   ├── auth.service.spec.ts
│   │   │   ├── auth.service.ts
│   │   │   ├── decorators/
│   │   │   │   ├── get-user.decorator.ts
│   │   │   │   └── public.decorator.ts
│   │   │   ├── dto/
│   │   │   │   ├── change-password.dto.ts
│   │   │   │   ├── login-user.dto.ts
│   │   │   │   ├── register-user.dto.ts
│   │   │   │   └── update-profile.dto.ts
│   │   │   ├── guards/
│   │   │   │   └── jwt-auth.guard.ts
│   │   │   ├── jwt.strategy.ts
│   │   │   └── profile.controller.ts
│   │   ├── casl/
│   │   │   ├── check-policies.decorator.ts
│   │   │   ├── policies.guard.spec.ts
│   │   │   ├── policies.guard.ts
│   │   │   ├── policy.interface.ts
│   │   │   ├── project-policies.handler.ts
│   │   │   └── roles.enum.ts
│   │   ├── comments/
│   │   │   ├── comments.module.ts
│   │   │   ├── comments.service.spec.ts
│   │   │   ├── comments.service.ts
│   │   │   └── dto/
│   │   │       └── create-comment.dto.ts
│   │   ├── common/
│   │   │   ├── filters/
│   │   │   │   └── global-exception.filter.ts
│   │   │   └── services/
│   │   │       └── encryption.service.ts
│   │   ├── events/
│   │   │   ├── events.gateway.ts
│   │   │   └── events.module.ts
│   │   ├── knex/
│   │   │   ├── knex.constants.ts
│   │   │   └── knex.module.ts
│   │   ├── main.ts
│   │   ├── notifications/
│   │   │   ├── dto/
│   │   │   │   └── notification.dto.ts
│   │   │   ├── guards/
│   │   │   │   └── notification-owner.guard.ts
│   │   │   ├── notifications.controller.spec.ts
│   │   │   ├── notifications.controller.ts
│   │   │   ├── notifications.module.ts
│   │   │   ├── notifications.service.spec.ts
│   │   │   └── notifications.service.ts
│   │   ├── projects/
│   │   │   ├── dto/
│   │   │   │   ├── add-member.dto.ts
│   │   │   │   ├── create-column.dto.ts
│   │   │   │   ├── create-project.dto.ts
│   │   │   │   ├── project-details.dto.ts
│   │   │   │   ├── project-settings.dto.ts
│   │   │   │   ├── update-column.dto.ts
│   │   │   │   ├── update-member.dto.ts
│   │   │   │   └── update-project-settings.dto.ts
│   │   │   ├── projects.controller.spec.ts
│   │   │   ├── projects.controller.ts
│   │   │   ├── projects.module.ts
│   │   │   ├── projects.service.spec.ts
│   │   │   └── projects.service.ts
│   │   ├── tasks/
│   │   │   ├── dto/
│   │   │   │   ├── create-task.dto.ts
│   │   │   │   ├── move-task.dto.ts
│   │   │   │   ├── task.dto.ts
│   │   │   │   └── update-task.dto.ts
│   │   │   ├── tasks.controller.spec.ts
│   │   │   ├── tasks.controller.ts
│   │   │   ├── tasks.module.ts
│   │   │   ├── tasks.service.spec.ts
│   │   │   └── tasks.service.ts
│   │   └── types/
│   │       └── db-records.d.ts
│   ├── tsconfig.build.json
│   └── tsconfig.json
├── client/
│   ├── Dockerfile
│   ├── Dockerfile.dev
│   ├── .env
│   ├── .env.example
│   ├── eslint.config.js
│   ├── .gitignore
│   ├── index.html
│   ├── nginx.conf
│   ├── package.json
│   ├── package-lock.json
│   ├── public/
│   │   └── vite.svg
│   ├── README.md
│   ├── src/
│   │   ├── app/
│   │   │   ├── AppRouter.tsx
│   │   │   ├── App.spec.tsx
│   │   │   ├── App.tsx
│   │   │   ├── auth/
│   │   │   │   └── AuthContext.tsx
│   │   │   └── styles/
│   │   │       ├── global.css
│   │   │       └── theme.css
│   │   ├── features/
│   │   │   ├── AddTaskModal/
│   │   │   │   ├── AddTaskModal.module.css
│   │   │   │   ├── index.ts
│   │   │   │   └── ui/
│   │   │   │       └── AddTaskModal.tsx
│   │   │   ├── authByEmail/
│   │   │   │   ├── api/
│   │   │   │   │   └── index.ts
│   │   │   │   └── ui/
│   │   │   │       ├── LoginForm.tsx
│   │   │   │       ├── LogoutButton.tsx
│   │   │   │       ├── RegistrationForm.module.css
│   │   │   │       └── RegistrationForm.tsx
│   │   │   ├── ColumnLane/
│   │   │   │   ├── ColumnLane.module.css
│   │   │   │   └── ColumnLane.tsx
│   │   │   ├── Comments/
│   │   │   │   ├── api.ts
│   │   │   │   ├── index.ts
│   │   │   │   └── ui/
│   │   │   │       ├── AddCommentForm.module.css
│   │   │   │       ├── AddCommentForm.tsx
│   │   │   │       ├── CommentItem.module.css
│   │   │   │       ├── CommentItem.tsx
│   │   │   │       ├── CommentList.module.css
│   │   │   │       └── CommentList.tsx
│   │   │   ├── Notifications/
│   │   │   │   ├── api.ts
│   │   │   │   ├── index.ts
│   │   │   │   └── ui/
│   │   │   │       ├── NotificationBell.module.css
│   │   │   │       ├── NotificationBell.tsx
│   │   │   │       ├── NotificationDropdown.module.css
│   │   │   │       ├── NotificationDropdown.tsx
│   │   │   │       ├── NotificationItem.module.css
│   │   │   │       └── NotificationItem.tsx
│   │   │   ├── TaskCard/
│   │   │   │   ├── TaskCard.module.css
│   │   │   │   └── TaskCard.tsx
│   │   │   └── TaskDetailModal/
│   │   │       ├── index.ts
│   │   │       └── ui/
│   │   │           ├── EditableField.tsx
│   │   │           ├── TaskDetailModal.module.css
│   │   │           └── TaskDetailModal.tsx
│   │   ├── main.tsx
│   │   ├── pages/
│   │   │   ├── BoardPage.module.css
│   │   │   ├── BoardPage.tsx
│   │   │   ├── DashboardPage.module.css
│   │   │   ├── DashboardPage.tsx
│   │   │   ├── LandingPage.tsx
│   │   │   ├── LoginPage.tsx
│   │   │   ├── NotFoundPage.tsx
│   │   │   ├── ProjectSettings/
│   │   │   │   ├── GeneralSettingsTab.tsx
│   │   │   │   ├── MembersSettingsTab.tsx
│   │   │   │   ├── StatusesSettingsTab.tsx
│   │   │   │   └── TypesSettingsTab.tsx
│   │   │   ├── ProjectSettingsPage.module.css
│   │   │   ├── ProjectSettingsPage.spec.tsx
│   │   │   ├── ProjectSettingsPage.tsx
│   │   │   ├── RegistrationPage.tsx
│   │   │   ├── TaskPage.module.css
│   │   │   ├── TaskPage.tsx
│   │   │   ├── UserSettingsPage.module.css
│   │   │   └── UserSettingsPage.tsx
│   │   ├── setupTests.ts
│   │   ├── shared/
│   │   │   ├── api/
│   │   │   │   ├── axiosInstance.ts
│   │   │   │   ├── notificationService.ts
│   │   │   │   ├── projectService.ts
│   │   │   │   ├── taskService.ts
│   │   │   │   └── types.ts
│   │   │   ├── contexts/
│   │   │   │   ├── AddTaskModalContext.tsx
│   │   │   │   └── ThemeContext.tsx
│   │   │   ├── lib/
│   │   │   │   └── socket.ts
│   │   │   └── ui/
│   │   │       ├── index.ts
│   │   │       └── Modal/
│   │   │           ├── index.ts
│   │   │           ├── Modal.module.css
│   │   │           ├── Modal.spec.tsx
│   │   │           └── Modal.tsx
│   │   ├── vite-env.d.ts
│   │   └── widgets/
│   │       ├── Header/
│   │       │   ├── Header.module.css
│   │       │   ├── Header.spec.tsx
│   │       │   └── Header.tsx
│   │       └── Layout/
│   │           ├── MainLayout.module.css
│   │           └── MainLayout.tsx
│   ├── tsconfig.app.json
│   ├── tsconfig.json
│   ├── tsconfig.node.json
│   └── vite.config.ts
├── create_context.sh*
├── docker-compose.dev.yml
├── docker-compose.test.yml
├── docker-compose.yml
├── docs/
│   ├── Contracts.md
│   ├── Contribution Guidelines.md
│   ├── Database Schema.md
│   ├── Dependencies Map.md
│   ├── Design System.md
│   ├── Implementation Plan.md
│   ├── Layer Guides.md
│   ├── Solution Design.md
│   └── User Flow Diagrams.md
├── package.json
├── project_context.txt
└── README.md

60 directories, 199 files


================================================
FILE: api/db/changelog/db.changelog-add-user-role.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog
    xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
                        http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-latest.xsd">

    <changeSet id="add-user-role-1" author="mutabor-admin-feature">
        <comment>Add role column to users table for global roles like Admin</comment>
        
        <addColumn tableName="users">
            <column name="role" type="TEXT" defaultValue="user">
                <constraints nullable="false"/>
            </column>
        </addColumn>

        <createIndex indexName="idx_users_role" tableName="users">
            <column name="role"/>
        </createIndex>

    </changeSet>

</databaseChangeLog>

================================================
FILE: api/db/changelog/db.changelog-initial.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog
    xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
                        http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-latest.xsd">

    <changeSet id="initial-schema-1" author="mutabor-final-fix">
        <comment>Initial consolidated schema for Mutabor project</comment>

        <!-- Create users table -->
        <createTable tableName="users">
            <column name="id" type="UUID"><constraints primaryKey="true" nullable="false"/></column>
            <column name="email" type="TEXT"><constraints unique="true" nullable="false"/></column>
            <column name="name" type="TEXT"><constraints nullable="true"/></column>
            <column name="password_hash" type="TEXT"><constraints nullable="false"/></column>
            <column name="created_at" type="TIMESTAMP WITH TIME ZONE" defaultValueComputed="CURRENT_TIMESTAMP"><constraints nullable="false"/></column>
            <column name="updated_at" type="TIMESTAMP WITH TIME ZONE" defaultValueComputed="CURRENT_TIMESTAMP"><constraints nullable="false"/></column>
        </createTable>

        <!-- Create projects table -->
        <createTable tableName="projects">
            <column name="id" type="SERIAL"><constraints primaryKey="true" nullable="false"/></column>
            <column name="name" type="TEXT"><constraints nullable="false"/></column>
            <column name="task_prefix" type="TEXT"><constraints unique="true" nullable="false"/></column>
            <column name="owner_id" type="UUID"><constraints nullable="false" foreignKeyName="fk_projects_owner" references="users(id)" deleteCascade="false"/></column>
            <column name="last_task_number" type="INT" defaultValueNumeric="0"><constraints nullable="false"/></column>
            <column name="created_at" type="TIMESTAMP WITH TIME ZONE" defaultValueComputed="CURRENT_TIMESTAMP"><constraints nullable="false"/></column>
            <column name="updated_at" type="TIMESTAMP WITH TIME ZONE" defaultValueComputed="CURRENT_TIMESTAMP"><constraints nullable="false"/></column>
        </createTable>

        <!-- Create project_members table -->
        <createTable tableName="project_members">
            <column name="project_id" type="INT"><constraints nullable="false" foreignKeyName="fk_projectmembers_project" references="projects(id)" deleteCascade="true"/></column>
            <column name="user_id" type="UUID"><constraints nullable="false" foreignKeyName="fk_projectmembers_user" references="users(id)" deleteCascade="true"/></column>
            <column name="role" type="TEXT"><constraints nullable="false"/></column>
            <column name="created_at" type="TIMESTAMP WITH TIME ZONE" defaultValueComputed="CURRENT_TIMESTAMP"><constraints nullable="false"/></column>
            <column name="updated_at" type="TIMESTAMP WITH TIME ZONE" defaultValueComputed="CURRENT_TIMESTAMP"><constraints nullable="false"/></column>
        </createTable>
        <addPrimaryKey tableName="project_members" columnNames="project_id, user_id" constraintName="pk_project_members"/>
        <createIndex indexName="idx_project_members_user_id" tableName="project_members"><column name="user_id"/></createIndex>

        <!-- Create project_task_types table -->
        <createTable tableName="project_task_types">
            <column name="id" type="SERIAL"><constraints primaryKey="true" nullable="false"/></column>
            <column name="name" type="TEXT"><constraints nullable="false"/></column>
            <column name="project_id" type="INT"><constraints nullable="false" foreignKeyName="fk_tasktypes_project" references="projects(id)" deleteCascade="true"/></column>
            <column name="created_at" type="TIMESTAMP WITH TIME ZONE" defaultValueComputed="CURRENT_TIMESTAMP"><constraints nullable="false"/></column>
            <column name="updated_at" type="TIMESTAMP WITH TIME ZONE" defaultValueComputed="CURRENT_TIMESTAMP"><constraints nullable="false"/></column>
        </createTable>
        <addUniqueConstraint columnNames="name,project_id" constraintName="uq_project_task_types_name_project_id" tableName="project_task_types"/>
        
        <!-- Create columns table -->
        <createTable tableName="columns">
            <column name="id" type="UUID"><constraints primaryKey="true" nullable="false"/></column>
            <column name="name" type="TEXT"><constraints nullable="false"/></column>
            <column name="position" type="INT"><constraints nullable="false"/></column>
            <column name="project_id" type="INT"><constraints nullable="false" foreignKeyName="fk_columns_project" references="projects(id)" deleteCascade="true"/></column>
            <column name="created_at" type="TIMESTAMP WITH TIME ZONE" defaultValueComputed="CURRENT_TIMESTAMP"><constraints nullable="false"/></column>
            <column name="updated_at" type="TIMESTAMP WITH TIME ZONE" defaultValueComputed="CURRENT_TIMESTAMP"><constraints nullable="false"/></column>
        </createTable>
        <addUniqueConstraint columnNames="name,project_id" constraintName="uq_columns_name_project_id" tableName="columns"/>
        
        <!-- Create tasks table (without problematic FKs) -->
        <createTable tableName="tasks">
            <column name="id" type="UUID"><constraints primaryKey="true" nullable="false"/></column>
            <column name="human_readable_id" type="TEXT"><constraints unique="true" nullable="false"/></column>
            <column name="task_number" type="INT"><constraints nullable="false"/></column>
            <column name="title" type="TEXT"><constraints nullable="false"/></column>
            <column name="description" type="TEXT"><constraints nullable="true"/></column>
            <column name="position" type="INT"><constraints nullable="false"/></column>
            <column name="type" type="VARCHAR(255)"><constraints nullable="true"/></column>
            <column name="priority" type="VARCHAR(255)"><constraints nullable="true"/></column>
            <column name="tags" type="TEXT[]"><constraints nullable="true"/></column>
            <column name="project_id" type="INT"><constraints nullable="false" foreignKeyName="fk_tasks_project" references="projects(id)" deleteCascade="true"/></column>
            <column name="column_id" type="UUID"><constraints nullable="false" foreignKeyName="fk_tasks_column" references="columns(id)" deleteCascade="true"/></column>
            <column name="assignee_id" type="UUID"><constraints nullable="true"/></column> <!-- FK will be added later -->
            <column name="creator_id" type="UUID"><constraints nullable="false" foreignKeyName="fk_tasks_creator" references="users(id)" deleteCascade="false"/></column>
            <column name="due_date" type="TIMESTAMP WITH TIME ZONE"><constraints nullable="true"/></column>
            <column name="created_at" type="TIMESTAMP WITH TIME ZONE" defaultValueComputed="CURRENT_TIMESTAMP"><constraints nullable="false"/></column>
            <column name="updated_at" type="TIMESTAMP WITH TIME ZONE" defaultValueComputed="CURRENT_TIMESTAMP"><constraints nullable="false"/></column>
        </createTable>
        <addUniqueConstraint columnNames="project_id,task_number" constraintName="uq_tasks_project_id_task_number" tableName="tasks"/>
        <createIndex indexName="idx_tasks_column_id" tableName="tasks"><column name="column_id"/></createIndex>
        <createIndex indexName="idx_tasks_assignee_id" tableName="tasks"><column name="assignee_id"/></createIndex>
        
        <!-- Create comments table (without problematic FKs) -->
        <createTable tableName="comments">
            <column name="id" type="UUID"><constraints primaryKey="true" nullable="false"/></column>
            <column name="text" type="TEXT"><constraints nullable="false"/></column>
            <column name="task_id" type="UUID"><constraints nullable="false" foreignKeyName="fk_comments_task" references="tasks(id)" deleteCascade="true"/></column>
            <column name="author_id" type="UUID"><constraints nullable="true"/></column> <!-- FK will be added later -->
            <column name="created_at" type="TIMESTAMP WITH TIME ZONE" defaultValueComputed="CURRENT_TIMESTAMP"><constraints nullable="false"/></column>
            <column name="updated_at" type="TIMESTAMP WITH TIME ZONE" defaultValueComputed="CURRENT_TIMESTAMP"><constraints nullable="false"/></column>
        </createTable>

        <!-- Create notifications table -->
        <createTable tableName="notifications">
            <column name="id" type="UUID"><constraints primaryKey="true" nullable="false"/></column>
            <column name="recipient_id" type="UUID"><constraints nullable="false" foreignKeyName="fk_notifications_recipient" references="users(id)" deleteCascade="true"/></column>
            <column name="text" type="TEXT"><constraints nullable="false"/></column>
            <column name="is_read" type="BOOLEAN" defaultValueBoolean="false"><constraints nullable="false"/></column>
            <column name="source_url" type="TEXT"><constraints nullable="true"/></column>
            <column name="task_id" type="UUID"><constraints nullable="true" foreignKeyName="fk_notifications_task" references="tasks(id)" deleteCascade="true"/></column>
            <column name="created_at" type="TIMESTAMP WITH TIME ZONE" defaultValueComputed="CURRENT_TIMESTAMP"><constraints nullable="false"/></column>
            <column name="updated_at" type="TIMESTAMP WITH TIME ZONE" defaultValueComputed="CURRENT_TIMESTAMP"><constraints nullable="false"/></column>
        </createTable>
        <createIndex indexName="idx_notifications_recipient_id" tableName="notifications"><column name="recipient_id"/></createIndex>
        
        <!-- Add complex foreign keys separately -->
        <addForeignKeyConstraint
            baseColumnNames="assignee_id"
            baseTableName="tasks"
            constraintName="fk_tasks_assignee"
            referencedColumnNames="id"
            referencedTableName="users"
            onDelete="SET NULL"/>

        <addForeignKeyConstraint
            baseColumnNames="author_id"
            baseTableName="comments"
            constraintName="fk_comments_author"
            referencedColumnNames="id"
            referencedTableName="users"
            onDelete="SET NULL"/>
            
    </changeSet>

</databaseChangeLog>

================================================
FILE: api/db/changelog/db.changelog-master.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog
    xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
                        http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-latest.xsd">

    <include file="db/changelog/db.changelog-initial.xml"/>
    <include file="db/changelog/db.changelog-add-user-role.xml"/>

</databaseChangeLog>

================================================
FILE: api/db/seeds/01_create_admin_user.js
================================================
// api/db/seeds/01_create_admin_user.js
const bcrypt = require('bcrypt');
const crypto = require('crypto');

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> } 
 */
exports.seed = async function(knex) {
  const adminEmail = process.env.ADMIN_EMAIL;
  const adminPassword = process.env.ADMIN_PASSWORD;

  if (!adminEmail || !adminPassword) {
    console.log('ADMIN_EMAIL or ADMIN_PASSWORD not set in .env file. Skipping admin user seed.');
    return;
  }

  // Хешируем пароль из .env. Он будет использован ТОЛЬКО если мы создаем нового пользователя.
  const hashedPassword = await bcrypt.hash(adminPassword, 10);
  const userId = crypto.randomUUID();

  // Данные для вставки нового пользователя
  const adminUserData = {
    id: userId,
    email: adminEmail,
    name: 'Super Admin',
    password_hash: hashedPassword,
    role: 'admin',
    created_at: new Date(),
    updated_at: new Date(),
  };

  // Данные для обновления, если пользователь уже существует.
  // ВАЖНО: Мы не обновляем пароль! Только роль.
  const adminRoleUpdate = {
    role: 'admin',
    updated_at: new Date(),
  };

  try {
    // Выполняем операцию "UPSERT"
    await knex('users')
      .insert(adminUserData)
      .onConflict('email') // Если возникает конфликт по уникальному полю 'email'
      .merge(adminRoleUpdate); // ...то не вставляем, а обновляем существующую запись данными из merge()

    console.log(`Admin privileges ensured for user ${adminEmail}.`);
  } catch (error) {
    console.error(`Error during admin user seed: ${error.message}`);
  }
};

================================================
FILE: api/Dockerfile
================================================
# ---- 1. Сборщик (Builder) ----
FROM node:20-bullseye-slim AS builder

WORKDIR /app
COPY package*.json ./
# ### ИЗМЕНЕНИЕ: Устанавливаем ВСЕ зависимости, так как bcrypt нужен для сидинга
RUN npm install
COPY . .
RUN npm run build

# ---- 2. Финальный образ (Production) ----
FROM node:20-bullseye-slim

RUN apt-get update && apt-get install -y \
    curl \
    default-jre-headless \
    unzip \
    && apt-get clean && rm -rf /var/lib/apt/lists/*

RUN mkdir -p /usr/local/liquibase \
    && curl -L https://github.com/liquibase/liquibase/releases/download/v4.28.0/liquibase-4.28.0.zip -o liquibase.zip \
    && unzip liquibase.zip -d /usr/local/liquibase \
    && rm liquibase.zip \
    && chmod +x /usr/local/liquibase/liquibase
ENV PATH="/usr/local/liquibase:${PATH}"

WORKDIR /app

# ### ИЗМЕНЕНИЕ: Копируем все node_modules, включая dev, так как knex и bcrypt нужны для сидинга
COPY --from=builder /app/node_modules ./node_modules
COPY package*.json ./

COPY --from=builder /app/dist ./dist
COPY --from=builder /app/knexfile.js ./knexfile.js
COPY --from=builder /app/db ./db
COPY --from=builder /app/liquibase.properties ./liquibase.properties

EXPOSE 3001

# ### ИЗМЕНЕНИЕ: Добавлен запуск `npm run seed` после миграций
CMD ["sh", "-c", "liquibase --url=\"jdbc:postgresql://${DB_HOST}:${DB_PORT}/${DB_NAME}\" --username=\"${DB_USER}\" --password=\"${DB_PASSWORD}\" update && npm run seed && node dist/main.js"]

================================================
FILE: api/Dockerfile.dev
================================================
# api/Dockerfile.dev
FROM node:20-bullseye-slim

RUN apt-get update && apt-get install -y \
    curl \
    default-jre-headless \
    unzip \
    procps \
    && apt-get clean && rm -rf /var/lib/apt/lists/*

RUN mkdir -p /usr/local/liquibase \
    && curl -L https://github.com/liquibase/liquibase/releases/download/v4.28.0/liquibase-4.28.0.zip -o liquibase.zip \
    && unzip liquibase.zip -d /usr/local/liquibase \
    && rm liquibase.zip \
    && chmod +x /usr/local/liquibase/liquibase
ENV PATH="/usr/local/liquibase:${PATH}"

WORKDIR /app

COPY package*.json ./
RUN npm install

COPY . .

# ### ИЗМЕНЕНИЕ: Добавлен запуск `npm run seed` после миграций
CMD ["sh", "-c", "liquibase --url=\"jdbc:postgresql://${DB_HOST}:${DB_PORT}/${DB_NAME}\" --username=\"${DB_USER}\" --password=\"${DB_PASSWORD}\" update && npm run seed && npm run start:dev"]

================================================
FILE: api/Dockerfile.test
================================================
# Dockerfile для запуска тестов
FROM node:20-bullseye-slim

RUN apt-get update && apt-get install -y \
    curl \
    default-jre-headless \
    unzip \
    && apt-get clean && rm -rf /var/lib/apt/lists/*

RUN mkdir -p /usr/local/liquibase \
    && curl -L https://github.com/liquibase/liquibase/releases/download/v4.28.0/liquibase-4.28.0.zip -o liquibase.zip \
    && unzip liquibase.zip -d /usr/local/liquibase \
    && rm liquibase.zip \
    && chmod +x /usr/local/liquibase/liquibase
ENV PATH="/usr/local/liquibase:${PATH}"

WORKDIR /app

COPY package*.json ./
RUN npm install

COPY . .

# ### ИЗМЕНЕНИЕ: Добавлен запуск `npm run seed` после миграций
CMD ["sh", "-c", "liquibase --url=\"jdbc:postgresql://${DB_HOST}:${DB_PORT}/${DB_NAME}\" --username=\"${DB_USER}\" --password=\"${DB_PASSWORD}\" update && npm run seed && npm run test:cov"]

================================================
FILE: api/.dockerignore
================================================
# api/.dockerignore

# Игнорируем зависимости, их устанавливает Docker
node_modules

# Игнорируем директорию сборки
dist

# Игнорируем временные файлы npm
npm-debug.log

# ИГНОРИРУЕМ ПАПКУ С AI-МОДУЛЕМ, ЧТОБЫ ОНА НЕ ПОПАЛА В СБОРКУ
src/ai

# ВАЖНО: Игнорируем локальные .env файлы, чтобы они не попали в образ
.env*

================================================
FILE: api/.env
================================================
# ===============================================================
#                       API Server Settings
# ===============================================================

# Port for the API server. Recommended to use 3001 to avoid conflicts with the client dev server (3000).
PORT=3001

# ### ИЗМЕНЕНИЕ: Возвращаемся к одному простому секретному ключу ###
# JWT Secret Key - CHANGE THIS TO A STRONG, RANDOM SECRET
JWT_SECRET="YOUR_SUPER_SECRET_JWT_KEY_PLEASE_CHANGE_ME"

# Client URL for CORS policy
CLIENT_URL=http://localhost:3000

# Secret key for encrypting AI provider credentials stored in the database
AI_CREDENTIALS_ENCRYPTION_KEY="AI_CREDENTIALS_ENCRYPTION_KEY_SECRET_KEY_CHANGE_ME"


# ===============================================================
#                     Database Connection
# ===============================================================
# IMPORTANT: This file contains settings for local development.
# The application uses DATABASE_URL, while the migration script uses DB_* variables.
# Ensure they are consistent.

# --- For Nest.js Application (used by KnexModule) ---
# Example for connecting to the database started with `docker-compose up -d db`
DATABASE_URL="postgresql://user:password@localhost:54321/mutabor?schema=public"
# Example for a locally installed PostgreSQL on the default port
# DATABASE_URL="postgresql://user:password@localhost:5432/mutabor?schema=public"


# --- For Liquibase Migration Script (`npm run migrate`) ---
# These variables ARE REQUIRED for the migration script to work.
DB_HOST=localhost
DB_PORT=54321
DB_NAME=mutabor
DB_USER=user
DB_PASSWORD=password

# ===============================================================
#                     Super Admin Credentials
# ===============================================================
# These credentials will be used by the database seed script to create
# an admin account on the first run.
ADMIN_EMAIL=eldar@kurbanov.pro
ADMIN_PASSWORD=changeme

================================================
FILE: api/.env.dev
================================================
# Файл .env для РАЗРАБОТКИ.
# Убедитесь, что порты соответствуют docker-compose.dev.yml

# --- For Nest.js Application ---
DATABASE_URL="postgresql://user:password@localhost:54322/mutabor_dev?schema=public"

# --- For Liquibase Migration Script ---
DB_HOST=localhost
DB_PORT=54322
DB_NAME=mutabor_dev
DB_USER=user
DB_PASSWORD=password

# --- JWT and other settings ---
JWT_SECRET="YOUR_SUPER_SECRET_JWT_KEY_PLEASE_CHANGE_ME"
CLIENT_URL=http://localhost:8080
AI_CREDENTIALS_ENCRYPTION_KEY="AI_CREDENTIALS_ENCRYPTION_KEY_SECRET_KEY_CHANGE_ME"

# ### НОВОЕ: Учетные данные для супер-администратора ###
# Эти данные будут использованы seed-скриптом для создания админа при первом запуске
ADMIN_EMAIL=eldar@kurbanov.pro
ADMIN_PASSWORD=supersecretpassword

================================================
FILE: api/.env.example
================================================
# ===============================================================
#                       API Server Settings
# ===============================================================

# Port for the API server. Recommended to use 3001 to avoid conflicts with the client dev server (3000).
PORT=3001

# ### ИЗМЕНЕНИЕ: Возвращаемся к одному простому секретному ключу ###
# JWT Secret Key - CHANGE THIS TO A STRONG, RANDOM SECRET
JWT_SECRET="YOUR_SUPER_SECRET_JWT_KEY_PLEASE_CHANGE_ME"

# Client URL for CORS policy
CLIENT_URL=http://localhost:3000

# Secret key for encrypting AI provider credentials stored in the database
AI_CREDENTIALS_ENCRYPTION_KEY="AI_CREDENTIALS_ENCRYPTION_KEY_SECRET_KEY_CHANGE_ME"


# ===============================================================
#                     Database Connection
# ===============================================================
# IMPORTANT: This file contains settings for local development.
# The application uses DATABASE_URL, while the migration script uses DB_* variables.
# Ensure they are consistent.

# --- For Nest.js Application (used by KnexModule) ---
# Example for connecting to the database started with `docker-compose up -d db`
DATABASE_URL="postgresql://user:password@localhost:54321/mutabor?schema=public"
# Example for a locally installed PostgreSQL on the default port
# DATABASE_URL="postgresql://user:password@localhost:5432/mutabor?schema=public"


# --- For Liquibase Migration Script (`npm run migrate`) ---
# These variables ARE REQUIRED for the migration script to work.
DB_HOST=localhost
DB_PORT=54321
DB_NAME=mutabor
DB_USER=user
DB_PASSWORD=password

# ===============================================================
#                     Super Admin Credentials
# ===============================================================
# These credentials will be used by the database seed script to create
# an admin account on the first run.
ADMIN_EMAIL=admin@example.com
ADMIN_PASSWORD=changeme

================================================
FILE: api/.env.test
================================================
# Файл .env для ТЕСТИРОВАНИЯ.
# Убедитесь, что порты соответствуют docker-compose.dev.yml

# --- For Nest.js Application & Liquibase Migration Script ---
DATABASE_URL="postgresql://user:password@localhost:54323/mutabor_test?schema=public"
DB_HOST=localhost
DB_PORT=54323
DB_NAME=mutabor_test
DB_USER=user
DB_PASSWORD=password

# --- JWT and other settings (могут быть упрощены для тестов) ---
JWT_SECRET="TEST_JWT_SECRET_KEY"
CLIENT_URL=http://localhost:8080
AI_CREDENTIALS_ENCRYPTION_KEY="11223344556677889900aabbccddeeff11223344556677889900aabbccddeeff"

# ### НОВОЕ: Учетные данные для тестов, могут быть любыми ###
ADMIN_EMAIL=admin@test.com
ADMIN_PASSWORD=testpassword

================================================
FILE: api/.gitignore
================================================
node_modules
*.log

# IDE specific
.vscode/
.idea/

# OS specific
.DS_Store
Thumbs.db
.env
.env.dev

coverage/

================================================
FILE: api/jest.config.js
================================================
module.exports = {
  moduleFileExtensions: ['js', 'json', 'ts'],
  rootDir: '.',
  testRegex: '.*\\.spec\\.ts$',
  transform: {
    // ### ИЗМЕНЕНИЕ: Указываем, что ts-jest должен трансформировать только .ts файлы ###
    '^.+\\.ts$': 'ts-jest',
  },
  collectCoverageFrom: ['**/*.(t|j)s'],
  coverageDirectory: './coverage',
  testEnvironment: 'node',
};

================================================
FILE: api/knexfile.js
================================================
// api/knexfile.js

const env = process.env.NODE_ENV || 'development';
if (env === 'development') {
    require('dotenv').config({ path: './.env.dev' });
} else if (env === 'test') {
    require('dotenv').config({ path: './.env.test' });
} else {
    require('dotenv').config({ path: './.env' });
}

/**
 * @type { Object.<string, import("knex").Knex.Config> }
 */
module.exports = {
  development: {
    client: 'pg',
    connection: process.env.DATABASE_URL,
    pool: {
      min: 2,
      max: 10,
    },
    seeds: {
      directory: './db/seeds',
    },
  },
  test: {
    client: 'pg',
    connection: process.env.DATABASE_URL,
    pool: {
      min: 2,
      max: 10,
    },
    seeds: {
      directory: './db/seeds',
    },
  },
  production: {
    client: 'pg',
    connection: process.env.DATABASE_URL,
    pool: {
      min: 2,
      max: 10,
    },
    seeds: {
      directory: './db/seeds',
    },
  },
};

================================================
FILE: api/liquibase.properties
================================================
# Liquibase Properties File

# Путь к мастер-файлу ченджлога. Он не изменился.
changeLogFile: db/changelog/db.changelog-master.xml

# ### ИЗМЕНЕНИЕ: Явно указываем Liquibase брать параметры из переменных окружения ###
# Liquibase автоматически подставит значения из переменных DB_HOST, DB_PORT и т.д.
url: jdbc:postgresql://${DB_HOST}:${DB_PORT}/${DB_NAME}
username: ${DB_USER}
password: ${DB_PASSWORD}

# Драйвер для PostgreSQL. Liquibase найдет его в classpath.
driver: org.postgresql.Driver

# Отключаем интерактивные запросы, важно для автоматизации
promptForNonLocalDatabase: false

# Уровень логирования
logLevel: INFO

================================================
FILE: api/package.json
================================================
{
  "name": "api",
  "version": "0.0.1",
  "private": true,
  "scripts": {
    "build": "nest build",
    "migrate": "liquibase --changeLogFile=./db/changelog/db.changelog-master.xml --url=\"jdbc:postgresql://${DB_HOST}:${DB_PORT}/${DB_NAME}\" --username=${DB_USER} --password=${DB_PASSWORD} update",
    "seed": "knex seed:run",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json",
    "test:docker": "docker compose run --rm --build api-test"
  },
  "dependencies": {
    "@nestjs/common": "^10.3.10",
    "@nestjs/config": "^3.2.3",
    "@nestjs/core": "^10.3.10",
    "@nestjs/jwt": "^10.2.0",
    "@nestjs/passport": "^10.0.3",
    "@nestjs/platform-express": "^10.3.10",
    "@nestjs/platform-socket.io": "^10.3.10",
    "@nestjs/swagger": "^7.4.0",
    "@nestjs/websockets": "^10.3.10",
    "bcrypt": "^5.1.1",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.1",
    "dotenv": "^16.4.5",
    "knex": "^3.1.0",
    "liquibase": "^4.28.1",
    "passport": "^0.7.0",
    "passport-jwt": "^4.0.1",
    "pg": "^8.12.0",
    "socket.io": "^4.7.5"
  },
  "devDependencies": {
    "@nestjs/cli": "^10.4.2",
    "@nestjs/schematics": "^10.1.3",
    "@nestjs/testing": "^10.3.10",
    "@types/bcrypt": "^5.0.2",
    "@types/express": "^4.17.21",
    "@types/jest": "^29.5.12",
    "@types/node": "^20.19.1",
    "@types/passport-jwt": "^4.0.1",
    "@types/supertest": "^6.0.2",
    "jest": "^29.7.0",
    "openai": "^4.52.7",
    "source-map-support": "^0.5.21",
    "supertest": "^7.0.0",
    "ts-jest": "^29.2.3",
    "ts-loader": "^9.5.1",
    "ts-node": "^10.9.2",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.8.3"
  }
}

================================================
FILE: api/src/ai/ai.controller.ts
================================================
import { Controller, Post, Body, UseGuards, Req, HttpCode, HttpStatus, Get, Put, Param, ParseIntPipe } from '@nestjs/common';
import { ApiTags, ApiBearerAuth, ApiOperation, ApiResponse } from '@nestjs/swagger';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { AiService } from './ai.service';
import { UpdateAiSettingsDto } from './dto/update-ai-settings.dto';
// ### ИЗМЕНЕНИЕ: Импортируем нужные декораторы и политики ###
import { CheckPolicies } from '../casl/check-policies.decorator';
import { CanManageProjectSettingsPolicy } from '../casl/project-policies.handler';
import { AssistRequestDto } from './dto/assist-request.dto';


@ApiBearerAuth()
@ApiTags('AI')
@UseGuards(JwtAuthGuard)
@Controller('api/v1') 
export class AiController {
  constructor(private readonly aiService: AiService) {}

  @Post('ai/assist')
  @ApiOperation({ summary: 'Invoke the AI assistant' })
  @ApiResponse({ status: 200, description: 'AI task completed successfully.'})
  @ApiResponse({ status: 400, description: 'Invalid request or AI settings not configured.'})
  @HttpCode(HttpStatus.OK)
  async assist(
    @Body() assistRequestDto: AssistRequestDto,
    @Req() req,
  ) {
    // Примечание: проверка прав доступа для этой операции (CanEditProjectContent)
    // выполняется внутри aiService.handleAssistRequest, так как гварду сложно
    // анализировать тело запроса для получения ID задачи.
    return this.aiService.handleAssistRequest(assistRequestDto, req.user);
  }

  @Get('projects/:projectId/ai/settings')
  @ApiOperation({ summary: "Get a project's AI provider settings" })
  // ### НОВОЕ: Эндпоинт защищен политикой ###
  @CheckPolicies(CanManageProjectSettingsPolicy)
  async getAiSettings(@Param('projectId', ParseIntPipe) projectId: number) {
    return this.aiService.getSettingsForProject(projectId);
  }

  @Put('projects/:projectId/ai/settings')
  @ApiOperation({ summary: "Update a project's AI provider settings" })
  // ### НОВОЕ: Эндпоинт защищен политикой ###
  @CheckPolicies(CanManageProjectSettingsPolicy)
  async updateAiSettings(
    @Param('projectId', ParseIntPipe) projectId: number,
    @Body() settingsDto: UpdateAiSettingsDto,
  ) {
    return this.aiService.updateSettingsForProject(projectId, settingsDto);
  }

  @Get('projects/:projectId/ai/models')
  @ApiOperation({ summary: 'List available models from the configured AI provider' })
  // ### НОВОЕ: Эндпоинт защищен политикой ###
  @CheckPolicies(CanManageProjectSettingsPolicy)
  async listModels(@Param('projectId', ParseIntPipe) projectId: number) {
    return this.aiService.listModelsForProject(projectId);
  }
}

================================================
FILE: api/src/ai/ai.module.ts
================================================
import { Module, forwardRef } from '@nestjs/common';
import { AiController } from './ai.controller';
import { AiService } from './ai.service';
import { ConfigModule } from '@nestjs/config';
import { ProjectsModule } from '../projects/projects.module';
import { EncryptionService } from '../common/services/encryption.service';
import { KnexModule } from '../knex/knex.module';
import { TasksModule } from '../tasks/tasks.module';

@Module({
  imports: [
    ConfigModule,
    KnexModule,
    forwardRef(() => ProjectsModule),
    forwardRef(() => TasksModule),
  ],
  controllers: [AiController],
  providers: [AiService, EncryptionService], // EncryptionService используется внутри AiService
  exports: [AiService],
})
export class AiModule {}

================================================
FILE: api/src/ai/ai.service.ts
================================================
import { Injectable, Inject, forwardRef, BadRequestException, NotFoundException, InternalServerErrorException, Logger, ForbiddenException } from '@nestjs/common';
import OpenAI from 'openai';
import { AssistRequestDto, AiAction, ContextType } from './dto/assist-request.dto';
import { ProjectsService } from '../projects/projects.service';
import { UserRecord } from 'src/types/db-records';
import { Knex } from 'knex';
import { KNEX_CONNECTION } from '../knex/knex.constants';
import { EncryptionService } from '../common/services/encryption.service';
import { Role } from '../casl/roles.enum';
import { UpdateAiSettingsDto } from './dto/update-ai-settings.dto';
import { TasksService } from '../tasks/tasks.service';

interface AiProviderSettings {
    id: number;
    project_id: number;
    provider_name: string;
    base_url: string;
    model_name: string | null;
    encrypted_api_key: string | null;
    encryption_key_version: number;
}

@Injectable()
export class AiService {
  private readonly logger = new Logger(AiService.name);
  private clientCache = new Map<number, OpenAI>(); // Кэш клиентов для проектов

  constructor(
    @Inject(KNEX_CONNECTION) private readonly knex: Knex,
    private readonly encryptionService: EncryptionService,
    @Inject(forwardRef(() => ProjectsService))
    private readonly projectsService: ProjectsService,
    @Inject(forwardRef(() => TasksService))
    private readonly tasksService: TasksService,
  ) {}

  private async getClientForProject(projectId: number): Promise<{ client: OpenAI, settings: AiProviderSettings }> {
    // Проверяем кэш
    if (this.clientCache.has(projectId)) {
        const settings = await this.knex('ai_provider_settings').where({ project_id: projectId }).first();
        return { client: this.clientCache.get(projectId), settings };
    }

    const settings: AiProviderSettings = await this.knex('ai_provider_settings')
      .where({ project_id: projectId }).first();

    if (!settings) {
      throw new BadRequestException('AI settings are not configured for this project.');
    }

    let apiKey = 'not-needed'; // По умолчанию для LMStudio
    if (settings.encrypted_api_key) {
        apiKey = this.encryptionService.decrypt(settings.encrypted_api_key);
    }
    
    const client = new OpenAI({
      baseURL: settings.base_url,
      apiKey: apiKey,
    });
    
    // Кэшируем клиент, чтобы не создавать его при каждом запросе
    this.clientCache.set(projectId, client);
    
    return { client, settings };
  }

  async handleAssistRequest(dto: AssistRequestDto, user: UserRecord) {
    if (dto.contextType !== ContextType.TASK) {
      throw new BadRequestException(`Unsupported context type: ${dto.contextType}`);
    }
    
    const task = await this.knex('tasks').where({ id: dto.contextId }).first();
    if (!task) throw new NotFoundException(`Task with ID ${dto.contextId} not found.`);

    // ### ИЗМЕНЕНИЕ: Исправлено имя метода с getProjectAndRole на getUserRoleForProject
    const userRole = await this.projectsService.getUserRoleForProject(task.project_id, user.id);
    if (userRole !== Role.Owner && userRole !== Role.Editor) {
        throw new ForbiddenException('You do not have permission to perform AI actions in this project.');
    }
    
    const { client, settings } = await this.getClientForProject(task.project_id);
    
    let prompt: string;
    switch (dto.action) {
      case AiAction.DECOMPOSE:
        prompt = this.getDecompositionPrompt(task.title, task.description);
        break;
      case AiAction.GENERATE_BRANCH_NAME:
        prompt = this.getBranchNamePrompt(task.title);
        break;
      default:
        throw new BadRequestException(`Unsupported action '${dto.action}' for context 'task'`);
    }
    
    const aiResponse = await this.generateText(client, settings.model_name, prompt);

    if (dto.action === AiAction.DECOMPOSE) {
        const newDescription = `${task.description || ''}\n\n---\n**AI Assistant Suggestion:**\n${aiResponse}`;
        await this.tasksService.updateTask(task.id, { description: newDescription }, user);
        return { message: 'Task decomposed successfully.', content: aiResponse };
    }
    
    if (dto.action === AiAction.GENERATE_BRANCH_NAME) {
        return { message: 'Branch name generated successfully', content: aiResponse };
    }
  }
  
  async getSettingsForProject(projectId: number) {
    const settings = await this.knex('ai_provider_settings')
      .where({ project_id: projectId })
      .select('id', 'project_id', 'provider_name', 'base_url', 'model_name')
      .first();
      
    return settings || null;
  }
  
  async updateSettingsForProject(projectId: number, dto: UpdateAiSettingsDto) {
    const { provider_name, base_url, model_name, api_key } = dto;
    
    let encrypted_api_key: string | null = null;
    if (api_key) {
        encrypted_api_key = this.encryptionService.encrypt(api_key);
    }
    
    const payload = {
        project_id: projectId,
        provider_name,
        base_url,
        model_name,
        encrypted_api_key,
        encryption_key_version: 1, // Задел на будущее
        updated_at: new Date()
    };

    await this.knex('ai_provider_settings')
      .insert(payload)
      .onConflict('project_id')
      .merge();
      
    // Сбрасываем кэш для данного проекта, чтобы при следующем запросе использовались новые настройки
    this.clientCache.delete(projectId);

    return { message: 'AI settings updated successfully.' };
  }

  async listModelsForProject(projectId: number): Promise<{ id: string }[]> {
    const { client } = await this.getClientForProject(projectId);
    try {
        const models = await client.models.list();
        return models.data.map(m => ({ id: m.id }));
    } catch (error) {
        this.logger.error(`Failed to fetch models for project ${projectId}`, error);
        throw new InternalServerErrorException('Could not connect to the AI provider to list models. Check the base URL and API key.');
    }
  }

  private getDecompositionPrompt(title: string, description?: string): string { return ''; }
  private getBranchNamePrompt(title: string): string { return ''; }
  private async generateText(client: OpenAI, modelName: string, prompt: string): Promise<string> { return Promise.resolve(''); }
}

================================================
FILE: api/src/ai/dto/ai-settings.dto.ts
================================================
import { IsString, IsNotEmpty, IsOptional, IsUrl } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';

export class AiProviderSettingsDto {
  @ApiProperty({ description: 'The base URL of the AI provider API.', example: 'http://localhost:1234/v1' })
  @IsUrl()
  @IsNotEmpty()
  baseUrl: string;
  
  @ApiProperty({ description: 'The API key for the provider. Will be encrypted.', required: false, example: 'sk-...' })
  @IsOptional()
  @IsString()
  apiKey?: string;
  
  @ApiProperty({ description: 'The specific model to use from the provider.', required: false, example: 'lmstudio-community/Meta-Llama-3-8B-Instruct-GGUF' })
  @IsOptional()
  @IsString()
  modelName?: string;
}

================================================
FILE: api/src/ai/dto/assist-request.dto.ts
================================================
// api/src/ai/dto/assist-request.dto.ts

// Минимальная заглушка, чтобы удовлетворить компилятор.
// Реальная реализация будет позже.

export enum ContextType {
  TASK = 'task',
}

export enum AiAction {
  DECOMPOSE = 'decompose',
  GENERATE_BRANCH_NAME = 'generate_branch_name',
}

export class AssistRequestDto {
  action: AiAction;
  contextType: ContextType;
  contextId: string;
}

================================================
FILE: api/src/ai/dto/update-ai-settings.dto.ts
================================================
import { IsString, IsNotEmpty, IsOptional, IsUrl } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';

export class UpdateAiSettingsDto {
  @ApiProperty({ description: "Identifier for the AI provider, e.g., 'openai_compatible' or 'google_gemini'", example: 'openai_compatible' })
  @IsString()
  @IsNotEmpty()
  provider_name: string;

  @ApiProperty({ description: 'The base URL for the AI provider API.', example: 'http://localhost:1234/v1' })
  @IsUrl()
  base_url: string;

  @ApiProperty({ description: 'The specific model to use for AI requests.', required: false, example: 'lmstudio-community/Meta-Llama-3-8B-Instruct-GGUF' })
  @IsOptional()
  @IsString()
  model_name?: string;

  @ApiProperty({ description: 'The API Key for the provider. Will be stored encrypted. Not returned on GET requests.', required: false })
  @IsOptional()
  @IsString()
  api_key?: string;
}

================================================
FILE: api/src/app.controller.spec.ts
================================================
import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { ConfigModule } from '@nestjs/config'; // Import ConfigModule

describe('AppController', () => {
  let app: INestApplication;
  let appController: AppController;

  beforeEach(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [ConfigModule.forRoot({ isGlobal: true })], // Add ConfigModule here
      controllers: [AppController],
      // No providers needed if AppController has no direct service dependencies for /health
    }).compile();

    appController = moduleFixture.get<AppController>(AppController);

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  afterEach(async () => {
    await app.close();
  });

  describe('getHealth', () => {
    it('should return a health status object', () => {
      expect(appController.getHealth()).toEqual({
        status: 'ok',
        message: 'API is healthy',
      });
    });

    it('should return 200 OK for GET /health', async () => {
      const response = await request(app.getHttpServer())
        .get('/health')
        .expect(200);

      expect(response.body).toEqual({
        status: 'ok',
        message: 'API is healthy',
      });
    });
  });
});


================================================
FILE: api/src/app.controller.ts
================================================
// api/src/app.controller.ts
import { Controller, Get } from '@nestjs/common';
import { ApiExcludeController } from '@nestjs/swagger';
import { Public } from './auth/decorators/public.decorator'; // ### НОВОЕ: Импортируем декоратор

@ApiExcludeController()
@Controller()
export class AppController {
  constructor() {} 

  @Public() // ### НОВОЕ: Помечаем эндпоинт как публичный
  @Get('/health')
  getHealth(): { status: string; message: string } {
    return { status: 'ok', message: 'API is healthy' };
  }
}

================================================
FILE: api/src/app.module.ts
================================================
// api/src/app.module.ts
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { AuthModule } from './auth/auth.module';
import { ProjectsModule } from './projects/projects.module';
import { TasksModule } from './tasks/tasks.module';
import { KnexModule } from './knex/knex.module';
import { EventsModule } from './events/events.module';
import { NotificationsModule } from './notifications/notifications.module';
import { AppController } from './app.controller';
import { CommentsModule } from './comments/comments.module';
import { PoliciesGuard } from './casl/policies.guard';
import { APP_GUARD } from '@nestjs/core';
import { JwtAuthGuard } from './auth/guards/jwt-auth.guard';
// ### ИЗМЕНЕНИЕ: Убран импорт AiModule и CaslModule (который был закомментирован ранее) ###
// import { AiModule } from './ai/ai.module';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      envFilePath: process.env.NODE_ENV === 'test' ? '.env.test' : (process.env.NODE_ENV === 'development' ? '.env.dev' : '.env'),
    }),
    KnexModule,
    AuthModule,
    ProjectsModule,
    TasksModule,
    CommentsModule,
    // ### ИЗМЕНЕНИЕ: AiModule и CaslModule удалены из импортов ###
    EventsModule,
    NotificationsModule,
  ],
  controllers: [AppController],
  providers: [
    {
      provide: APP_GUARD,
      useClass: JwtAuthGuard, // JwtAuthGuard должен идти первым
    },
    {
      provide: APP_GUARD,
      useClass: PoliciesGuard,
    },
  ],
})
export class AppModule {}

================================================
FILE: api/src/auth/auth.controller.ts
================================================
// api/src/auth/auth.controller.ts
import { Controller, Post, Body, HttpCode, HttpStatus } from '@nestjs/common';
import { AuthService } from './auth.service';
import { RegisterUserDto } from './dto/register-user.dto';
import { LoginUserDto } from './dto/login-user.dto';
import { Public } from './decorators/public.decorator'; // ### НОВОЕ: Импортируем декоратор

@Controller('api/v1/auth')
export class AuthController {
  constructor(private authService: AuthService) {}

  @Public() // ### НОВОЕ: Помечаем эндпоинт как публичный
  @Post('login')
  @HttpCode(200)
  async login(@Body() loginUserDto: LoginUserDto) {
    return this.authService.login(loginUserDto);
  }

  @Public() // ### НОВОЕ: Помечаем эндпоинт как публичный
  @Post('register')
  @HttpCode(HttpStatus.CREATED)
  async register(@Body() registerUserDto: RegisterUserDto) {
    return this.authService.register(registerUserDto);
  }

  // Logout требует аутентификации, поэтому @Public() здесь не нужен
  @Post('logout')
  @HttpCode(200)
  async logout() {
    return { message: 'Logged out successfully' };
  }
}

================================================
FILE: api/src/auth/auth.module.ts
================================================
// api/src/auth/auth.module.ts
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { PassportModule } from '@nestjs/passport';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { JwtStrategy } from './jwt.strategy';
import { ProfileController } from './profile.controller';

@Module({
  imports: [
    ConfigModule,
    PassportModule.register({ session: false }),
    // ### ИЗМЕНЕНИЕ: Настраиваем JwtModule, чтобы он знал о секретном ключе ###
    JwtModule.registerAsync({
      imports: [ConfigModule],
      useFactory: async (configService: ConfigService) => ({
        secret: configService.get<string>('JWT_SECRET'),
        signOptions: { expiresIn: '24h' }, // Устанавливаем срок жизни токена
      }),
      inject: [ConfigService],
    }),
  ],
  providers: [AuthService, JwtStrategy],
  controllers: [AuthController, ProfileController], 
  exports: [AuthService],
})
export class AuthModule {}

================================================
FILE: api/src/auth/auth.service.spec.ts
================================================
import { Test, TestingModule } from '@nestjs/testing';
import { ConfigModule } from '@nestjs/config';
import { AuthService } from './auth.service';
import { JwtService } from '@nestjs/jwt';
import { ConflictException, UnauthorizedException } from '@nestjs/common';
import * as bcrypt from 'bcrypt';
import { RegisterUserDto } from './dto/register-user.dto';
import { LoginUserDto } from './dto/login-user.dto';
import { KNEX_CONNECTION } from '../knex/knex.constants';
import { UserRecord } from '../types/db-records';

jest.mock('bcrypt', () => ({
  compare: jest.fn(),
  hash: jest.fn().mockResolvedValue('mockedHashedPassword'),
}));

const mockKnex = {
  select: jest.fn().mockReturnThis(),
  where: jest.fn().mockReturnThis(),
  first: jest.fn(),
  insert: jest.fn().mockReturnThis(),
  returning: jest.fn(),
};

const knexProvider = {
  provide: KNEX_CONNECTION,
  useValue: jest.fn().mockReturnValue(mockKnex),
};

describe('AuthService', () => {
  let service: AuthService;
  let jwt: JwtService;

  const mockJwtService = {
    sign: jest.fn(),
  };

  beforeEach(async () => {
    jest.clearAllMocks();

    const module: TestingModule = await Test.createTestingModule({
      imports: [ConfigModule.forRoot({
        isGlobal: true,
        // Предоставляем мок-секрет для тестов
        ignoreEnvFile: true,
        load: [() => ({ JWT_SECRET: 'test-secret' })],
      })],
      providers: [
        AuthService,
        { provide: JwtService, useValue: mockJwtService },
        knexProvider,
      ],
    }).compile();

    service = module.get<AuthService>(AuthService);
    jwt = module.get<JwtService>(JwtService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('register', () => {
    const registerDto: RegisterUserDto = {
      email: 'test@example.com',
      name: 'Test User',
      password: 'password123',
    };

    const createdUserMock = {
      id: 'generated-uuid',
      email: registerDto.email,
      name: registerDto.name,
    };

    it('should register a new user and return an access_token', async () => {
      mockKnex.first.mockResolvedValueOnce(null);
      mockKnex.returning.mockResolvedValueOnce([createdUserMock]);
      mockJwtService.sign.mockReturnValue('mock.jwt.token');

      const result = await service.register(registerDto);

      expect(result).toEqual({ access_token: 'mock.jwt.token' });
      expect(mockJwtService.sign).toHaveBeenCalledWith({
        email: createdUserMock.email,
        sub: createdUserMock.id,
        name: createdUserMock.name,
      });
    });

    it('should throw ConflictException if email already exists', async () => {
      mockKnex.first.mockResolvedValueOnce({ email: registerDto.email });
      await expect(service.register(registerDto)).rejects.toThrow(ConflictException);
    });
  });

  describe('validateUser', () => {
    const dbUserMock = {
      id: 'some-uuid',
      email: 'test@example.com',
      name: 'Test User',
      password_hash: 'hashedPasswordFromDb',
      created_at: new Date(),
      updated_at: new Date(),
    };

    it('should return user object if validation is successful', async () => {
      mockKnex.first.mockResolvedValueOnce(dbUserMock);
      (bcrypt.compare as jest.Mock).mockResolvedValue(true);
      const { password_hash, ...expectedUser } = dbUserMock;
      const result = await service.validateUser('test@example.com', 'password123');
      expect(result).toEqual(expectedUser);
    });

    it('should return null if user not found', async () => {
      mockKnex.first.mockResolvedValueOnce(null);
      const result = await service.validateUser('test@example.com', 'password123');
      expect(result).toBeNull();
    });
  });
});

================================================
FILE: api/src/auth/auth.service.ts
================================================
// api/src/auth/auth.service.ts
import { Injectable, ConflictException, UnauthorizedException, Inject, NotFoundException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { RegisterUserDto } from './dto/register-user.dto';
import { LoginUserDto } from './dto/login-user.dto';
import * as bcrypt from 'bcrypt';
import { Knex } from 'knex';
import { KNEX_CONNECTION } from '../knex/knex.constants';
import * as crypto from 'crypto';
import { UserRecord } from '../types/db-records';
import { UpdateProfileDto } from './dto/update-profile.dto';

@Injectable()
export class AuthService {
  constructor(
    @Inject(KNEX_CONNECTION) private readonly knex: Knex,
    private readonly jwtService: JwtService,
    // ### ИЗМЕНЕНИЕ: ConfigService больше не нужен здесь напрямую ###
  ) {}

  async validateUser(email: string, pass: string): Promise<UserRecord | null> {
    const user: UserRecord & { password_hash?: string } = await this.knex('users')
        .select('id', 'email', 'name', 'password_hash', 'created_at', 'updated_at')
        .where({ email })
        .first();

    if (user && user.password_hash) {
      const isMatch = await bcrypt.compare(pass, user.password_hash);
      if (isMatch) {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const { password_hash, ...result } = user;
        return result as UserRecord;
      }
    }
    return null;
  }

  async login(dto: LoginUserDto) {
    const user = await this.validateUser(dto.email, dto.password);
    if (!user) {
      throw new UnauthorizedException('Invalid credentials');
    }
    const payload = { email: user.email, sub: user.id, name: user.name };
    return {
      // ### ИЗМЕНЕНИЕ: Просто используем JwtService, он уже настроен с секретом ###
      access_token: this.jwtService.sign(payload),
    };
  }

  async register(dto: RegisterUserDto): Promise<{ access_token: string }> {
    const existingUser = await this.knex('users').where({ email: dto.email }).first();

    if (existingUser) {
      throw new ConflictException('Email already registered');
    }

    const hashedPassword = await bcrypt.hash(dto.password, 10);
    const userId = crypto.randomUUID();

    const [insertedUser] = await this.knex('users')
      .insert({
        id: userId,
        email: dto.email,
        name: dto.name,
        password_hash: hashedPassword,
        created_at: new Date(),
        updated_at: new Date(),
      })
      .returning(['id', 'email', 'name']);

    const payload = { email: insertedUser.email, sub: insertedUser.id, name: insertedUser.name };
    return {
      access_token: this.jwtService.sign(payload),
    };
  }

  async updateProfile(userId: string, dto: UpdateProfileDto): Promise<Omit<UserRecord, 'password_hash'>> {
    const updatePayload: { name?: string; updated_at: Date } = {
        updated_at: new Date(),
    };

    if (dto.name) {
        updatePayload.name = dto.name;
    }
    
    if (Object.keys(updatePayload).length === 1) {
        const currentUser = await this.knex('users').where({ id: userId }).select('id', 'email', 'name').first();
        if (!currentUser) throw new NotFoundException('User not found');
        return currentUser;
    }
    
    const [updatedUser] = await this.knex('users')
      .where({ id: userId })
      .update(updatePayload)
      .returning(['id', 'email', 'name', 'created_at', 'updated_at']);

    return updatedUser;
  }

  async changePassword(userId: string, oldPass: string, newPass: string): Promise<void> {
    const user = await this.knex('users').where({ id: userId }).select('password_hash').first();

    if (!user) {
      throw new NotFoundException('User not found');
    }

    const isMatch = await bcrypt.compare(oldPass, user.password_hash);
    if (!isMatch) {
      throw new UnauthorizedException('Old password does not match.');
    }

    const newHashedPassword = await bcrypt.hash(newPass, 10);

    await this.knex('users')
      .where({ id: userId })
      .update({
        password_hash: newHashedPassword,
        updated_at: new Date(),
      });
  }
}

================================================
FILE: api/src/auth/decorators/get-user.decorator.ts
================================================
import { createParamDecorator, ExecutionContext } from '@nestjs/common';

export const GetUser = createParamDecorator(
  (data: string | undefined, ctx: ExecutionContext) => {
    const request = ctx.switchToHttp().getRequest();
    if (data) {
      return request.user?.[data];
    }
    return request.user;
  },
);


================================================
FILE: api/src/auth/decorators/public.decorator.ts
================================================
// api/src/auth/decorators/public.decorator.ts
import { SetMetadata } from '@nestjs/common';

export const IS_PUBLIC_KEY = 'isPublic';
export const Public = () => SetMetadata(IS_PUBLIC_KEY, true);

================================================
FILE: api/src/auth/dto/change-password.dto.ts
================================================
import { IsString, IsNotEmpty, MinLength } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';

export class ChangePasswordDto {
  @ApiProperty({
    description: 'The current password of the user.',
    example: 'OldSecurePassword123',
  })
  @IsString()
  @IsNotEmpty()
  oldPassword: string;

  @ApiProperty({
    description: 'The new password for the user. Must be at least 8 characters.',
    example: 'NewSecurePassword456',
  })
  @IsString()
  @IsNotEmpty()
  @MinLength(8)
  newPassword: string;
}

================================================
FILE: api/src/auth/dto/login-user.dto.ts
================================================
import { IsEmail, IsNotEmpty, IsString } from 'class-validator';

export class LoginUserDto {
  @IsEmail()
  @IsNotEmpty()
  email: string;

  @IsString()
  @IsNotEmpty()
  password: string;
}


================================================
FILE: api/src/auth/dto/register-user.dto.ts
================================================
import { IsEmail, IsNotEmpty, IsString, MinLength } from 'class-validator';

export class RegisterUserDto {
  @IsEmail()
  @IsNotEmpty()
  email: string;

  @IsString()
  @IsNotEmpty()
  @MinLength(2)
  name: string;

  @IsString()
  @IsNotEmpty()
  @MinLength(8)
  password: string;
}


================================================
FILE: api/src/auth/dto/update-profile.dto.ts
================================================
import { IsString, IsNotEmpty, MinLength, IsOptional } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';

export class UpdateProfileDto {
  @ApiProperty({
    description: 'The new name of the user.',
    example: 'John Doe',
    required: false,
  })
  @IsOptional()
  @IsString()
  @IsNotEmpty()
  @MinLength(2)
  name?: string;
}

================================================
FILE: api/src/auth/guards/jwt-auth.guard.ts
================================================
// api/src/auth/guards/jwt-auth.guard.ts
import { Injectable, ExecutionContext } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';
import { Reflector } from '@nestjs/core';
import { IS_PUBLIC_KEY } from '../decorators/public.decorator';
import { Observable } from 'rxjs';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {
  constructor(private reflector: Reflector) {
    super();
  }

  canActivate(context: ExecutionContext): boolean | Promise<boolean> | Observable<boolean> {
    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [
      context.getHandler(),
      context.getClass(),
    ]);

    if (isPublic) {
      return true;
    }
    
    // Если эндпоинт не публичный, вызывается стандартная логика AuthGuard('jwt')
    return super.canActivate(context);
  }
}

================================================
FILE: api/src/auth/jwt.strategy.ts
================================================
import { Injectable, Inject } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { Strategy, ExtractJwt } from 'passport-jwt';
import { ConfigService } from '@nestjs/config';
import { KNEX_CONNECTION } from '../knex/knex.constants';
import { Knex } from 'knex';

export interface JwtPayload {
  email: string;
  sub: string; // User ID
  name: string;
}

export type AuthenticatedUser = {
  id: string;
  email: string;
  name: string;
  role: 'admin' | 'user'; // ### НОВОЕ: Добавлена роль в объект пользователя
}

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(
    private readonly configService: ConfigService,
    // ### НОВОЕ: Инжектируем Knex для получения роли
    @Inject(KNEX_CONNECTION) private readonly knex: Knex,
  ) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: configService.get<string>('JWT_SECRET'),
    });
  }

  // ### ИЗМЕНЕНИЕ: Метод validate теперь получает роль из БД и добавляет ее в объект пользователя
  async validate(payload: JwtPayload): Promise<AuthenticatedUser> {
    const user = await this.knex('users').where({ id: payload.sub }).select('role').first();
    const role = user ? user.role : 'user';

    return { 
      id: payload.sub, 
      email: payload.email, 
      name: payload.name,
      role: role,
    };
  }
}

================================================
FILE: api/src/auth/profile.controller.ts
================================================
import { Controller, Get, UseGuards, Patch, Body, Post, HttpCode, HttpStatus } from '@nestjs/common';
import { ApiTags, ApiBearerAuth, ApiOperation, ApiResponse } from '@nestjs/swagger';
import { JwtAuthGuard } from './guards/jwt-auth.guard';
import { GetUser } from './decorators/get-user.decorator';
import { UserRecord } from '../types/db-records';
import { UpdateProfileDto } from './dto/update-profile.dto';
import { ChangePasswordDto } from './dto/change-password.dto';
import { AuthService } from './auth.service';

@ApiBearerAuth()
@ApiTags('Profile')
@UseGuards(JwtAuthGuard)
// ### ИЗМЕНЕНИЕ: Добавляем префикс /api/v1 ###
@Controller('api/v1/profile')
export class ProfileController {
  constructor(private authService: AuthService) {}

  @Get('me')
  @ApiOperation({ summary: 'Get current user profile' })
  @ApiResponse({ status: 200, description: 'Returns the current user profile.' })
  getProfile(@GetUser() user: Omit<UserRecord, 'password_hash'>) {
    return user;
  }

  @Patch('me')
  @ApiOperation({ summary: 'Update current user profile' })
  @ApiResponse({ status: 200, description: 'Profile updated successfully.' })
  @ApiResponse({ status: 400, description: 'Invalid input.' })
  updateProfile(
    @GetUser('id') userId: string,
    @Body() updateProfileDto: UpdateProfileDto,
  ): Promise<Omit<UserRecord, 'password_hash'>> {
    return this.authService.updateProfile(userId, updateProfileDto);
  }

  @Post('change-password')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'Change current user password' })
  @ApiResponse({ status: 200, description: 'Password changed successfully.' })
  @ApiResponse({ status: 400, description: 'Invalid input (e.g., weak new password).' })
  @ApiResponse({ status: 401, description: 'Old password does not match.' })
  async changePassword(
    @GetUser('id') userId: string,
    @Body() changePasswordDto: ChangePasswordDto,
  ): Promise<{ message: string }> {
    await this.authService.changePassword(
      userId,
      changePasswordDto.oldPassword,
      changePasswordDto.newPassword,
    );
    return { message: 'Password changed successfully.' };
  }
}

================================================
FILE: api/src/casl/check-policies.decorator.ts
================================================
// api/src/casl/check-policies.decorator.ts

import { SetMetadata } from '@nestjs/common';
// Импортируем наш новый тип для класса политики
import { PolicyHandlerClass } from './policy.interface';

export const CHECK_POLICIES_KEY = 'check_policy';

// Декоратор теперь принимает массив классов политик
export const CheckPolicies = (...handlers: PolicyHandlerClass[]) =>
  SetMetadata(CHECK_POLICIES_KEY, handlers);

================================================
FILE: api/src/casl/policies.guard.spec.ts
================================================
import { Test, TestingModule } from '@nestjs/testing';
import { Reflector } from '@nestjs/core';
import { ExecutionContext, ForbiddenException, NotFoundException, InternalServerErrorException } from '@nestjs/common';
import { PoliciesGuard } from './policies.guard';
import { ProjectsService } from '../projects/projects.service';
import { TasksService } from '../tasks/tasks.service';
import { Role } from './roles.enum';
import { CanViewProjectPolicy, CanEditProjectContentPolicy, CanManageProjectSettingsPolicy } from './project-policies.handler';
import { CHECK_POLICIES_KEY } from './check-policies.decorator';
import { IS_PUBLIC_KEY } from '../auth/decorators/public.decorator';

const mockProjectsService = {
  getUserRoleForProject: jest.fn(),
};

const mockTasksService = {
  getUserRoleForTask: jest.fn(),
};

describe('PoliciesGuard', () => {
  let guard: PoliciesGuard;
  let reflector: Reflector;

  const createMockExecutionContext = (user: any, params: any, path: string): ExecutionContext => {
    return {
      getHandler: () => ({}),
      getClass: () => ({}),
      switchToHttp: () => ({
        getRequest: () => ({
          user,
          params,
          path,
        }),
      }),
    } as any;
  };

  beforeEach(async () => {
    jest.clearAllMocks();

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        PoliciesGuard,
        { provide: ProjectsService, useValue: mockProjectsService },
        { provide: TasksService, useValue: mockTasksService },
        // ### ИЗМЕНЕНИЕ: Мок Reflector теперь включает метод 'get' ###
        { 
          provide: Reflector, 
          useValue: { 
            getAllAndOverride: jest.fn(),
            get: jest.fn(), // Добавляем недостающий метод
          } 
        },
      ],
    }).compile();

    guard = module.get<PoliciesGuard>(PoliciesGuard);
    reflector = module.get<Reflector>(Reflector);
  });
  
  it('should be defined', () => {
    expect(guard).toBeDefined();
  });

  describe('Authorization Logic', () => {
    const user = { id: 'user-id-1', role: 'user' };

    it('should DENY access if policy check fails', async () => {
      mockProjectsService.getUserRoleForProject.mockResolvedValue(Role.Editor);
      // Мокируем, что эндпоинт НЕ публичный
      (reflector.getAllAndOverride as jest.Mock).mockReturnValueOnce(false); // For IS_PUBLIC_KEY
      // Мокируем, что эндпоинт требует политику CanManageProjectSettingsPolicy
      (reflector.get as jest.Mock).mockReturnValue([CanManageProjectSettingsPolicy]); // For CHECK_POLICIES_KEY

      const context = createMockExecutionContext(user, { id: 1 }, '/api/v1/projects/1/settings');
      await expect(guard.canActivate(context)).rejects.toThrow(ForbiddenException);
    });

    it('should ALLOW access if policy check passes', async () => {
      mockProjectsService.getUserRoleForProject.mockResolvedValue(Role.Owner);
      (reflector.getAllAndOverride as jest.Mock).mockReturnValueOnce(false);
      (reflector.get as jest.Mock).mockReturnValue([CanManageProjectSettingsPolicy]);

      const context = createMockExecutionContext(user, { id: 1 }, '/api/v1/projects/1/settings');
      await expect(guard.canActivate(context)).resolves.toBe(true);
    });

    it('should ALLOW access for admin role regardless of policies', async () => {
      const adminUser = { ...user, role: 'admin' };
      (reflector.getAllAndOverride as jest.Mock).mockReturnValueOnce(false); // Не публичный

      const context = createMockExecutionContext(adminUser, { id: 1 }, '/api/v1/projects/1');
      await expect(guard.canActivate(context)).resolves.toBe(true);
    });

    it('should ALLOW access if route is public', async () => {
      (reflector.getAllAndOverride as jest.Mock).mockReturnValueOnce(true); // Публичный

      const context = createMockExecutionContext(null, {}, '/health');
      await expect(guard.canActivate(context)).resolves.toBe(true);
    });
    
    it('should call tasksService for task-related routes', async () => {
      mockTasksService.getUserRoleForTask.mockResolvedValue(Role.Editor);
      (reflector.getAllAndOverride as jest.Mock).mockReturnValueOnce(false);
      (reflector.get as jest.Mock).mockReturnValue([CanEditProjectContentPolicy]);
      
      const context = createMockExecutionContext(user, { id: 'task-uuid' }, '/api/v1/tasks/task-uuid');
      await guard.canActivate(context);

      expect(mockTasksService.getUserRoleForTask).toHaveBeenCalledWith('task-uuid', user.id);
      expect(mockProjectsService.getUserRoleForProject).not.toHaveBeenCalled();
    });
  });
});

================================================
FILE: api/src/casl/policies.guard.ts
================================================
// api/src/casl/policies.guard.ts
import { Injectable, CanActivate, ExecutionContext, ForbiddenException, NotFoundException, InternalServerErrorException } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { CHECK_POLICIES_KEY } from './check-policies.decorator';
import { PolicyHandlerClass } from './policy.interface';
import { ProjectsService } from '../projects/projects.service';
import { TasksService } from '../tasks/tasks.service';
import { Role } from './roles.enum';
import { AuthenticatedUser } from '../auth/jwt.strategy';
import { IS_PUBLIC_KEY } from '../auth/decorators/public.decorator';

@Injectable()
export class PoliciesGuard implements CanActivate {
  constructor(
    private reflector: Reflector,
    private projectsService: ProjectsService,
    private tasksService: TasksService,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [
      context.getHandler(),
      context.getClass(),
    ]);
    if (isPublic) {
      return true;
    }

    const request = context.switchToHttp().getRequest();
    const user = request.user as AuthenticatedUser;

    if (!user) {
      throw new InternalServerErrorException('PoliciesGuard used without a valid user context. Ensure JwtAuthGuard runs first.');
    }
    
    if ((user as any).role === 'admin') {
      return true;
    }

    const policyHandlers =
      this.reflector.get<PolicyHandlerClass[]>(
        CHECK_POLICIES_KEY,
        context.getHandler(),
      ) || [];

    if (policyHandlers.length === 0) {
      return true;
    }
    
    const params = request.params;
    let userRole: Role | null = null;

    try {
      // ### НОВОЕ: Добавлена логика для обработки human-readable ID (:hid) ###
      if (params.hid) {
          const projectId = await this.tasksService.getProjectIdByHumanId(params.hid);
          userRole = await this.projectsService.getUserRoleForProject(projectId, user.id);
      } else if (params.taskId || (params.id && request.path.includes('/tasks/'))) {
          const taskId = params.taskId || params.id;
          userRole = await this.tasksService.getUserRoleForTask(taskId, user.id);
      } else if (params.projectId || params.id) {
          const projectId = parseInt(params.projectId || params.id, 10);
          if (isNaN(projectId)) throw new NotFoundException('Invalid Project ID format.');
          userRole = await this.projectsService.getUserRoleForProject(projectId, user.id);
      }
    } catch (error) {
      if (error instanceof NotFoundException) {
        throw error;
      }
      throw new ForbiddenException('You do not have permission to access this resource.');
    }


    if (userRole === null) {
        throw new ForbiddenException('You do not have permission to access this resource.');
    }
    
    const allPoliciesPassed = policyHandlers.every((Handler) => {
        const handler = new Handler();
        return handler.handle({ role: userRole });
    });

    if (!allPoliciesPassed) {
      throw new ForbiddenException('You do not have permission to perform this action.');
    }
    
    return true;
  }
}

================================================
FILE: api/src/casl/policy.interface.ts
================================================
// api/src/casl/policy.interface.ts
import { Role } from './roles.enum';

// Контекст теперь - это просто объект с ролью пользователя
export interface PolicyHandlerContext {
  role: Role;
}

// Обработчик - это просто функция, которая принимает роль и возвращает true/false
export interface IPolicyHandler {
  handle(context: PolicyHandlerContext): boolean;
}

export type PolicyHandlerClass = new () => IPolicyHandler;

================================================
FILE: api/src/casl/project-policies.handler.ts
================================================
// api/src/casl/project-policies.handler.ts
import { IPolicyHandler, PolicyHandlerContext } from './policy.interface';
import { Role } from './roles.enum';

export class CanEditProjectContentPolicy implements IPolicyHandler {
  handle(context: PolicyHandlerContext): boolean {
    return context.role === Role.Owner || context.role === Role.Editor;
  }
}

export class CanManageProjectSettingsPolicy implements IPolicyHandler {
  handle(context: PolicyHandlerContext): boolean {
    return context.role === Role.Owner;
  }
}

// ### ИЗМЕНЕНИЕ: Добавлена новая политика для просмотра ###
// Разрешает доступ всем участникам проекта, включая Viewer.
export class CanViewProjectPolicy implements IPolicyHandler {
  handle(context: PolicyHandlerContext): boolean {
    return context.role === Role.Owner || context.role === Role.Editor || context.role === Role.Viewer;
  }
}

================================================
FILE: api/src/casl/roles.enum.ts
================================================
// Этот enum определяет все возможные роли в проекте.
export enum Role {
    Owner = 'owner',
    Editor = 'editor',
    Viewer = 'viewer', // Добавим для будущего использования
}

================================================
FILE: api/src/comments/comments.module.ts
================================================
// api/src/comments/comments.module.ts
import { Module } from '@nestjs/common';
import { CommentsService } from './comments.service';
import { KnexModule } from '../knex/knex.module';
import { EventsModule } from '../events/events.module';
// ### ИЗМЕНЕНИЕ: Убран импорт NotificationsModule, так как он больше не нужен напрямую
// import { NotificationsModule } from '../notifications/notifications.module'; 

@Module({
  // ### ИЗМЕНЕНИЕ: Убран импорт NotificationsModule
  imports: [KnexModule, EventsModule], 
  // ### ИЗМЕНЕНИЕ: Убран CommentsController из providers и exports
  providers: [CommentsService],
  exports: [CommentsService],
})
export class CommentsModule {}

================================================
FILE: api/src/comments/comments.service.spec.ts
================================================
import { Test, TestingModule } from '@nestjs/testing';
import { CommentsService } from './comments.service';
import { EventsGateway } from '../events/events.gateway';
import { NotFoundException } from '@nestjs/common';
import { KNEX_CONNECTION } from '../knex/knex.constants';
import { UserRecord } from 'src/types/db-records';

const mockKnex = {
  where: jest.fn().mockReturnThis(),
  select: jest.fn().mockReturnThis(),
  first: jest.fn(),
  insert: jest.fn().mockReturnThis(),
  returning: jest.fn().mockResolvedValue([{ id: 'comment-uuid', text: 'Test comment', task_id: 'task1', author_id: 'user1' }]),
  orderBy: jest.fn().mockReturnThis(),
  whereIn: jest.fn().mockReturnThis(),
};

const knexProvider = {
  provide: KNEX_CONNECTION,
  useValue: jest.fn().mockReturnValue(mockKnex),
};

describe('CommentsService', () => {
  let service: CommentsService;
  const eventsGatewayMock = { emitCommentCreated: jest.fn() };

  // ### ИЗМЕНЕНИЕ: Добавлено поле role ###
  const mockUser: UserRecord = { id: 'user1', name: 'User One', email: 'user1@example.com', password_hash: 'hash', role: 'user', created_at: new Date(), updated_at: new Date() };
  const mockTaskData = { id: 'task1', project_id: 1 };
  
  beforeEach(async () => {
    jest.clearAllMocks();

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        CommentsService,
        knexProvider,
        { provide: EventsGateway, useValue: eventsGatewayMock },
      ],
    }).compile();
    service = module.get<CommentsService>(CommentsService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('createComment', () => {
    it('should create a comment and emit an event', async () => {
      mockKnex.first.mockResolvedValueOnce(mockTaskData);
      mockKnex.first.mockResolvedValueOnce(mockUser);

      const dto = { text: 'Test comment' };
      const result = await service.createComment('task1', dto, 'user1');

      expect(result.text).toBe(dto.text);
      expect(eventsGatewayMock.emitCommentCreated).toHaveBeenCalled();
    });

    it('should throw NotFoundException if task not found', async () => {
      mockKnex.first.mockResolvedValueOnce(null);
      const dto = { text: 'Test comment' };
      await expect(service.createComment('task-unknown', dto, 'user1')).rejects.toThrow(NotFoundException);
    });
  });
});

================================================
FILE: api/src/comments/comments.service.ts
================================================
// api/src/comments/comments.service.ts
import { Injectable, NotFoundException, Inject } from '@nestjs/common';
import { CreateCommentDto } from './dto/create-comment.dto';
import { Knex } from 'knex';
import { KNEX_CONNECTION } from '../knex/knex.constants';
import * as crypto from 'crypto';
import { CommentRecord, UserRecord } from '../types/db-records';
import { EventsGateway } from '../events/events.gateway';

@Injectable()
export class CommentsService {
  constructor(
    @Inject(KNEX_CONNECTION) private readonly knex: Knex,
    private readonly eventsGateway: EventsGateway, // EventsGateway нужен для оповещений
  ) {}

  async createComment(taskId: string, dto: CreateCommentDto, authorId: string): Promise<CommentRecord> {
    const task = await this.knex('tasks')
      .where({ id: taskId })
      .select('id', 'project_id')
      .first();

    if (!task) {
      throw new NotFoundException(`Task with ID ${taskId} not found.`);
    }

    const [newComment] = await this.knex('comments')
      .insert({
        id: crypto.randomUUID(),
        text: dto.text,
        task_id: taskId,
        author_id: authorId,
      })
      .returning('*');

    const author = await this.knex('users').where({ id: authorId }).select('id', 'name', 'email').first();
    const fullComment: CommentRecord = { ...newComment, author };

    // Оповещаем другие системы через gateway
    this.eventsGateway.emitCommentCreated(fullComment, task.project_id);
    
    return fullComment;
  }

  async getCommentsForTask(taskId: string): Promise<CommentRecord[]> {
    const comments = await this.knex('comments')
      .where({ task_id: taskId })
      .orderBy('created_at', 'asc');
      
    const authorIds = [...new Set(comments.map(c => c.author_id).filter(Boolean))];
    if (authorIds.length === 0) {
        return comments.map(c => ({...c, author: null}));
    }
    const authors = await this.knex('users').whereIn('id', authorIds).select('id', 'name', 'email');
    const authorsMap = new Map(authors.map(a => [a.id, a]));

    return comments.map(comment => ({
      ...comment,
      author: comment.author_id ? authorsMap.get(comment.author_id) : undefined,
    }));
  }
}

================================================
FILE: api/src/comments/dto/create-comment.dto.ts
================================================
import { IsNotEmpty, IsString, MinLength } from 'class-validator';

export class CreateCommentDto {
  @IsString()
  @IsNotEmpty()
  @MinLength(1)
  text: string;
}

================================================
FILE: api/src/common/filters/global-exception.filter.ts
================================================
import {
    ExceptionFilter,
    Catch,
    ArgumentsHost,
    HttpException,
    HttpStatus,
    Logger,
  } from '@nestjs/common';
  import { Request, Response } from 'express';
  
  @Catch() // Перехватывает ВСЕ исключения
  export class GlobalExceptionFilter implements ExceptionFilter {
    private readonly logger = new Logger(GlobalExceptionFilter.name);
  
    catch(exception: unknown, host: ArgumentsHost) {
      const ctx = host.switchToHttp();
      const response = ctx.getResponse<Response>();
      const request = ctx.getRequest<Request>();
  
      const status =
        exception instanceof HttpException
          ? exception.getStatus()
          : HttpStatus.INTERNAL_SERVER_ERROR;
  
      const message =
        exception instanceof HttpException
          ? exception.getResponse()
          : 'Internal server error';
      
      const errorResponse = {
        statusCode: status,
        timestamp: new Date().toISOString(),
        path: request.url,
        method: request.method,
        // Если у HttpException есть сложное сообщение (как у ValidationPipe), оно будет здесь
        message: (message as any).message || message,
      };
      
      // Логируем все ошибки для отладки
      this.logger.error(
        `HTTP Status: ${status} Error Message: ${JSON.stringify(message)}`,
        exception instanceof Error ? exception.stack : '',
        `${request.method} ${request.url}`
      );
  
      response.status(status).json(errorResponse);
    }
  }

================================================
FILE: api/src/common/services/encryption.service.ts
================================================
import { Injectable, InternalServerErrorException, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import * as crypto from 'crypto';

const ALGORITHM = 'aes-256-gcm';
const IV_LENGTH = 16;
const AUTH_TAG_LENGTH = 16;

@Injectable()
export class EncryptionService {
  private readonly logger = new Logger(EncryptionService.name);
  private encryptionKey: Buffer;

  constructor(private configService: ConfigService) {
    const keyHex = this.configService.get<string>('AI_CREDENTIALS_ENCRYPTION_KEY');
    if (!keyHex) {
        this.logger.warn('AI_CREDENTIALS_ENCRYPTION_KEY is not set. Encryption service will be disabled.');
        return;
    }
    if (keyHex.length !== 64) {
        throw new Error('AI_CREDENTIALS_ENCRYPTION_KEY must be 32 bytes (64 hex characters) long.');
    }
    this.encryptionKey = Buffer.from(keyHex, 'hex');
    this.logger.log('Encryption service initialized successfully.');
  }

  encrypt(text: string): string {
    if (!this.encryptionKey) {
        throw new InternalServerErrorException('Encryption key is not configured.');
    }
    
    const iv = crypto.randomBytes(IV_LENGTH);
    const cipher = crypto.createCipheriv(ALGORITHM, this.encryptionKey, iv);
    
    const encrypted = Buffer.concat([cipher.update(text, 'utf8'), cipher.final()]);
    const authTag = cipher.getAuthTag();

    // Храним iv, authTag и зашифрованные данные вместе в одной hex-строке
    return Buffer.concat([iv, authTag, encrypted]).toString('hex');
  }

  decrypt(encryptedText: string): string {
    if (!this.encryptionKey) {
      throw new InternalServerErrorException('Encryption key is not configured.');
    }

    /*
     * Для будущей ротации ключей:
     * 1. В БД добавить поле `encryption_key_version`.
     * 2. В .env хранить несколько ключей: AI_CREDENTIALS_ENCRYPTION_KEY_V1, AI_CREDENTIALS_ENCRYPTION_KEY_V2 и т.д.
     * 3. В конструкторе загрузить все ключи в Map<number, Buffer>.
     * 4. Этот метод будет принимать `keyVersion` и выбирать нужный ключ из Map для дешифровки.
     */

    const data = Buffer.from(encryptedText, 'hex');
    const iv = data.slice(0, IV_LENGTH);
    const authTag = data.slice(IV_LENGTH, IV_LENGTH + AUTH_TAG_LENGTH);
    const encrypted = data.slice(IV_LENGTH + AUTH_TAG_LENGTH);
    
    const decipher = crypto.createDecipheriv(ALGORITHM, this.encryptionKey, iv);
    decipher.setAuthTag(authTag);
    
    const decrypted = Buffer.concat([decipher.update(encrypted), decipher.final()]);
    
    return decrypted.toString('utf8');
  }
}

================================================
FILE: api/src/events/events.gateway.ts
================================================
import {
  WebSocketGateway,
  WebSocketServer,
  SubscribeMessage,
  MessageBody,
  OnGatewayConnection,
  OnGatewayDisconnect,
  ConnectedSocket,
} from '@nestjs/websockets';
import { Server, Socket } from 'socket.io';
import { Logger } from '@nestjs/common';
import { TaskRecord, CommentRecord, NotificationRecord } from 'src/types/db-records';

@WebSocketGateway({
  cors: {
    origin: '*', // В production следует указать конкретный домен фронтенда
  },
})
export class EventsGateway implements OnGatewayConnection, OnGatewayDisconnect {
  @WebSocketServer()
  server: Server;

  private logger: Logger = new Logger('EventsGateway');

  handleConnection(client: Socket) {
    this.logger.log(`Client connected: ${client.id}`);
  }

  handleDisconnect(client: Socket) {
    this.logger.log(`Client disconnected: ${client.id}`);
  }

  @SubscribeMessage('joinProjectRoom')
  handleJoinRoom(@MessageBody() projectId: string, @ConnectedSocket() client: Socket) {
    const room = `project:${projectId}`;
    this.logger.log(`Client ${client.id} joining project room: ${room}`);
    client.join(room);
    return { event: 'joinedProjectRoom', data: projectId };
  }

  @SubscribeMessage('joinUserRoom')
  handleJoinUserRoom(@MessageBody() userId: string, @ConnectedSocket() client: Socket) {
      if (userId && typeof userId === 'string') {
          const room = `user:${userId}`;
          this.logger.log(`Client ${client.id} joining user room: ${room}`);
          client.join(room);
          return { event: 'joinedUserRoom', data: room };
      }
      return { event: 'joinUserRoomFailed', data: 'Invalid userId provided' };
  }

  // --- Методы для отправки событий из сервисов ---

  emitTaskCreated(task: TaskRecord) {
    const room = `project:${task.project_id}`;
    this.logger.log(`Emitting task:created to room ${room}`);
    this.server.to(room).emit('task:created', task);
  }

  emitTaskUpdated(task: TaskRecord) {
    const room = `project:${task.project_id}`;
    this.logger.log(`Emitting task:updated to room ${room}`);
    this.server.to(room).emit('task:updated', task);
  }

  emitTaskMoved(task: TaskRecord) {
    const room = `project:${task.project_id}`;
    this.logger.log(`Emitting task:moved to room ${room}`);
    this.server.to(room).emit('task:moved', task);
  }

  emitCommentCreated(comment: CommentRecord, projectId: number) {
    const room = `project:${projectId}`;
    this.logger.log(`Emitting comment:created to room ${room}`);
    this.server.to(room).emit('comment:created', comment);
  }

  emitCommentDeleted(commentId: string, taskId: string, projectId: number) {
    const room = `project:${projectId}`;
    this.logger.log(`Emitting comment:deleted to room ${room}`);
    this.server.to(room).emit('comment:deleted', { commentId, taskId });
  }

  emitNotificationNew(notification: NotificationRecord) {
    const room = `user:${notification.recipient_id}`;
    this.logger.log(`Emitting notification:new to room ${room}`);
    this.server.to(room).emit('notification:new', notification);
  }

  emitNotificationRead(notification: NotificationRecord) {
    const room = `user:${notification.recipient_id}`;
    this.logger.log(`Emitting notification:read to room ${room}`);
    this.server.to(room).emit('notification:read', notification);
  }
}

================================================
FILE: api/src/events/events.module.ts
================================================
import { Module } from '@nestjs/common';
import { EventsGateway } from './events.gateway';

@Module({
  providers: [EventsGateway],
  exports: [EventsGateway], // Export gateway to be used in other modules
})
export class EventsModule {}


================================================
FILE: api/src/knex/knex.constants.ts
================================================
export const KNEX_CONNECTION = 'KNEX_CONNECTION';


================================================
FILE: api/src/knex/knex.module.ts
================================================
import { Module, Global, Logger } from '@nestjs/common'; // Added Logger
import { KNEX_CONNECTION } from './knex.constants';
import knex from 'knex';
const knexfile = require('../../knexfile');

// Logger instance
const logger = new Logger('KnexModule');

const knexProvider = {
  provide: KNEX_CONNECTION,
  useFactory: async () => {
    // Moved config loading logic inside useFactory
    const environment = process.env.NODE_ENV || 'development';
    const knexConfig = knexfile[environment];

    if (!knexConfig) {
      // Log the error before throwing
      logger.error(`Knex configuration for environment '${environment}' not found in knexfile.js`);
      throw new Error(`Knex configuration for environment '${environment}' not found in knexfile.js`);
    }

    const db = knex(knexConfig);

    try {
      await db.raw('select 1+1 as result');
      logger.log('Successfully connected to the database using Knex.'); // Use NestJS Logger
    } catch (error) {
      // Use NestJS Logger and log the stack
      logger.error('Failed to connect to the database using Knex:', error.stack);
      throw error;
    }
    return db;
  },
};

@Global()
@Module({
  providers: [knexProvider],
  exports: [knexProvider],
})
export class KnexModule {}


================================================
FILE: api/src/main.ts
================================================
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { ValidationPipe } from '@nestjs/common';
import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';
import { GlobalExceptionFilter } from './common/filters/global-exception.filter';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  // Глобальный фильтр исключений для стандартизации ответов об ошибках
  app.useGlobalFilters(new GlobalExceptionFilter());

  // Глобальный пайп для валидации всех входящих DTO
  app.useGlobalPipes(new ValidationPipe({
    whitelist: true,
    forbidNonWhitelisted: true,
    transform: true,
    transformOptions: {
      enableImplicitConversion: true,
    }
  }));

  app.enableCors({
    origin: process.env.CLIENT_URL || 'http://localhost:3000', // Используем переменную окружения
    methods: 'GET,HEAD,PUT,PATCH,POST,DELETE,OPTIONS',
    credentials: true,
  });

  // ### ИЗМЕНЕНИЕ: Глобальный префикс убран. ###
  // Префиксы теперь заданы в каждом контроллере для явности.
  // app.setGlobalPrefix('api/v1');

  // Настройка Swagger для документирования API
  const config = new DocumentBuilder()
    .setTitle('Mutabor API')
    .setDescription('The official API for the Mutabor project management tool.')
    .setVersion('1.0')
    .addBearerAuth()
    // Swagger будет отображать пути с префиксами, заданными в контроллерах.
    .build();
  const document = SwaggerModule.createDocument(app, config);
  // ### ИЗМЕНЕНИЕ: Путь к Swagger изменен для соответствия префиксам API ###
  const swaggerPath = 'api/v1/api-docs';
  SwaggerModule.setup(swaggerPath, app, document);
  
  const port = process.env.PORT || 3001;
  await app.listen(port, '0.0.0.0');
  
  const appUrl = await app.getUrl();
  console.log(`Application is running on: ${appUrl}`);
  console.log(`Swagger documentation is available at: ${appUrl}/${swaggerPath}`);
}
bootstrap();

================================================
FILE: api/src/notifications/dto/notification.dto.ts
================================================
import { UserRecord as User } from 'src/types/db-records'; // Or a UserDto

export class NotificationDto {
  id: string;
  text: string;
  isRead: boolean;
  recipientId: string;
  sourceUrl?: string | null;
  taskId?: string | null;
  createdAt: Date;
  updatedAt: Date;
  // Optional: include recipient or task details if needed directly in DTO
  // recipient?: Partial<User>;
}


================================================
FILE: api/src/notifications/guards/notification-owner.guard.ts
================================================
// api/src/notifications/guards/notification-owner.guard.ts
import { Injectable, CanActivate, ExecutionContext, ForbiddenException, NotFoundException, Inject } from '@nestjs/common';
import { KNEX_CONNECTION } from '../../knex/knex.constants';
import { Knex } from 'knex';
import { AuthenticatedUser } from '../../auth/jwt.strategy';

@Injectable()
export class NotificationOwnerGuard implements CanActivate {
  constructor(@Inject(KNEX_CONNECTION) private readonly knex: Knex) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest();
    const user = request.user as AuthenticatedUser;
    const notificationId = request.params.id;

    if (!user || !notificationId) {
      // This case should ideally not be hit if JwtAuthGuard is used before this guard
      return false;
    }

    const notification = await this.knex('notifications')
      .where({ id: notificationId })
      .select('recipient_id')
      .first();

    if (!notification) {
      // Важно не раскрывать, существует ли уведомление, если у пользователя нет к нему доступа.
      // Поэтому в случае отсутствия или несовпадения владельца бросаем одну и ту же ошибку.
      throw new ForbiddenException('You do not have permission to access this resource.');
    }

    if (notification.recipient_id !== user.id) {
      throw new ForbiddenException('You do not have permission to access this resource.');
    }
    
    return true;
  }
}

================================================
FILE: api/src/notifications/notifications.controller.spec.ts
================================================
import { Test, TestingModule } from '@nestjs/testing';
import { NotificationsController } from './notifications.controller';
import { NotificationsService } from './notifications.service';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import * as crypto from 'crypto';
import { AuthenticatedUser } from '../auth/jwt.strategy';
import { NotificationRecord } from '../types/db-records';
import { NotificationOwnerGuard } from './guards/notification-owner.guard'; // ### НОВОЕ: Импортируем гвард

describe('NotificationsController', () => {
  let app: INestApplication;
  let serviceMock: Partial<NotificationsService>;

  const mockUser: AuthenticatedUser = { id: 'user1', email: 'test@example.com', name: 'Test User', role: 'user' };

  beforeAll(async () => {
    serviceMock = {
      getNotificationsForUser: jest.fn().mockResolvedValue([]),
      markAsRead: jest.fn().mockImplementation((id: string, userId: string): Promise<NotificationRecord> => Promise.resolve({ id, recipient_id: userId, is_read: true, text: 'Notification ' + id, created_at: new Date(), updated_at: new Date(), source_url: null, task_id: null })),
      markAllAsReadForUser: jest.fn().mockResolvedValue({ updatedCount: 5 }),
    };

    const moduleFixture: TestingModule = await Test.createTestingModule({
      controllers: [NotificationsController],
      providers: [{ provide: NotificationsService, useValue: serviceMock }],
    })
    .overrideGuard(JwtAuthGuard)
    .useValue({ canActivate: (context) => {
        const req = context.switchToHttp().getRequest();
        req.user = mockUser;
        return true;
      }
    })
    // ### НОВОЕ: Отключаем NotificationOwnerGuard для тестов этого контроллера ###
    .overrideGuard(NotificationOwnerGuard)
    .useValue({ canActivate: () => true })
    .compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  afterAll(async () => {
    await app.close();
  });

  it('should be defined', () => {
    const controller = app.get<NotificationsController>(NotificationsController);
    expect(controller).toBeDefined();
  });

  describe('GET /notifications', () => {
    it('should return user notifications', async () => {
      const notifications = [{ id: '1', text: 'Test', is_read: false, recipient_id: mockUser.id, created_at: new Date(), updatedAt: new Date() }];
      (serviceMock.getNotificationsForUser as jest.Mock).mockResolvedValueOnce(notifications);
      return request(app.getHttpServer()).get('/api/v1/notifications').expect(200).expect(res => {
          expect(res.body[0].id).toEqual(notifications[0].id);
          expect(serviceMock.getNotificationsForUser).toHaveBeenCalledWith(mockUser.id);
      });
    });
  });

  describe('PATCH /notifications/:id/read', () => {
    it('should mark a notification as read', async () => {
      const notificationId = crypto.randomUUID();
      return request(app.getHttpServer()).patch(`/api/v1/notifications/${notificationId}/read`).expect(200).expect(res => {
          expect(res.body.id).toEqual(notificationId);
          expect(res.body.is_read).toBe(true);
          expect(serviceMock.markAsRead).toHaveBeenCalledWith(notificationId, mockUser.id);
      });
    });
  });
  
  describe('POST /notifications/mark-all-read', () => {
    it('should mark all notifications as read', async () => {
      return request(app.getHttpServer())
        .post('/api/v1/notifications/mark-all-read')
        .expect(200)
        .expect(res => {
          expect(res.body.message).toContain('5 notifications marked as read.');
          expect(serviceMock.markAllAsReadForUser).toHaveBeenCalledWith(mockUser.id);
        });
    });
  });
});

================================================
FILE: api/src/notifications/notifications.controller.ts
================================================
import { Controller, Get, Param, Patch, UseGuards, HttpCode, HttpStatus, ParseUUIDPipe, Post } from '@nestjs/common';
import { ApiTags, ApiBearerAuth, ApiOperation, ApiResponse } from '@nestjs/swagger';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { GetUser } from '../auth/decorators/get-user.decorator';
import { NotificationsService } from './notifications.service';
import { NotificationOwnerGuard } from './guards/notification-owner.guard'; // ### НОВОЕ: Импортируем наш гвард

@ApiBearerAuth()
@ApiTags('Notifications')
@UseGuards(JwtAuthGuard) // Глобальный гвард на аутентификацию
@Controller('api/v1/notifications')
export class NotificationsController {
  constructor(private readonly notificationsService: NotificationsService) {}

  @Get()
  @ApiOperation({ summary: "Get the current user's notifications" })
  async getMyNotifications(@GetUser('id') userId: string) {
    return this.notificationsService.getNotificationsForUser(userId);
  }

  @Patch(':id/read')
  @UseGuards(NotificationOwnerGuard) // ### НОВОЕ: Применяем гвард только к этому эндпоинту
  @ApiOperation({ summary: 'Mark a notification as read' })
  @ApiResponse({ status: 200, description: 'Notification marked as read.' })
  @ApiResponse({ status: 403, description: 'Forbidden resource.' })
  @ApiResponse({ status: 404, description: 'Notification not found.' })
  @HttpCode(HttpStatus.OK)
  async markAsRead(
    @Param('id', ParseUUIDPipe) id: string,
    @GetUser('id') userId: string,
  ) {
    // Теперь логика проверки владельца находится в гварде.
    // Сервис может просто выполнять свою работу.
    return this.notificationsService.markAsRead(id, userId);
  }

  @Post('mark-all-read')
  @ApiOperation({ summary: 'Mark all of the user\'s notifications as read' })
  @ApiResponse({ status: 200, description: 'All notifications marked as read.' })
  @HttpCode(HttpStatus.OK)
  async markAllAsRead(@GetUser('id') userId: string) {
    const result = await this.notificationsService.markAllAsReadForUser(userId);
    return { message: `${result.updatedCount} notifications marked as read.` };
  }
}

================================================
FILE: api/src/notifications/notifications.module.ts
================================================
// api/src/notifications/notifications.module.ts
import { Module, forwardRef } from '@nestjs/common';
import { NotificationsService } from './notifications.service';
import { NotificationsController } from './notifications.controller';
import { EventsModule } from '../events/events.module';
import { KnexModule } from '../knex/knex.module';
import { ProjectsModule } from '../projects/projects.module';
import { NotificationOwnerGuard } from './guards/notification-owner.guard'; // ### НОВОЕ: Импортируем гвард

@Module({
  imports: [
    KnexModule, 
    EventsModule,
    // ProjectsModule нужен, чтобы получить всех участников проекта для @-упоминаний
    forwardRef(() => ProjectsModule),
  ],
  controllers: [NotificationsController],
  providers: [NotificationsService, NotificationOwnerGuard], // ### НОВОЕ: Добавляем гвард в провайдеры
  exports: [NotificationsService],
})
export class NotificationsModule {}

================================================
FILE: api/src/notifications/notifications.service.spec.ts
================================================
import { Test, TestingModule } from '@nestjs/testing';
import { NotificationsService } from './notifications.service';
import { EventsGateway } from '../events/events.gateway';
import { KNEX_CONNECTION } from '../knex/knex.constants';
import { UserRecord } from '../types/db-records';
import { ProjectsService } from '../projects/projects.service';
import { NotFoundException } from '@nestjs/common';

// ### ИЗМЕНЕНИЕ: Создаем более сложный мок для Knex ###
const mockKnexReturning = { returning: jest.fn() };
const mockKnexUpdate = { update: jest.fn(() => mockKnexReturning) };
const mockKnexWhere = { where: jest.fn(() => mockKnexUpdate) };
const mockKnex = jest.fn(() => mockKnexWhere);


const mockEventsGateway = { emitNotificationNew: jest.fn(), emitNotificationRead: jest.fn() }; // ### ИЗМЕНЕНИЕ: Добавляем emitNotificationRead
const mockProjectsService = { getProjectMembers: jest.fn(), getProjectOwner: jest.fn() };

describe('NotificationsService', () => {
  let service: NotificationsService;

  const mockUser: UserRecord = { id: 'user1', email: 'user1@example.com', name: 'User One', created_at: new Date(), updated_at: new Date(), password_hash: 'hash', role: 'user' };

  beforeEach(async () => {
    // Сбрасываем все моки перед каждым тестом
    jest.clearAllMocks();
    mockKnexReturning.returning.mockClear();
    mockKnexUpdate.update.mockClear();
    mockKnexWhere.where.mockClear();
    (mockKnex as jest.Mock).mockClear();


    const module: TestingModule = await Test.createTestingModule({
      providers: [
        NotificationsService,
        { provide: KNEX_CONNECTION, useValue: mockKnex },
        { provide: EventsGateway, useValue: mockEventsGateway },
        { provide: ProjectsService, useValue: mockProjectsService },
      ],
    }).compile();
    service = module.get<NotificationsService>(NotificationsService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  // ### НОВЫЙ ТЕСТОВЫЙ СЦЕНАРИЙ ###
  describe('markAllAsReadForUser', () => {
    it('should update all unread notifications for a user and emit events', async () => {
      const userId = 'user-with-notifications';
      const notificationsToUpdate = [
        { id: 'notif1', recipient_id: userId, is_read: true },
        { id: 'notif2', recipient_id: userId, is_read: true },
      ];

      // Настраиваем мок Knex: .returning() вернет наш массив
      mockKnexReturning.returning.mockResolvedValue(notificationsToUpdate);

      const result = await service.markAllAsReadForUser(userId);

      // Проверяем, что результат корректный
      expect(result.updatedCount).toBe(2);

      // Проверяем, что был вызван правильный запрос к БД
      expect(mockKnex).toHaveBeenCalledWith('notifications');
      expect(mockKnexWhere.where).toHaveBeenCalledWith({ recipient_id: userId, is_read: false });
      expect(mockKnexUpdate.update).toHaveBeenCalledWith(expect.objectContaining({ is_read: true }));

      // Проверяем, что для каждого уведомления было отправлено событие
      expect(mockEventsGateway.emitNotificationRead).toHaveBeenCalledTimes(2);
      expect(mockEventsGateway.emitNotificationRead).toHaveBeenCalledWith(notificationsToUpdate[0]);
      expect(mockEventsGateway.emitNotificationRead).toHaveBeenCalledWith(notificationsToUpdate[1]);
    });

    it('should return 0 and not emit events if there are no unread notifications', async () => {
      const userId = 'user-without-notifications';
      // Настраиваем мок: .returning() вернет пустой массив
      mockKnexReturning.returning.mockResolvedValue([]);

      const result = await service.markAllAsReadForUser(userId);

      // Проверяем, что результат 0
      expect(result.updatedCount).toBe(0);

      // Проверяем, что события не отправлялись
      expect(mockEventsGateway.emitNotificationRead).not.toHaveBeenCalled();
    });
  });

  describe('markAsRead', () => {
    it('should throw NotFoundException if notification does not exist', async () => {
        const notificationId = 'non-existent-id';
        const userId = 'some-user';
        
        // Настраиваем мок: .returning() вернет пустой массив
        mockKnexReturning.returning.mockResolvedValue([]);
        
        await expect(service.markAsRead(notificationId, userId)).rejects.toThrow(NotFoundException);
    });
  });
});

================================================
FILE: api/src/notifications/notifications.service.ts
================================================
// api/src/notifications/notifications.service.ts
import { Injectable, Inject, forwardRef, NotFoundException } from '@nestjs/common';
import { Knex } from 'knex';
import { KNEX_CONNECTION } from '../knex/knex.constants';
import * as crypto from 'crypto';
import { NotificationRecord, CommentRecord, UserRecord } from '../types/db-records';
import { EventsGateway } from '../events/events.gateway';
import { ProjectsService } from '../projects/projects.service';

@Injectable()
export class NotificationsService {
  constructor(
    @Inject(KNEX_CONNECTION) private readonly knex: Knex,
    private readonly eventsGateway: EventsGateway,
    @Inject(forwardRef(() => ProjectsService))
    private readonly projectsService: ProjectsService,
  ) {}

  async createNotification(
    recipientId: string,
    text: string,
    sourceUrl: string,
    taskId?: string,
    trx?: Knex.Transaction,
  ): Promise<NotificationRecord> {
    const db = trx || this.knex;
    const notificationId = crypto.randomUUID();
    const newNotificationData = {
      id: notificationId,
      recipient_id: recipientId,
      text,
      source_url: sourceUrl,
      task_id: taskId,
    };

    const [notification] = await db('notifications').insert(newNotificationData).returning('*');

    this.eventsGateway.emitNotificationNew(notification);
    return notification;
  }

  async createMentionNotifications(comment: CommentRecord, taskTitle: string, projectId: number) {
    const regex = /@([\w.-]+)/g;
    let match;
    const mentionedNames = new Set<string>();

    while ((match = regex.exec(comment.text)) !== null) {
      mentionedNames.add(match[1]);
    }

    if (mentionedNames.size === 0) return;
    
    const membersResult = await this.projectsService.getProjectMembers(projectId);
    const owner = await this.projectsService.getProjectOwner(projectId);

    const allProjectUsers = [owner, ...membersResult.map(m => m.user)];
    const uniqueUsers = Array.from(new Map(allProjectUsers.map(u => [u.id, u])).values());
    
    const usersToNotify = uniqueUsers.filter(user => 
        user.name && mentionedNames.has(user.name) && user.id !== comment.author_id
    );

    if (usersToNotify.length === 0) return;

    const sourceUrl = `/tasks/${comment.task_id}`;
    const authorName = comment.author?.name || 'Someone';
    const text = `You were mentioned by ${authorName} in a comment on task "${taskTitle}": "${comment.text.substring(0, 50)}..."`;

    for (const user of usersToNotify) {
      await this.createNotification(user.id, text, sourceUrl, comment.task_id);
    }
  }

  async getNotificationsForUser(userId: string): Promise<NotificationRecord[]> {
    return this.knex('notifications')
      .where({ recipient_id: userId })
      .orderBy('created_at', 'desc')
      .limit(50);
  }

  async markAsRead(notificationId: string, userId: string): Promise<NotificationRecord> {
    const [notification] = await this.knex('notifications')
      .where({ id: notificationId, recipient_id: userId })
      .update({ is_read: true, updated_at: new Date() })
      .returning('*');
    
    if (!notification) {
      throw new NotFoundException(`Notification with ID ${notificationId} not found or you don't have permission to access it.`);
    }

    this.eventsGateway.emitNotificationRead(notification);
    return notification;
  }

  async markAllAsReadForUser(userId: string): Promise<{ updatedCount: number }> {
    const updatedNotifications = await this.knex('notifications')
      .where({ recipient_id: userId, is_read: false })
      .update({ is_read: true, updated_at: new Date() })
      .returning('*'); // ### ИЗМЕНЕНИЕ: Возвращаем обновленные записи

    const updatedCount = updatedNotifications.length;

    if (updatedCount > 0) {
      // ### НОВОЕ: Отправляем каждое обновленное уведомление через WebSocket
      // Это позволит UI обновить статус каждого элемента в списке.
      for (const notification of updatedNotifications) {
        this.eventsGateway.emitNotificationRead(notification);
      }
    }
    
    return { updatedCount };
  }
}

================================================
FILE: api/src/projects/dto/add-member.dto.ts
================================================
// api/src/projects/dto/add-member.dto.ts
import { IsEmail, IsNotEmpty, IsEnum } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';
import { Role } from '../../casl/roles.enum';

export class AddMemberDto {
  @ApiProperty({
    description: "The email of the user to add to the project.",
    example: "member@example.com"
  })
  @IsEmail()
  @IsNotEmpty()
  email: string;

  // ### ИЗМЕНЕНИЕ: Заменяем IsString на IsEnum ###
  // Теперь принимаются только значения 'editor' или 'viewer'.
  // Роль 'owner' не включена, так как владелец назначается при создании проекта.
  @ApiProperty({ 
    description: "The role to assign to the new member.",
    enum: [Role.Editor, Role.Viewer],
    example: Role.Editor 
  })
  @IsEnum([Role.Editor, Role.Viewer])
  @IsNotEmpty()
  role: Role.Editor | Role.Viewer;
}

================================================
FILE: api/src/projects/dto/create-column.dto.ts
================================================
import { ApiProperty } from '@nestjs/swagger';
import { IsNotEmpty, IsString, MaxLength, MinLength } from 'class-validator';

export class CreateColumnDto {
  @ApiProperty({
    description: 'The name for the new column (task status)',
    example: 'Backlog',
    minLength: 1,
    maxLength: 50,
  })
  @IsString()
  @IsNotEmpty()
  @MinLength(1)
  @MaxLength(50)
  name: string;
}


================================================
FILE: api/src/projects/dto/create-project.dto.ts
================================================
import { IsString, IsNotEmpty, Matches, MaxLength } from 'class-validator';

export class CreateProjectDto {
  @IsString()
  @IsNotEmpty()
  @MaxLength(100)
  name: string;

  @IsString()
  @IsNotEmpty()
  @Matches(/^[A-Z0-9]+$/, { message: 'Prefix must be uppercase alphanumeric characters.' })
  @MaxLength(10)
  prefix: string; // For task IDs like "PROJ-1"
}


================================================
FILE: api/src/projects/dto/project-details.dto.ts
================================================
// api/src/projects/dto/project-details.dto.ts
import { ApiProperty } from '@nestjs/swagger';
import { TaskDto } from 'src/tasks/dto/task.dto';

// Вспомогательные DTO для вложенных структур
class ProjectOwnerDto {
  @ApiProperty({ example: 'a1b2c3d4-e5f6-7890-1234-567890abcdef' })
  id: string;

  @ApiProperty({ example: 'John Doe' })
  name: string;
  
  @ApiProperty({ example: 'john.doe@example.com' })
  email: string;
}

class ProjectMemberDto {
  @ApiProperty({ example: 'b2c3d4e5-f6a7-8901-2345-67890abcdef1' })
  id: string;

  @ApiProperty({ example: 'Jane Smith' })
  name: string;
  
  @ApiProperty({ example: 'jane.smith@example.com' })
  email: string;

  @ApiProperty({ example: 'editor' })
  role: string;
}

class ColumnWithTasksDto {
  @ApiProperty()
  id: string;

  @ApiProperty()
  name: string;

  @ApiProperty()
  position: number;

  @ApiProperty({ type: () => [TaskDto] }) // Используем TaskDto из модуля tasks
  tasks: TaskDto[];
}

// Основной DTO, который возвращается клиенту
export class ProjectDetailsDto {
  @ApiProperty({ example: 1 })
  id: number;

  @ApiProperty({ example: 'Mutabor Project' })
  name: string;

  @ApiProperty({ example: 'MUT' })
  prefix: string;

  @ApiProperty({ type: ProjectOwnerDto })
  owner: ProjectOwnerDto;

  @ApiProperty({ type: [ProjectMemberDto] })
  members: ProjectMemberDto[];

  @ApiProperty({ type: [ColumnWithTasksDto] })
  columns: ColumnWithTasksDto[];

  @ApiProperty({ type: [String], example: ['Task', 'Bug', 'Feature'] })
  availableTaskTypes: string[];
}

================================================
FILE: api/src/projects/dto/project-settings.dto.ts
================================================
// api/src/projects/dto/project-settings.dto.ts
import { ApiProperty } from '@nestjs/swagger';

export class ProjectSettingsDto {
  @ApiProperty({ example: 1 })
  id: number;

  @ApiProperty({ example: 'My Awesome Project' })
  name: string;
  
  @ApiProperty({ example: 'AWESOME' })
  prefix: string;

  @ApiProperty({ type: [String], example: ['To Do', 'In Progress', 'Done'] })
  settings_statuses: string[];

  @ApiProperty({ type: [String], example: ['Bug', 'Feature', 'Chore'] })
  settings_types: string[];
}

================================================
FILE: api/src/projects/dto/update-column.dto.ts
================================================
import { ApiProperty } from '@nestjs/swagger';
import { IsNotEmpty, IsString, MaxLength, MinLength } from 'class-validator';

export class UpdateColumnDto {
  @ApiProperty({
    description: 'The new name for the column (task status)',
    example: 'In Review',
    minLength: 1,
    maxLength: 50,
  })
  @IsString()
  @IsNotEmpty()
  @MinLength(1)
  @MaxLength(50)
  name: string;
}

================================================
FILE: api/src/projects/dto/update-member.dto.ts
================================================
// api/src/projects/dto/update-member.dto.ts
import { IsEnum, IsNotEmpty } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';
import { Role } from '../../casl/roles.enum';

export class UpdateMemberDto {
  @ApiProperty({ 
    description: "The new role to assign to the member.",
    enum: [Role.Editor, Role.Viewer],
    example: Role.Editor 
  })
  @IsEnum([Role.Editor, Role.Viewer])
  @IsNotEmpty()
  role: Role.Editor | Role.Viewer;
}

================================================
FILE: api/src/projects/dto/update-project-settings.dto.ts
================================================
import { ApiProperty } from '@nestjs/swagger';
import {
  IsArray,
  IsOptional,
  IsString,
  MaxLength,
  MinLength,
  IsAlphanumeric,
  ArrayNotEmpty,
  ArrayMinSize,
} from 'class-validator';

export class UpdateProjectSettingsDto {
  @ApiProperty({
    description: 'The new name of the project',
    example: 'My Awesome Project Revised',
    required: false,
  })
  @IsOptional()
  @IsString()
  @MinLength(3)
  @MaxLength(100)
  name?: string;

  @ApiProperty({
    description: 'The new unique prefix for tasks in the project (uppercase, alphanumeric)',
    example: 'NPROJ',
    required: false,
    minLength: 2,
    maxLength: 10,
  })
  @IsOptional()
  @IsString()
  @IsAlphanumeric()
  @MinLength(2)
  @MaxLength(10)
  // Consider adding a Transform to uppercase: @Transform(({ value }) => value.toUpperCase())
  prefix?: string;

  @ApiProperty({
    description: 'The list of task statuses for the project',
    example: ['To Do', 'In Progress', 'Review', 'Done'],
    type: [String],
    required: false,
  })
  @IsOptional()
  @IsArray()
  // @ArrayNotEmpty() is redundant if @ArrayMinSize(1) is present
  @ArrayMinSize(1)
  @IsString({ each: true })
  @MinLength(1, { each: true })
  @MaxLength(50, { each: true })
  statuses?: string[];

  @ApiProperty({
    description: 'The list of task types for the project',
    example: ['Feature', 'Bug Fix', 'Documentation', 'Refactor'],
    type: [String],
    required: false,
  })
  @IsOptional()
  @IsArray()
  // @ArrayNotEmpty() is redundant if @ArrayMinSize(1) is present
  @ArrayMinSize(1)
  @IsString({ each: true })
  @MinLength(1, { each: true })
  @MaxLength(50, { each: true })
  types?: string[];
}


================================================
FILE: api/src/projects/projects.controller.spec.ts
================================================
import { Test, TestingModule } from '@nestjs/testing';
import { ProjectsController } from './projects.controller';
import { ProjectsService } from './projects.service';
import { INestApplication, ValidationPipe } from '@nestjs/common';
import * as request from 'supertest';
import { KnexModule } from '../knex/knex.module';
import { ConfigModule } from '@nestjs/config';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { Knex } from 'knex';
import { KNEX_CONNECTION } from '../knex/knex.constants';
import * as crypto from 'crypto';
import { PoliciesGuard } from '../casl/policies.guard';
import { TasksService } from '../tasks/tasks.service';

describe('ProjectsController (e2e)', () => {
  let app: INestApplication;
  let knex: Knex;
  let createdProjectId: number;

  const mockUser = {
    id: crypto.randomUUID(),
    email: 'e2e-test@example.com',
    name: 'E2E Test User',
  };

  const mockTasksService = {
    getUserRoleForTask: jest.fn().mockResolvedValue('owner'),
  };
  
  beforeAll(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [
        ConfigModule.forRoot({ isGlobal: true, envFilePath: '.env.test' }),
        KnexModule,
      ],
      controllers: [ProjectsController],
      providers: [
        // ### ИЗМЕНЕНИЕ: Добавляем все нужные провайдеры
        ProjectsService,
        PoliciesGuard,
        { provide: TasksService, useValue: mockTasksService },
      ],
    })
    .overrideGuard(JwtAuthGuard)
    .useValue({
      canActivate: (context) => {
        const req = context.switchToHttp().getRequest();
        req.user = mockUser;
        return true;
      },
    })
    // ### ИЗМЕНЕНИЕ: Мокируем PoliciesGuard, чтобы не проверять реальную логику прав в e2e тестах контроллера
    .overrideGuard(PoliciesGuard)
    .useValue({ canActivate: () => true })
    .compile();

    app = moduleFixture.createNestApplication();
    app.useGlobalPipes(new ValidationPipe());
    await app.init();
    
    knex = app.get(KNEX_CONNECTION);
    await knex('project_members').del();
    await knex('tasks').del();
    await knex('columns').del();
    await knex('projects').del();
    await knex('users').where('email', mockUser.email).del();
    await knex('users').insert({ ...mockUser, password_hash: 'test-hash' });
  });

  afterAll(async () => {
    if (knex) {
      await knex.destroy();
    }
    if (app) {
      await app.close();
    }
  });

  it('POST /api/v1/projects - should create a new project', async () => {
    const createProjectDto = { name: 'E2E Project', prefix: 'E2E' };
    
    const response = await request(app.getHttpServer())
      .post('/api/v1/projects')
      .send(createProjectDto)
      .expect(201);

    expect(response.body.name).toEqual(createProjectDto.name);
    expect(response.body.owner_id).toEqual(mockUser.id);
    createdProjectId = response.body.id;
  });

  it('GET /api/v1/projects/:id - should get the created project details', async () => {
    expect(createdProjectId).toBeDefined();

    const response = await request(app.getHttpServer())
      .get(`/api/v1/projects/${createdProjectId}`)
      .expect(200);

    expect(response.body.id).toEqual(createdProjectId);
    expect(response.body.owner.id).toEqual(mockUser.id);
    expect(response.body.columns).toHaveLength(3);
  });

  it('GET /api/v1/projects - should list the created project for the user', async () => {
    const response = await request(app.getHttpServer())
      .get('/api/v1/projects')
      .expect(200);

    expect(Array.isArray(response.body)).toBe(true);
    expect(response.body.length).toBeGreaterThan(0);
    expect(response.body.some(p => p.id === createdProjectId)).toBe(true);
  });
});

================================================
FILE: api/src/projects/projects.controller.ts
================================================
// api/src/projects/projects.controller.ts
import { Controller, Post, Body, Get, Param, UseGuards, Req, ParseIntPipe, HttpCode, HttpStatus, Put, Patch, ParseUUIDPipe, Delete } from '@nestjs/common';
import { ProjectsService } from './projects.service';
import { CreateProjectDto } from './dto/create-project.dto';
import { AddMemberDto } from './dto/add-member.dto';
import { UpdateProjectSettingsDto } from './dto/update-project-settings.dto';
import { CreateColumnDto } from './dto/create-column.dto';
import { UpdateColumnDto } from './dto/update-column.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { ApiTags, ApiBearerAuth, ApiOperation, ApiResponse } from '@nestjs/swagger';
import { AuthenticatedUser } from 'src/auth/jwt.strategy';
import { CheckPolicies } from '../casl/check-policies.decorator';
import { CanEditProjectContentPolicy, CanManageProjectSettingsPolicy, CanViewProjectPolicy } from '../casl/project-policies.handler';
import { ProjectSettingsDto } from './dto/project-settings.dto';
import { UpdateMemberDto } from './dto/update-member.dto'; // ### НОВОЕ: Импортируем DTO

@ApiBearerAuth()
@ApiTags('Projects')
@UseGuards(JwtAuthGuard)
@Controller('api/v1/projects')
export class ProjectsController {
  constructor(private readonly projectsService: ProjectsService) {}

  @Post()
  @HttpCode(HttpStatus.CREATED)
  @ApiOperation({ summary: 'Create a new project' })
  create(@Body() createProjectDto: CreateProjectDto, @Req() req) {
    const user = req.user as AuthenticatedUser;
    return this.projectsService.createProject(createProjectDto, user);
  }

  @Get()
  @ApiOperation({ summary: 'Get all projects for the current user' })
  findAll(@Req() req) {
    const user = req.user as AuthenticatedUser;
    return this.projectsService.findAllProjectsForUser(user.id);
  }

  @Get(':id')
  @CheckPolicies(CanViewProjectPolicy)
  @ApiOperation({ summary: 'Get full details of a project (board, tasks, members)' })
  findOne(@Param('id', ParseIntPipe) id: number) {
    return this.projectsService.getProjectDetails(id);
  }

  @Get(':id/settings')
  @CheckPolicies(CanManageProjectSettingsPolicy)
  @ApiOperation({ summary: 'Get project settings (name, prefix, types, statuses)' })
  @ApiResponse({ status: 200, description: 'Returns project settings.', type: ProjectSettingsDto })
  getProjectSettings(
    @Param('id', ParseIntPipe) id: number,
  ): Promise<ProjectSettingsDto> {
    return this.projectsService.getProjectSettings(id);
  }
  
  @Put(':id/settings')
  @CheckPolicies(CanManageProjectSettingsPolicy)
  @ApiOperation({ summary: 'Update project settings (name, prefix, types)' })
  updateProjectSettings(
    @Param('id', ParseIntPipe) id: number,
    @Body() updateProjectSettingsDto: UpdateProjectSettingsDto,
  ) {
    return this.projectsService.updateProjectSettings(id, updateProjectSettingsDto);
  }
  
  // --- Columns CRUD ---

  @Post(':projectId/columns')
  @CheckPolicies(CanEditProjectContentPolicy)
  @ApiOperation({ summary: 'Create a new column in a project' })
  @HttpCode(HttpStatus.CREATED)
  createColumn(
    @Param('projectId', ParseIntPipe) projectId: number,
    @Body() createColumnDto: CreateColumnDto,
  ) {
    return this.projectsService.createColumn(projectId, createColumnDto);
  }

  @Patch(':projectId/columns/:columnId')
  @CheckPolicies(CanEditProjectContentPolicy)
  @ApiOperation({ summary: 'Update a column\'s name' })
  @HttpCode(HttpStatus.OK)
  updateColumn(
    @Param('projectId', ParseIntPipe) projectId: number,
    @Param('columnId', ParseUUIDPipe) columnId: string,
    @Body() updateColumnDto: UpdateColumnDto,
  ) {
    return this.projectsService.updateColumn(projectId, columnId, updateColumnDto);
  }

  @Delete(':projectId/columns/:columnId')
  @CheckPolicies(CanEditProjectContentPolicy)
  @ApiOperation({ summary: 'Delete a column and move its tasks' })
  @HttpCode(HttpStatus.NO_CONTENT)
  deleteColumn(
    @Param('projectId', ParseIntPipe) projectId: number,
    @Param('columnId', ParseUUIDPipe) columnId: string,
  ) {
    return this.projectsService.deleteColumn(projectId, columnId);
  }

  // --- Members ---

  @Post(':projectId/members')
  @CheckPolicies(CanManageProjectSettingsPolicy)
  @ApiOperation({ summary: 'Add a new member to a project' })
  addMember(
    @Param('projectId', ParseIntPipe) projectId: number,
    @Body() addMemberDto: AddMemberDto,
  ) {
    return this.projectsService.addMemberToProject(projectId, addMemberDto);
  }

  @Get(':projectId/members')
  @CheckPolicies(CanViewProjectPolicy)
  @ApiOperation({ summary: 'Get all members of a project' })
  getMembers(
    @Param('projectId', ParseIntPipe) projectId: number,
  ) {
    // ### ИЗМЕНЕНИЕ: Теперь возвращаем и владельца, и участников одним списком
    return this.projectsService.getAllProjectParticipants(projectId);
  }

  // ### НОВЫЙ ЭНДПОИНТ ###
  @Patch(':projectId/members/:userId')
  @CheckPolicies(CanManageProjectSettingsPolicy)
  @ApiOperation({ summary: 'Update a project member\'s role' })
  @HttpCode(HttpStatus.OK)
  updateMember(
    @Param('projectId', ParseIntPipe) projectId: number,
    @Param('userId', ParseUUIDPipe) userId: string,
    @Body() updateMemberDto: UpdateMemberDto,
  ) {
    return this.projectsService.updateProjectMember(projectId, userId, updateMemberDto);
  }

  // ### НОВЫЙ ЭНДПОИНТ ###
  @Delete(':projectId/members/:userId')
  @CheckPolicies(CanManageProjectSettingsPolicy)
  @ApiOperation({ summary: 'Remove a member from a project' })
  @HttpCode(HttpStatus.NO_CONTENT)
  removeMember(
    @Param('projectId', ParseIntPipe) projectId: number,
    @Param('userId', ParseUUIDPipe) userId: string,
  ) {
    return this.projectsService.removeMemberFromProject(projectId, userId);
  }
}

================================================
FILE: api/src/projects/projects.module.ts
================================================
// api/src/projects/projects.module.ts

import { Module, forwardRef } from '@nestjs/common';
import { ProjectsService } from './projects.service';
import { ProjectsController } from './projects.controller';
import { KnexModule } from '../knex/knex.module';
// ### ИЗМЕНЕНИЕ: Закомментированный импорт CaslModule удален ###
import { TasksModule } from '../tasks/tasks.module';

@Module({
  imports: [
    KnexModule,
    // ### ИЗМЕНЕНИЕ: Закомментированный импорт CaslModule удален ###
    forwardRef(() => TasksModule),
  ],
  controllers: [ProjectsController],
  providers: [ProjectsService],
  exports: [ProjectsService],
})
export class ProjectsModule {}

================================================
FILE: api/src/projects/projects.service.spec.ts
================================================
import { Test, TestingModule } from '@nestjs/testing';
import { ProjectsService } from './projects.service';
import { KNEX_CONNECTION } from '../knex/knex.constants';
import { NotFoundException, BadRequestException } from '@nestjs/common';
import { AuthenticatedUser } from 'src/auth/jwt.strategy';
import { Role } from '../casl/roles.enum';

const mockUser: AuthenticatedUser = { id: 'user-1', email: 'test@example.com', name: 'Test User', role: 'user' };

describe('ProjectsService', () => {
  let service: ProjectsService;
  let knex;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        ProjectsService,
        { 
          provide: KNEX_CONNECTION, 
          useValue: jest.fn(),
        },
      ],
    }).compile();

    service = module.get<ProjectsService>(ProjectsService);
    knex = module.get(KNEX_CONNECTION);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('getUserRoleForProject', () => {
    it('should return Role.Owner if user is the owner', async () => {
      const mockFirst = jest.fn().mockResolvedValue({ owner_id: 'user-1' });
      knex.mockReturnValue({ where: () => ({ first: mockFirst }) });
      const role = await service.getUserRoleForProject(1, 'user-1');
      expect(role).toBe(Role.Owner);
    });

    it('should return member role if user is a member', async () => {
      const mockFirst = jest.fn()
        .mockResolvedValueOnce({ owner_id: 'owner-id' })
        .mockResolvedValueOnce({ role: Role.Editor });
      knex.mockReturnValue({ where: () => ({ first: mockFirst }) });
      const role = await service.getUserRoleForProject(1, 'user-2');
      expect(role).toBe(Role.Editor);
    });
  });

  describe('createProject', () => {
    it('should create a project with default columns and types within a transaction', async () => {
      const dto = { name: 'New Project', prefix: 'NEW' };
      const newProjectRecord = { id: 1, ...dto };

      const mockReturning = jest.fn().mockResolvedValue([newProjectRecord]);
      const mockInsert = jest.fn().mockReturnValue({ returning: mockReturning });
      const mockTrx = jest.fn(() => ({ insert: mockInsert }));
      knex.transaction = jest.fn().mockImplementation(async (callback) => callback(mockTrx));

      await service.createProject(dto, mockUser);

      expect(knex.transaction).toHaveBeenCalled();
      expect(mockTrx).toHaveBeenCalledWith('projects');
    });
  });
  
  describe('deleteColumn', () => {
    let mockTrx;
    let mockUpdate;
    let mockDelete;
    let mockOrderBy;

    beforeEach(() => {
        mockUpdate = jest.fn().mockResolvedValue(1);
        mockDelete = jest.fn().mockResolvedValue(1);
        mockOrderBy = jest.fn();

        // Этот мок теперь правильно имитирует и .where(...).update(...) и .where(...).delete()
        const mockWhereChain = {
          orderBy: mockOrderBy,
          delete: mockDelete,
          update: mockUpdate,
        };

        mockTrx = jest.fn(() => ({
          where: jest.fn(() => mockWhereChain),
        }));
        
        knex.transaction = jest.fn().mockImplementation(async (callback) => callback(mockTrx));
    });

    it('should throw BadRequestException if trying to delete the last column', async () => {
        mockOrderBy.mockResolvedValue([{ id: 'col1' }]);
        await expect(service.deleteColumn(1, 'col1')).rejects.toThrow(BadRequestException);
    });

    it('should move tasks and delete column', async () => {
        const columns = [{ id: 'col1', position: 0 }, { id: 'col2', position: 1 }];
        mockOrderBy.mockResolvedValue(columns);

        await service.deleteColumn(1, 'col1');

        // Проверяем, что был вызов для перемещения задач в `col2`
        expect(mockTrx).toHaveBeenCalledWith('tasks');
        expect(mockUpdate).toHaveBeenCalledWith({ column_id: 'col2' });

        // Проверяем, что был вызов удаления для `col1`
        expect(mockTrx).toHaveBeenCalledWith('columns');
        expect(mockDelete).toHaveBeenCalled();

        // Проверяем, что был вызов для обновления позиции `col2`
        expect(mockUpdate).toHaveBeenCalledWith({ position: 0 });
    });
  });
});

================================================
FILE: api/src/projects/projects.service.ts
================================================
// api/src/projects/projects.service.ts
import { Injectable, NotFoundException, ConflictException, Inject, Logger, BadRequestException, ForbiddenException } from '@nestjs/common';
import { CreateProjectDto } from './dto/create-project.dto';
import { UpdateProjectSettingsDto } from './dto/update-project-settings.dto';
import { UpdateColumnDto } from './dto/update-column.dto';
import { CreateColumnDto } from './dto/create-column.dto';
import { AddMemberDto } from './dto/add-member.dto';
import { UpdateMemberDto } from './dto/update-member.dto';
import { Knex } from 'knex';
import { KNEX_CONNECTION } from '../knex/knex.constants';
import * as crypto from 'crypto';
import { ProjectRecord, UserRecord, ProjectMemberWithUser, ColumnRecord, AllParticipants } from '../types/db-records';
import { ProjectDetailsDto } from './dto/project-details.dto';
import { Role } from '../casl/roles.enum';
import { AuthenticatedUser } from 'src/auth/jwt.strategy';
import { ProjectSettingsDto } from './dto/project-settings.dto';

const DEFAULT_PROJECT_COLUMNS = ['To Do', 'In Progress', 'Done'];
const DEFAULT_PROJECT_TYPES = ['Task', 'Bug', 'Feature'];

@Injectable()
export class ProjectsService {
  private readonly logger = new Logger(ProjectsService.name);

  constructor(
    @Inject(KNEX_CONNECTION) private readonly knex: Knex,
  ) {}

  async getUserRoleForProject(projectId: number, userId: string, trx?: Knex.Transaction): Promise<Role | null> {
    const db = trx || this.knex;
    const project = await db('projects').where({ id: projectId }).first();
    if (!project) {
        throw new NotFoundException(`Project with ID ${projectId} not found.`);
    }

    if (project.owner_id === userId) {
        return Role.Owner;
    }

    const membership = await db('project_members').where({ project_id: projectId, user_id: userId }).first();
    if (membership) {
        return membership.role as Role;
    }

    return null;
  }
  
  async getProjectOwner(projectId: number): Promise<UserRecord> {
    const project = await this.knex('projects').where({ id: projectId }).select('owner_id').first();
    if (!project) {
        throw new NotFoundException(`Project with ID ${projectId} not found.`);
    }
    const owner = await this.knex('users').where({ id: project.owner_id }).select('id', 'name', 'email', 'created_at', 'updated_at').first();
    if (!owner) {
        throw new NotFoundException(`Owner for project ID ${projectId} not found.`);
    }
    return owner;
  }

  async createProject(createProjectDto: CreateProjectDto, user: AuthenticatedUser): Promise<ProjectRecord> {
    return this.knex.transaction(async (trx) => {
      const [newProject] = await trx('projects')
        .insert({
          name: createProjectDto.name,
          task_prefix: createProjectDto.prefix.toUpperCase(),
          owner_id: user.id,
        })
        .returning('*');
      
      const defaultColumns = DEFAULT_PROJECT_COLUMNS.map((name, index) => ({
        id: crypto.randomUUID(), name, position: index, project_id: newProject.id,
      }));
      await trx('columns').insert(defaultColumns);

      const defaultTypes = DEFAULT_PROJECT_TYPES.map(name => ({
        name, project_id: newProject.id,
      }));
      await trx('project_task_types').insert(defaultTypes);
      
      return newProject;
    });
  }

  async findAllProjectsForUser(userId: string): Promise<ProjectRecord[]> {
    const projectsAsOwner = await this.knex('projects').where({ owner_id: userId });
    const projectsAsMember = await this.knex('projects')
        .join('project_members', 'projects.id', '=', 'project_members.project_id')
        .where('project_members.user_id', userId)
        .select('projects.*');
    
    const allProjects = [...projectsAsOwner, ...projectsAsMember];
    const uniqueProjects = Array.from(new Map(allProjects.map(p => [p.id, p])).values());

    return uniqueProjects.sort((a,b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime());
  }

  async getProjectDetails(projectId: number): Promise<ProjectDetailsDto> {
    const project = await this.knex('projects').where({ id: projectId }).first();
    if (!project) {
      throw new NotFoundException(`Project with ID ${projectId} not found.`);
    }

    const [columnsDb, tasksDb, taskTypesDb, owner, membersResult] = await Promise.all([
      this.knex('columns').where({ project_id: projectId }).orderBy('position', 'asc'),
      this.knex('tasks').where({ project_id: projectId }).orderBy('position', 'asc'),
      this.knex('project_task_types').where({ project_id: projectId }).orderBy('id', 'asc'),
      this.getProjectOwner(projectId),
      this.getProjectMembers(projectId)
    ]);
    
    const members = membersResult.map(m => ({
      id: m.user.id,
      name: m.user.name,
      email: m.user.email,
      role: m.role,
    }));

    const columns = columnsDb.map(col => ({
      ...col,
      tasks: tasksDb
        .filter(task => task.column_id === col.id)
        .map(task => ({ ...task })),
    }));

    return {
      id: project.id,
      name: project.name,
      prefix: project.task_prefix,
      owner,
      members,
      columns,
      availableTaskTypes: taskTypesDb.map(t => t.name),
    };
  }
  
  async getProjectSettings(projectId: number): Promise<ProjectSettingsDto> {
    const project = await this.knex('projects').where({ id: projectId }).first();
    if (!project) {
        throw new NotFoundException(`Project with ID ${projectId} not found.`);
    }

    const statuses = await this.knex('columns')
        .where({ project_id: projectId })
        .orderBy('position', 'asc')
        .select('name');

    const types = await this.knex('project_task_types')
        .where({ project_id: projectId })
        .orderBy('name', 'asc')
        .select('name');

    return {
        id: project.id,
        name: project.name,
        prefix: project.task_prefix,
        settings_statuses: statuses.map(s => s.name),
        settings_types: types.map(t => t.name),
    };
  }

  async updateProjectSettings(
    projectId: number,
    settingsDto: UpdateProjectSettingsDto,
  ): Promise<ProjectSettingsDto> {
    await this.knex.transaction(async (trx) => {
      const project = await trx('projects').where({id: projectId}).first();
      if (!project) throw new NotFoundException(`Project with ID ${projectId} not found.`);

      if (settingsDto.name || settingsDto.prefix) {
        await this.updateProjectCoreDetails(project, settingsDto, trx);
      }
      
      if (settingsDto.types) {
        await this.synchronizeTaskTypes(projectId, settingsDto.types, trx);
      }

      if (settingsDto.statuses) {
        await this.synchronizeStatuses(projectId, settingsDto.statuses, trx);
      }
    });
    
    return this.getProjectSettings(projectId);
  }

  private async updateProjectCoreDetails(project: ProjectRecord, settingsDto: UpdateProjectSettingsDto, trx: Knex.Transaction): Promise<void> {
      const updatePayload: Partial<Pick<ProjectRecord, 'name' | 'task_prefix'>> = {};
      if (settingsDto.name) {
        updatePayload.name = settingsDto.name;
      }
      if (settingsDto.prefix) {
        const newPrefix = settingsDto.prefix.toUpperCase();
        if (newPrefix !== project.task_prefix) {
            const existing = await trx('projects').where({ task_prefix: newPrefix }).whereNot({ id: project.id }).first();
            if (existing) throw new ConflictException(`Project prefix '${newPrefix}' is already in use.`);
            updatePayload.task_prefix = newPrefix;
            await this.updateTaskPrefixesForProject(project.id, project.task_prefix, newPrefix, trx);
        }
      }
      if (Object.keys(updatePayload).length > 0) {
        await trx('projects').where({ id: project.id }).update(updatePayload);
      }
  }

  private async synchronizeTaskTypes(projectId: number, newTypes: string[], trx: Knex.Transaction): Promise<void> {
    await trx('project_task_types').where({ project_id: projectId }).delete();
    if (newTypes.length > 0) {
      const newTypesData = newTypes.map(name => ({ name, project_id: projectId }));
      await trx('project_task_types').insert(newTypesData);
    }
  }

  private async synchronizeStatuses(projectId: number, newStatusNames: string[], trx: Knex.Transaction): Promise<void> {
    const existingColumns = await trx('columns').where({ project_id: projectId });
    const existingNames = existingColumns.map(c => c.name);
    
    const columnsToRemove = existingColumns.filter(c => !newStatusNames.includes(c.name));
    const namesToAdd = newStatusNames.filter(name => !existingNames.includes(name));

    if (columnsToRemove.length > 0) {
      if (newStatusNames.length === 0) throw new BadRequestException('A project must have at least one status column.');
      
      const remainingColumns = existingColumns.filter(c => !columnsToRemove.some(rem => rem.id === c.id));
      const targetColumnForOrphanedTasks = remainingColumns[0] || null;

      if (!targetColumnForOrphanedTasks && namesToAdd.length === 0) {
          throw new BadRequestException('Cannot delete all columns without adding new ones.');
      }

      if (targetColumnForOrphanedTasks?.id) {
        const columnsToRemoveIds = columnsToRemove.map(c => c.id);
        await trx('tasks')
          .whereIn('column_id', columnsToRemoveIds)
          .update({ column_id: targetColumnForOrphanedTasks.id });
      }
      await trx('columns').whereIn('id', columnsToRemove.map(c => c.id)).delete();
    }

    if (namesToAdd.length > 0) {
      const newColumnsData = namesToAdd.map(name => ({
        id: crypto.randomUUID(),
        name,
        project_id: projectId,
        position: -1,
      }));
      await trx('columns').insert(newColumnsData);
    }

    const finalColumns = await trx('columns').where({ project_id: projectId });
    const positionUpdatePromises = newStatusNames.map((name, index) => {
      const columnToUpdate = finalColumns.find(c => c.name === name);
      if (columnToUpdate) {
        return trx('columns').where({ id: columnToUpdate.id }).update({ position: index });
      }
    });
    await Promise.all(positionUpdatePromises.filter(p => p));
  }
  
  private async updateTaskPrefixesForProject(
    projectId: number,
    oldPrefix: string,
    newPrefix: string,
    trx: Knex.Transaction,
  ): Promise<number> {
    const oldPrefixPattern = `${oldPrefix}-`;
    const newPrefixPattern = `${newPrefix}-`;
    const result = await trx.raw(`
        UPDATE tasks
        SET human_readable_id = REPLACE(human_readable_id, ?, ?), updated_at = ?
        WHERE project_id = ? AND human_readable_id LIKE ?`,
        [oldPrefixPattern, newPrefixPattern, new Date(), projectId, `${oldPrefixPattern}%`]
    );
    return result.rowCount || 0;
  }

  async createColumn(projectId: number, createColumnDto: CreateColumnDto): Promise<ColumnRecord> {
    const { name } = createColumnDto;
    const maxPositionResult = await this.knex('columns')
        .where({ project_id: projectId })
        .max('position as max_pos')
        .first();

    const newPosition = (maxPositionResult?.max_pos ?? -1) + 1;

    const [newColumn] = await this.knex('columns')
      .insert({
        id: crypto.randomUUID(),
        name,
        project_id: projectId,
        position: newPosition,
      })
      .returning('*');

    return newColumn;
  }

  async updateColumn(projectId: number, columnId: string, updateColumnDto: UpdateColumnDto): Promise<ColumnRecord> {
    const column = await this.knex('columns').where({ id: columnId, project_id: projectId }).first();
    if (!column) throw new NotFoundException(`Column with ID ${columnId} not found in this project.`);

    const [updatedColumn] = await this.knex('columns')
      .where({ id: columnId })
      .update({ name: updateColumnDto.name, updated_at: new Date() })
      .returning('*');
    
    return updatedColumn;
  }

  async deleteColumn(projectId: number, columnId: string): Promise<void> {
    await this.knex.transaction(async (trx) => {
        const allColumns = await trx('columns').where({ project_id: projectId }).orderBy('position', 'asc');
        
        if (allColumns.length <= 1) {
            throw new BadRequestException('Cannot delete the last column. A project must have at least one column.');
        }

        const columnToDelete = allColumns.find(c => c.id === columnId);
        if (!columnToDelete) {
            this.logger.warn(`Attempted to delete non-existent column ${columnId} in project ${projectId}.`);
            return; // Exit gracefully if column is already gone.
        }

        const columnIndex = allColumns.findIndex(c => c.id === columnId);
        
        // Find a new home for the tasks: the previous column, or the next one if deleting the first.
        const targetColumn = (columnIndex > 0) ? allColumns[columnIndex - 1] : allColumns[1];
        
        // Move tasks from the deleted column to the target column.
        await trx('tasks')
            .where({ column_id: columnId })
            .update({ column_id: targetColumn.id });

        // Delete the column itself.
        await trx('columns').where({ id: columnId }).delete();
        
        // Re-sequence the remaining columns to ensure there are no gaps in `position`.
        const remainingColumns = allColumns.filter(c => c.id !== columnId);
        const updatePromises = remainingColumns.map((col, index) =>
            trx('columns')
                .where({ id: col.id })
                .update({ position: index })
        );
        await Promise.all(updatePromises);
    });
  }
  
  async isTaskTypeValidForProject(projectId: number, taskType: string, trx?: Knex.Transaction): Promise<boolean> {
      if (!taskType) return true;
      const db = trx || this.knex;
      const typeRecord = await db('project_task_types').where({ project_id: projectId, name: taskType }).first();
      return !!typeRecord;
  }

  async addMemberToProject(projectId: number, addMemberDto: AddMemberDto): Promise<AllParticipants> {
    const project = await this.knex('projects').where({ id: projectId }).first();
    if (!project) throw new NotFoundException(`Project with ID ${projectId} not found.`);

    const userToAdd = await this.knex('users').where({ email: addMemberDto.email }).first();
    if (!userToAdd) throw new NotFoundException(`User with email ${addMemberDto.email} not found.`);
    if (userToAdd.id === project.owner_id) throw new ConflictException('Cannot add the project owner as a member.');
    
    const existingMembership = await this.knex('project_members').where({ project_id: projectId, user_id: userToAdd.id }).first();
    if (existingMembership) throw new ConflictException(`User ${addMemberDto.email} is already a member of this project.`);
    
    await this.knex('project_members').insert({ project_id: projectId, user_id: userToAdd.id, role: addMemberDto.role });
    
    const user = await this.knex('users').where({ id: userToAdd.id }).first();

    return {
      id: user.id,
      name: user.name,
      email: user.email,
      role: addMemberDto.role
    };
  }
  
  async getProjectMembers(projectId: number): Promise<ProjectMemberWithUser[]> {
    const membersData = await this.knex('project_members')
      .join('users', 'project_members.user_id', '=', 'users.id')
      .where('project_members.project_id', projectId)
      .select('project_members.role', 'users.id', 'users.name', 'users.email', 'users.created_at', 'users.updated_at')
      .orderBy('users.name', 'asc');
    
    return membersData.map(m => ({
        project_id: projectId, user_id: m.id, role: m.role,
        user: { id: m.id, name: m.name, email: m.email, created_at: m.created_at, updated_at: m.updated_at, password_hash: '', role: 'user' }
    }));
  }

  async getAllProjectParticipants(projectId: number): Promise<AllParticipants[]> {
    const owner = await this.getProjectOwner(projectId);
    const members = await this.getProjectMembers(projectId);

    const ownerData: AllParticipants = {
      id: owner.id,
      name: owner.name,
      email: owner.email,
      role: Role.Owner,
    };

    const membersData: AllParticipants[] = members.map(m => ({
      id: m.user.id,
      name: m.user.name,
      email: m.user.email,
      role: m.role,
    }));
    
    return [ownerData, ...membersData];
  }

  async updateProjectMember(projectId: number, userId: string, updateDto: UpdateMemberDto): Promise<AllParticipants> {
    const project = await this.knex('projects').where({ id: projectId }).select('owner_id').first();
    if (!project) throw new NotFoundException(`Project with ID ${projectId} not found.`);
    if (project.owner_id === userId) throw new ForbiddenException('Cannot change the role of the project owner.');

    const [updatedMember] = await this.knex('project_members')
      .where({ project_id: projectId, user_id: userId })
      .update({ role: updateDto.role, updated_at: new Date() })
      .returning('*');

    if (!updatedMember) throw new NotFoundException(`Member with ID ${userId} not found in project ${projectId}.`);

    const user = await this.knex('users').where({ id: userId }).select('id', 'name', 'email').first();

    return {
      id: user.id,
      name: user.name,
      email: user.email,
      role: updatedMember.role,
    };
  }

  async removeMemberFromProject(projectId: number, userId: string): Promise<void> {
    const project = await this.knex('projects').where({ id: projectId }).select('owner_id').first();
    if (!project) throw new NotFoundException(`Project with ID ${projectId} not found.`);
    if (project.owner_id === userId) throw new ForbiddenException('Cannot remove the project owner.');

    const deletedCount = await this.knex('project_members')
      .where({ project_id: projectId, user_id: userId })
      .delete();
      
    if (deletedCount === 0) {
      throw new NotFoundException(`Member with ID ${userId} not found in project ${projectId}.`);
    }
  }
}

================================================
FILE: api/src/tasks/dto/create-task.dto.ts
================================================
import { IsString, IsNotEmpty, IsOptional, IsUUID, IsDateString, IsArray } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';

export class CreateTaskDto {
  @ApiProperty({ description: 'The title of the task.', example: 'Implement login feature' })
  @IsString()
  @IsNotEmpty()
  title: string;

  @ApiProperty({ description: 'A detailed description of the task.', required: false })
  @IsOptional()
  @IsString()
  description?: string;

  @ApiProperty({ description: 'The ID of the column (status) this task belongs to.', example: 'f47ac10b-58cc-4372-a567-0e02b2c3d479' })
  @IsUUID()
  columnId: string;

  // projectId удален из DTO, так как он теперь передается через URL параметр
  // @IsInt()
  // projectId: number;

  @ApiProperty({ description: 'The ID of the user this task is assigned to.', required: false })
  @IsOptional()
  @IsUUID()
  assigneeId?: string;

  @ApiProperty({ description: 'The due date for the task in ISO 8601 format.', required: false, example: '2024-12-31T23:59:59.000Z' })
  @IsOptional()
  @IsDateString()
  dueDate?: string;

  @ApiProperty({ description: 'The type of the task (e.g., "Bug", "Feature").', required: false, example: 'Feature' })
  @IsOptional()
  @IsString()
  type?: string;

  @ApiProperty({ description: 'The priority of the task (e.g., "High", "Low").', required: false, example: 'High' })
  @IsOptional()
  @IsString()
  priority?: string;

  @ApiProperty({ description: 'An array of tags for the task.', required: false, example: ['frontend', 'auth'] })
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  tags?: string[];
}

================================================
FILE: api/src/tasks/dto/move-task.dto.ts
================================================
import { IsUUID, IsNotEmpty, IsInt, IsOptional } from 'class-validator';

export class MoveTaskDto {
  @IsUUID()
  @IsNotEmpty()
  newColumnId: string;

  @IsInt()
  @IsNotEmpty()
  newPosition: number; // 0-based index in the new column

  @IsUUID()
  @IsOptional() // If moving from one column to another, old column might be needed for reordering
  oldColumnId?: string;
}


================================================
FILE: api/src/tasks/dto/task.dto.ts
================================================
export class TaskDto {
  id: string;
  humanReadableId: string;
  taskNumber: number;
  title: string;
  description?: string;
  position: number;
  projectId: number;
  columnId: string;
  assigneeId?: string;
  creatorId: string;
  dueDate?: Date;
  createdAt: Date;
  updatedAt: Date;
}


================================================
FILE: api/src/tasks/dto/update-task.dto.ts
================================================
import { IsString, IsOptional, IsUUID, MaxLength, IsInt, IsArray, IsDateString } from 'class-validator';

export class UpdateTaskDto {
  @IsString()
  @IsOptional()
  @MaxLength(255)
  title?: string;

  @IsString()
  @IsOptional()
  @MaxLength(10000)
  description?: string;

  @IsUUID()
  @IsOptional()
  columnId?: string;

  @IsUUID()
  @IsOptional()
  assigneeId?: string;

  @IsInt()
  @IsOptional()
  position?: number;

  @IsOptional()
  @IsDateString() // Changed from IsString
  dueDate?: string;

  @IsOptional()
  @IsString()
  @MaxLength(255)
  type?: string;

  @IsOptional()
  @IsString()
  @MaxLength(255)
  priority?: string;

  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  tags?: string[];
}


================================================
FILE: api/src/tasks/tasks.controller.spec.ts
================================================
import { Test, TestingModule } from '@nestjs/testing';
import { TasksController } from './tasks.controller';
import { TasksService } from './tasks.service';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { TaskRecord } from '../types/db-records';
import { AuthenticatedUser } from '../auth/jwt.strategy';
import { PoliciesGuard } from '../casl/policies.guard';
import { ProjectsService } from '../projects/projects.service';

// ### ИЗМЕНЕНИЕ: Добавлено поле role ###
const mockUser: AuthenticatedUser = { id: 'user-1', email: 'test@example.com', name: 'Test User', role: 'user' };
const mockTask: TaskRecord = { id: 'task-1', human_readable_id: 'TP-1', task_number: 1, title: 'Test Task', description: null, position: 0, project_id: 1, column_id: 'col-1', assignee_id: null, creator_id: 'user-1', due_date: null, created_at: new Date(), updated_at: new Date(), type: null, priority: null, tags: null };

const mockTasksService = {
  createTask: jest.fn().mockResolvedValue(mockTask),
  findTaskByHumanId: jest.fn().mockResolvedValue(mockTask),
  updateTask: jest.fn().mockResolvedValue(mockTask),
  moveTask: jest.fn().mockResolvedValue(mockTask),
  addCommentToTask: jest.fn(),
  getCommentsForTask: jest.fn(),
};

const mockProjectsService = {
  getUserRoleForProject: jest.fn().mockResolvedValue('owner'),
};

describe('TasksController', () => {
  let controller: TasksController;
  let service: TasksService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [TasksController],
      providers: [
        PoliciesGuard,
        { provide: TasksService, useValue: mockTasksService },
        { provide: ProjectsService, useValue: mockProjectsService },
      ],
    })
    .overrideGuard(JwtAuthGuard)
    .useValue({ canActivate: (context) => {
        const req = context.switchToHttp().getRequest();
        req.user = mockUser;
        return true;
      } 
    })
    .overrideGuard(PoliciesGuard)
    .useValue({ canActivate: () => true })
    .compile();

    controller = module.get<TasksController>(TasksController);
    service = module.get<TasksService>(TasksService);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });

  const mockReq = { user: mockUser };

  describe('create', () => {
    it('should call service.createTask and return a task', async () => {
      const createDto = { title: 'New Task', columnId: 'col-1' };
      await controller.create(1, createDto, mockReq);
      expect(service.createTask).toHaveBeenCalledWith(1, createDto, mockUser);
    });
  });

  describe('findOne', () => {
    it('should call service.findTaskByHumanId and return a task', async () => {
      await controller.findOne(mockTask.human_readable_id);
      expect(service.findTaskByHumanId).toHaveBeenCalledWith(mockTask.human_readable_id);
    });
  });
  
  describe('update', () => {
    it('should call service.updateTask and return a task', async () => {
      const updateDto = { title: 'Updated Task' };
      await controller.update(mockTask.id, updateDto, mockReq);
      expect(service.updateTask).toHaveBeenCalledWith(mockTask.id, updateDto, mockUser);
    });
  });

  describe('move', () => {
    it('should call service.moveTask and return a task', async () => {
      const moveDto = { newColumnId: 'col-2', newPosition: 0 };
      await controller.move(mockTask.id, moveDto, mockReq);
      expect(service.moveTask).toHaveBeenCalledWith(mockTask.id, moveDto, mockUser);
    });
  });
});

================================================
FILE: api/src/tasks/tasks.controller.ts
================================================
// api/src/tasks/tasks.controller.ts
import { Controller, Post, Body, Get, Param, Patch, UseGuards, Req, HttpCode, HttpStatus, ParseIntPipe, ParseUUIDPipe } from '@nestjs/common';
import { TasksService } from './tasks.service';
import { CreateTaskDto } from './dto/create-task.dto';
import { UpdateTaskDto } from './dto/update-task.dto';
import { MoveTaskDto } from './dto/move-task.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { CreateCommentDto } from '../comments/dto/create-comment.dto';
import { AuthenticatedUser } from '../auth/jwt.strategy';
import { ApiTags, ApiBearerAuth, ApiOperation } from '@nestjs/swagger';
import { CheckPolicies } from '../casl/check-policies.decorator';
import { CanEditProjectContentPolicy, CanViewProjectPolicy } from '../casl/project-policies.handler';

@ApiBearerAuth()
@ApiTags('Tasks & Comments')
// ### ИЗМЕНЕНИЕ: Убираем PoliciesGuard, так как он теперь глобальный
@UseGuards(JwtAuthGuard)
@Controller('api/v1')
export class TasksController {
  constructor(private readonly tasksService: TasksService) {}

  @Post('projects/:projectId/tasks')
  @CheckPolicies(CanEditProjectContentPolicy)
  @ApiOperation({ summary: 'Create a new task in a project' })
  @HttpCode(HttpStatus.CREATED)
  create(
    @Param('projectId', ParseIntPipe) projectId: number,
    @Body() createTaskDto: CreateTaskDto,
    @Req() req,
  ) {
    const user = req.user as AuthenticatedUser;
    return this.tasksService.createTask(projectId, createTaskDto, user);
  }

  @Get('tasks/:hid')
  @CheckPolicies(CanViewProjectPolicy)
  @ApiOperation({ summary: 'Get a task by its Human-Readable ID (e.g., MUT-1)' })
  findOne(@Param('hid') hid: string) {
    return this.tasksService.findTaskByHumanId(hid);
  }

  @Patch('tasks/:id')
  @CheckPolicies(CanEditProjectContentPolicy)
  @ApiOperation({ summary: 'Update a task' })
  @HttpCode(HttpStatus.OK)
  update(@Param('id', ParseUUIDPipe) id: string, @Body() updateTaskDto: UpdateTaskDto, @Req() req) {
    const user = req.user as AuthenticatedUser;
    return this.tasksService.updateTask(id, updateTaskDto, user);
  }

  @Patch('tasks/:id/move')
  @CheckPolicies(CanEditProjectContentPolicy)
  @ApiOperation({ summary: 'Move a task between columns or positions' })
  @HttpCode(HttpStatus.OK)
  move(@Param('id', ParseUUIDPipe) id: string, @Body() moveTaskDto: MoveTaskDto, @Req() req) {
    const user = req.user as AuthenticatedUser;
    return this.tasksService.moveTask(id, moveTaskDto, user);
  }

  @Post('tasks/:taskId/comments')
  @CheckPolicies(CanEditProjectContentPolicy)
  @ApiOperation({ summary: 'Add a comment to a task' })
  @HttpCode(HttpStatus.CREATED)
  createComment(@Param('taskId', ParseUUIDPipe) taskId: string, @Body() createCommentDto: CreateCommentDto, @Req() req) {
    const user = req.user as AuthenticatedUser;
    return this.tasksService.addCommentToTask(taskId, createCommentDto, user);
  }

  @Get('tasks/:taskId/comments')
  @CheckPolicies(CanViewProjectPolicy)
  @ApiOperation({ summary: 'Get all comments for a task' })
  getComments(@Param('taskId', ParseUUIDPipe) taskId: string) {
    return this.tasksService.getCommentsForTask(taskId);
  }
}

================================================
FILE: api/src/tasks/tasks.module.ts
================================================
// api/src/tasks/tasks.module.ts

import { Module, forwardRef } from '@nestjs/common';
import { TasksService } from './tasks.service';
import { TasksController } from './tasks.controller';
import { EventsModule } from '../events/events.module';
import { CommentsModule } from '../comments/comments.module';
// ### ИЗМЕНЕНИЕ: Закомментированный импорт CaslModule удален ###
import { KnexModule } from '../knex/knex.module';
import { NotificationsModule } from '../notifications/notifications.module';
import { ProjectsModule } from '../projects/projects.module';

@Module({
  imports: [
    KnexModule,
    EventsModule,
    CommentsModule,
    NotificationsModule,
    // ### ИЗМЕНЕНИЕ: Закомментированный импорт CaslModule удален ###
    forwardRef(() => ProjectsModule),
  ],
  controllers: [TasksController],
  providers: [TasksService],
  exports: [TasksService],
})
export class TasksModule {}

================================================
FILE: api/src/tasks/tasks.service.spec.ts
================================================
import { Test, TestingModule } from '@nestjs/testing';
import { TasksService } from './tasks.service';
import { EventsGateway } from '../events/events.gateway';
import { CommentsService } from '../comments/comments.service';
import { ProjectsService } from '../projects/projects.service';
import { KNEX_CONNECTION } from '../knex/knex.constants';
import { TaskRecord } from '../types/db-records';
import { AuthenticatedUser } from 'src/auth/jwt.strategy';
import { NotificationsService } from '../notifications/notifications.service';
import { Logger, BadRequestException, NotFoundException } from '@nestjs/common';

const mockUser: AuthenticatedUser = { id: 'user-1', email: 'test@example.com', name: 'Test User', role: 'user' };

describe('TasksService', () => {
  let service: TasksService;
  let knex;
  let mockProjectsService: ProjectsService;
  let mockEventsGateway: EventsGateway;

  const mockQueryBuilder = {
    where: jest.fn().mockReturnThis(),
    andWhere: jest.fn().mockReturnThis(),
    first: jest.fn(),
    insert: jest.fn().mockReturnThis(),
    returning: jest.fn(),
    select: jest.fn().mockReturnThis(),
    count: jest.fn().mockReturnValue({
      first: jest.fn(),
    }),
    forUpdate: jest.fn().mockReturnThis(),
    increment: jest.fn().mockReturnThis(),
    decrement: jest.fn().mockReturnThis(),
    update: jest.fn().mockReturnThis(),
  };

  const mockKnexFn = jest.fn(() => mockQueryBuilder);

  beforeEach(async () => {
    jest.clearAllMocks();

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        TasksService,
        Logger,
        {
          provide: KNEX_CONNECTION,
          useValue: Object.assign(mockKnexFn, {
            transaction: jest.fn().mockImplementation(async (callback) => callback(mockKnexFn)),
          }),
        },
        {
          provide: EventsGateway,
          useValue: { emitTaskCreated: jest.fn(), emitTaskUpdated: jest.fn(), emitTaskMoved: jest.fn() },
        },
        {
          provide: CommentsService,
          useValue: { createComment: jest.fn() },
        },
        {
          provide: ProjectsService,
          useValue: { 
            isTaskTypeValidForProject: jest.fn().mockResolvedValue(true),
            getUserRoleForProject: jest.fn().mockResolvedValue('owner'),
          },
        },
        {
          provide: NotificationsService,
          useValue: { createMentionNotifications: jest.fn() },
        },
      ],
    }).compile();

    service = module.get<TasksService>(TasksService);
    knex = module.get(KNEX_CONNECTION);
    // ### ИЗМЕНЕНИЕ: Исправлено получение мока сервиса ###
    mockProjectsService = module.get<ProjectsService>(ProjectsService);
    mockEventsGateway = module.get<EventsGateway>(EventsGateway);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('getProjectIdByHumanId', () => {
    it('should return project ID for a given human-readable ID', async () => {
      const hid = 'TP-1';
      const expectedProjectId = 123;
      mockQueryBuilder.first.mockResolvedValue({ project_id: expectedProjectId });
  
      const projectId = await service.getProjectIdByHumanId(hid);
  
      expect(projectId).toBe(expectedProjectId);
      expect(mockKnexFn).toHaveBeenCalledWith('tasks');
      expect(mockQueryBuilder.where).toHaveBeenCalledWith({ human_readable_id: hid });
      expect(mockQueryBuilder.select).toHaveBeenCalledWith('project_id');
    });
  
    it('should throw NotFoundException if task with HID is not found', async () => {
      const hid = 'TP-999';
      mockQueryBuilder.first.mockResolvedValue(null);
  
      await expect(service.getProjectIdByHumanId(hid)).rejects.toThrow(NotFoundException);
    });
  });

  describe('createTask', () => {
    const projectId = 1;
    const createTaskDto = { title: 'New Task', columnId: 'col-1' };
    const mockColumn = { id: 'col-1', project_id: projectId };
    const mockProject = { last_task_number: 1, task_prefix: 'TP' };
    const mockTask: Partial<TaskRecord> = { id: 'task-1', title: 'New Task' };

    it('should create a task successfully', async () => {
      mockQueryBuilder.first.mockResolvedValueOnce(mockColumn);
      mockQueryBuilder.count().first.mockResolvedValueOnce({ count: '5' });
      mockQueryBuilder.returning.mockResolvedValueOnce([mockProject]);
      mockQueryBuilder.returning.mockResolvedValueOnce([mockTask]);

      const result = await service.createTask(projectId, createTaskDto, mockUser);
      
      expect(result).toEqual(mockTask);
      expect(mockEventsGateway.emitTaskCreated).toHaveBeenCalledWith(mockTask);
      expect(mockQueryBuilder.increment).toHaveBeenCalledWith('last_task_number', 1);
      expect(mockQueryBuilder.insert).toHaveBeenCalledWith(expect.objectContaining({
        human_readable_id: `${mockProject.task_prefix}-${mockProject.last_task_number}`,
        position: 5,
        creator_id: mockUser.id,
      }));
    });

    it('should throw BadRequestException if column does not exist', async () => {
      mockQueryBuilder.first.mockResolvedValue(null);
      await expect(service.createTask(projectId, createTaskDto, mockUser)).rejects.toThrow(BadRequestException);
    });

    it('should throw BadRequestException if task type is invalid', async () => {
      (mockProjectsService.isTaskTypeValidForProject as jest.Mock).mockResolvedValue(false);
      mockQueryBuilder.first.mockResolvedValueOnce(mockColumn);
      const dtoWithInvalidType = { ...createTaskDto, type: 'InvalidType' };
      await expect(service.createTask(projectId, dtoWithInvalidType, mockUser)).rejects.toThrow(BadRequestException);
    });
  });

  describe('updateTask', () => {
    const taskId = 'task-uuid';
    const updateDto = { title: 'Updated Title' };
    const mockTask = { id: taskId, project_id: 1, title: 'Old Title' };
    const updatedMockTask = { ...mockTask, ...updateDto };

    it('should update a task successfully', async () => {
      mockQueryBuilder.first.mockResolvedValue(mockTask);
      mockQueryBuilder.returning.mockResolvedValue([updatedMockTask]);

      const result = await service.updateTask(taskId, updateDto, mockUser);

      expect(result).toEqual(updatedMockTask);
      expect(knex.transaction).toHaveBeenCalled();
      expect(mockQueryBuilder.update).toHaveBeenCalledWith(expect.objectContaining({ title: 'Updated Title' }));
      expect(mockEventsGateway.emitTaskUpdated).toHaveBeenCalledWith(updatedMockTask);
    });
    
    it('should throw NotFoundException if task does not exist', async () => {
        mockQueryBuilder.first.mockResolvedValue(null);
        await expect(service.updateTask(taskId, updateDto, mockUser)).rejects.toThrow(NotFoundException);
    });
  });

  describe('moveTask', () => {
    const taskId = 'task-uuid';
    const moveDto = { newColumnId: 'col-2', newPosition: 0 };
    const taskToMove = { id: taskId, project_id: 1, column_id: 'col-1', position: 2 };
    
    it('should move a task and reorder positions', async () => {
      mockQueryBuilder.first
        .mockResolvedValueOnce(taskToMove)
        .mockResolvedValueOnce({ id: 'col-2', project_id: 1 })
        .mockResolvedValueOnce(taskToMove);
        
      mockQueryBuilder.decrement.mockResolvedValue(1);
      mockQueryBuilder.increment.mockResolvedValue(1);
      
      const finalMovedTask = { 
        ...taskToMove, 
        column_id: moveDto.newColumnId,
        position: moveDto.newPosition,
      };
      mockQueryBuilder.returning.mockResolvedValue([finalMovedTask]);

      const result = await service.moveTask(taskId, moveDto, mockUser);

      expect(knex.transaction).toHaveBeenCalled();
      expect(mockQueryBuilder.decrement).toHaveBeenCalledWith('position');
      expect(mockQueryBuilder.increment).toHaveBeenCalledWith('position');
      expect(mockQueryBuilder.update).toHaveBeenCalledWith(expect.objectContaining({
        column_id: moveDto.newColumnId,
        position: moveDto.newPosition,
      }));
      expect(mockEventsGateway.emitTaskMoved).toHaveBeenCalled();
      expect(result.column_id).toBe('col-2');
    });
  });
});

================================================
FILE: api/src/tasks/tasks.service.ts
================================================
// api/src/tasks/tasks.service.ts
import { Injectable, NotFoundException, BadRequestException, Inject, Logger, forwardRef } from '@nestjs/common';
import { CreateTaskDto } from './dto/create-task.dto';
import { MoveTaskDto } from './dto/move-task.dto';
import { UpdateTaskDto } from './dto/update-task.dto';
import { EventsGateway } from '../events/events.gateway';
import { CommentsService } from '../comments/comments.service';
import { CreateCommentDto } from '../comments/dto/create-comment.dto';
import { Knex } from 'knex';
import { KNEX_CONNECTION } from '../knex/knex.constants';
import * as crypto from 'crypto';
import { TaskRecord, UserRecord, ProjectRecord } from '../types/db-records';
import { ProjectsService } from '../projects/projects.service';
import { Role } from '../casl/roles.enum';
import { NotificationsService } from '../notifications/notifications.service';
import { AuthenticatedUser } from 'src/auth/jwt.strategy';

@Injectable()
export class TasksService {
  private readonly logger = new Logger(TasksService.name);

  constructor(
    @Inject(KNEX_CONNECTION) private readonly knex: Knex,
    private readonly eventsGateway: EventsGateway,
    private readonly commentsService: CommentsService,
    private readonly notificationsService: NotificationsService,
    private readonly projectsService: ProjectsService,
  ) {}

  // ### НОВОЕ: Вспомогательный метод для PoliciesGuard ###
  async getProjectIdByHumanId(hid: string): Promise<number> {
    const task = await this.knex('tasks').where({ human_readable_id: hid }).select('project_id').first();
    if (!task) {
        throw new NotFoundException(`Task with ID ${hid} not found.`);
    }
    return task.project_id;
  }

  async getUserRoleForTask(taskId: string, userId: string): Promise<Role | null> {
    const task = await this.knex('tasks').where({ id: taskId }).select('project_id').first();
    if (!task) {
      throw new NotFoundException(`Task with ID ${taskId} not found.`);
    }
    return this.projectsService.getUserRoleForProject(task.project_id, userId);
  }

  async createTask(projectId: number, createTaskDto: CreateTaskDto, user: AuthenticatedUser): Promise<TaskRecord> {
    const { title, description, columnId, assigneeId, dueDate, type, priority, tags } = createTaskDto;

    return this.knex.transaction(async (trx) => {
      const column = await trx('columns').where({id: columnId, project_id: projectId}).first();
      if(!column) throw new BadRequestException(`Column with ID ${columnId} does not belong to project ${projectId}.`);

      if (type && !(await this.projectsService.isTaskTypeValidForProject(projectId, type, trx))) {
        throw new BadRequestException(`Task type '${type}' is not valid for this project.`);
      }

      const [updatedProject] = await trx('projects')
        .where({ id: projectId })
        .forUpdate()
        .increment('last_task_number', 1)
        .returning(['last_task_number', 'task_prefix']);

      const taskNumber = updatedProject.last_task_number;
      const humanReadableId = `${updatedProject.task_prefix}-${taskNumber}`;

      const tasksInColumnResult = await trx('tasks').where({ column_id: columnId }).count({ count: '*' }).first();
      const position = parseInt(tasksInColumnResult.count as string, 10);

      const [newTask] = await trx('tasks').insert({
        id: crypto.randomUUID(),
        title,
        description,
        column_id: columnId,
        project_id: projectId,
        assignee_id: assigneeId,
        due_date: dueDate ? new Date(dueDate) : null,
        type,
        priority,
        tags,
        human_readable_id: humanReadableId,
        task_number: taskNumber,
        position,
        creator_id: user.id,
      }).returning('*');

      this.eventsGateway.emitTaskCreated(newTask);
      return newTask;
    });
  }

  async findTaskById(taskId: string): Promise<TaskRecord> {
    const task = await this.knex('tasks').where({ id: taskId }).first();
    if (!task) throw new NotFoundException(`Task with ID ${taskId} not found.`);
    return task;
  }

  async findTaskByHumanId(hid: string): Promise<TaskRecord> {
    const task = await this.knex('tasks').where({ human_readable_id: hid }).first();
    if (!task) {
      throw new NotFoundException(`Task with ID ${hid} not found.`);
    }
    return task;
  }

  async updateTask(taskId: string, updateTaskDto: UpdateTaskDto, user: AuthenticatedUser): Promise<TaskRecord> {
    return this.knex.transaction(async (trx) => {
        const task = await trx('tasks').where({ id: taskId }).first();
        if (!task) throw new NotFoundException(`Task with ID ${taskId} not found.`);

        if (updateTaskDto.type && !(await this.projectsService.isTaskTypeValidForProject(task.project_id, updateTaskDto.type, trx))) {
            throw new BadRequestException(`Task type '${updateTaskDto.type}' is not valid for this project.`);
        }

        const { title, description, assigneeId, dueDate, type, priority, tags } = updateTaskDto;
        const updatePayload: Partial<TaskRecord> = {
            ...(title !== undefined && { title }),
            ...(description !== undefined && { description }),
            ...(assigneeId !== undefined && { assignee_id: assigneeId }),
            ...(dueDate !== undefined && { due_date: dueDate ? new Date(dueDate) : null }),
            ...(type !== undefined && { type }),
            ...(priority !== undefined && { priority }),
            ...(tags !== undefined && { tags }),
        };

        if (Object.keys(updatePayload).length === 0) {
          return task;
        }

        const [updatedTask] = await trx('tasks')
            .where({ id: taskId })
            .update({ ...updatePayload, updated_at: new Date() })
            .returning('*');

        this.eventsGateway.emitTaskUpdated(updatedTask);
        return updatedTask;
    });
  }

  async moveTask(taskId: string, moveTaskDto: MoveTaskDto, user: AuthenticatedUser): Promise<TaskRecord> {
    const { newColumnId, newPosition } = moveTaskDto;

    return this.knex.transaction(async (trx) => {
      const taskToMove = await trx('tasks').where({ id: taskId }).first();
      if (!taskToMove) throw new NotFoundException(`Task with ID ${taskId} not found.`);
      
      const targetColumn = await trx('columns').where({ id: newColumnId, project_id: taskToMove.project_id }).first();
      if (!targetColumn) throw new BadRequestException(`Target column with ID ${newColumnId} not found in this project.`);

      await trx('tasks').where({ id: taskId }).forUpdate().first();

      const oldColumnId = taskToMove.column_id;
      const oldPosition = taskToMove.position;

      await trx('tasks').where({ column_id: oldColumnId }).andWhere('position', '>', oldPosition).decrement('position');
      await trx('tasks').where({ column_id: newColumnId }).andWhere('position', '>=', newPosition).increment('position');

      const [finalMovedTask] = await trx('tasks')
        .where({ id: taskId })
        .update({ column_id: newColumnId, position: newPosition, updated_at: new Date() })
        .returning('*');

      this.eventsGateway.emitTaskMoved(finalMovedTask);
      return finalMovedTask;
    });
  }

  async addCommentToTask(taskId: string, createCommentDto: CreateCommentDto, author: AuthenticatedUser) {
    const task = await this.findTaskById(taskId);
    const newComment = await this.commentsService.createComment(task.id, createCommentDto, author.id);
    
    await this.notificationsService.createMentionNotifications(newComment, task.title, task.project_id);

    return newComment;
  }

  async getCommentsForTask(taskId: string) {
    await this.findTaskById(taskId);
    return this.commentsService.getCommentsForTask(taskId);
  }
}

================================================
FILE: api/src/types/db-records.d.ts
================================================
// api/src/types/db-records.d.ts

export type UserRecord = {
  id: string;
  email: string;
  name: string | null;
  password_hash: string;
  role: 'admin' | 'user';
  created_at: Date;
  updated_at: Date;
};

// ### НОВОЕ: Тип для объединенного списка участников ###
export type AllParticipants = {
  id: string;
  name: string | null;
  email: string;
  role: string; // 'owner', 'editor', 'viewer'
};

export type ProjectRecord = {
  id: number;
  name: string;
  task_prefix: string;
  last_task_number: number;
  owner_id: string;
  created_at: Date;
  updated_at: Date;
};

export type ProjectMemberRecord = {
  project_id: number;
  user_id: string;
  role: 'owner' | 'editor' | 'viewer';
};

export type ProjectMemberWithUser = ProjectMemberRecord & {
  user: Pick<UserRecord, 'id' | 'name' | 'email' | 'created_at' | 'updated_at'>;
};

export type ColumnRecord = {
  id: string;
  name: string;
  position: number;
  project_id: number;
  created_at: Date;
  updated_at: Date;
};

export type TaskRecord = {
  id: string;
  human_readable_id: string;
  task_number: number;
  title: string;
  description: string | null;
  position: number;
  type: string | null;
  priority: string | null;
  tags: string[] | null;
  project_id: number;
  column_id: string;
  assignee_id: string | null;
  creator_id: string;
  due_date: Date | null;
  created_at: Date;
  updated_at: Date;
};

export type CommentRecord = {
  id: string;
  text: string;
  task_id: string;
  author_id: string | null;
  created_at: Date;
  updated_at: Date;
  author?: Pick<UserRecord, 'id' | 'name' | 'email'>;
};

export type NotificationRecord = {
    id: string;
    recipient_id: string;
    text: string;
    is_read: boolean;
    source_url: string | null;
    task_id: string | null;
    created_at: Date;
    updated_at: Date;
};

================================================
FILE: api/tsconfig.build.json
================================================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}


================================================
FILE: api/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true,
    "strictNullChecks": false,
    "noImplicitAny": false,
    "strictBindCallApply": false,
    "forceConsistentCasingInFileNames": false,
    "noFallthroughCasesInSwitch": false
  },
  "exclude": [
    "node_modules",
    "dist",
    "src/ai" 
  ]
}

================================================
FILE: client/Dockerfile
================================================
# Stage 1: Build the Vite application
FROM node:18-alpine AS build

WORKDIR /app

COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build

# Stage 2: Serve the application with Nginx
FROM nginx:stable-alpine

# Копируем собранные ассеты из стадии сборки
COPY --from=build /app/dist /usr/share/nginx/html

# Копируем конфигурацию Nginx
COPY nginx.conf /etc/nginx/conf.d/default.conf

EXPOSE 3000

CMD ["nginx", "-g", "daemon off;"]

================================================
FILE: client/Dockerfile.dev
================================================
# client/Dockerfile.dev
# Dockerfile для режима разработки клиента (с Hot-Reload)
FROM node:18-alpine

WORKDIR /app

# Копируем только package.json для кэширования установки зависимостей
COPY package*.json ./

# Устанавливаем зависимости
RUN npm install

# Копируем остальной код.
# Файлы будут обновляться через volume mount, но это нужно для первоначального состояния.
COPY . .

# Открываем порт, который использует Vite dev server
EXPOSE 3000

# Команда для запуска dev-сервера.
# Он будет слушать на всех интерфейсах внутри контейнера.
CMD ["npm", "run", "dev"]

================================================
FILE: client/.env
================================================
# Example environment variables for the client application

# The base URL for the API
VITE_API_URL=http://localhost:3001


================================================
FILE: client/.env.example
================================================
# Example environment variables for the client application

# The base URL for the API
VITE_API_URL=http://localhost:3001


================================================
FILE: client/eslint.config.js
================================================
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
)


================================================
FILE: client/.gitignore
================================================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Environment variables
.env
.env.*
!.env.example
!.env.template

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

coverage/

================================================
FILE: client/index.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React + TS</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>


================================================
FILE: client/nginx.conf
================================================
server {
  listen 3000;

  location / {
    root   /usr/share/nginx/html;
    index  index.html index.htm;
    try_files $uri $uri/ /index.html;
  }

  # Optional: Add error pages
  error_page   500 502 503 504  /50x.html;
  location = /50x.html {
    root   /usr/share/nginx/html;
  }
}


================================================
FILE: client/package.json
================================================
{
  "name": "client",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite --host",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview",
    "test": "vitest run --no-cache",
    "test:ui": "vitest --ui",
    "test:cov": "vitest run --coverage"
  },
  "dependencies": {
    "@dnd-kit/core": "^6.0.0",
    "@dnd-kit/sortable": "^7.0.0",
    "axios": "^1.10.0",
    "jwt-decode": "^3.0.0",
    "react": "^19.1.0",
    "react-dom": "^19.1.0",
    "react-router-dom": "^7.6.2",
    "socket.io-client": "^4.0.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.29.0",
    "@testing-library/jest-dom": "^6.4.0",
    "@testing-library/react": "^16.1.0",
    "@testing-library/user-event": "^14.5.0",
    "@types/jest": "^29.0.0",
    "@types/jwt-decode": "^3.1.0",
    "@types/react": "^19.1.2",
    "@types/react-dom": "^19.1.2",
    "@types/socket.io-client": "^3.0.0",
    "@vitejs/plugin-react": "latest",
    "@vitest/coverage-v8": "^2.0.4",
    "@vitest/ui": "latest",
    "eslint": "^9.25.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.19",
    "globals": "^16.0.0",
    "jsdom": "^24.1.0",
    "typescript": "~5.8.3",
    "typescript-eslint": "^8.30.1",
    "vite": "latest",
    "vitest": "latest"
  }
}

================================================
FILE: client/public/vite.svg
================================================
[Binary file]


================================================
FILE: client/README.md
================================================
# Mutabor Client

For initial setup, installation, and running the client application (including environment variable `VITE_API_URL`), please refer to the [main project README.md](../../README.md#режим-локальной-разработки-manual-local-development-setup).

This README provides additional information specific to the client's Vite and ESLint configuration.

---

# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:

```js
export default tseslint.config({
  extends: [
    // Remove ...tseslint.configs.recommended and replace with this
    ...tseslint.configs.recommendedTypeChecked,
    // Alternatively, use this for stricter rules
    ...tseslint.configs.strictTypeChecked,
    // Optionally, add this for stylistic rules
    ...tseslint.configs.stylisticTypeChecked,
  ],
  languageOptions: {
    // other options...
    parserOptions: {
      project: ['./tsconfig.node.json', './tsconfig.app.json'],
      tsconfigRootDir: import.meta.dirname,
    },
  },
})
```

You can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:

```js
// eslint.config.js
import reactX from 'eslint-plugin-react-x'
import reactDom from 'eslint-plugin-react-dom'

export default tseslint.config({
  plugins: {
    // Add the react-x and react-dom plugins
    'react-x': reactX,
    'react-dom': reactDom,
  },
  rules: {
    // other rules...
    // Enable its recommended typescript rules
    ...reactX.configs['recommended-typescript'].rules,
    ...reactDom.configs.recommended.rules,
  },
})
```


================================================
FILE: client/src/app/AppRouter.tsx
================================================
// client/src/app/AppRouter.tsx
import React, { useState } from 'react';
import { Routes, Route, Navigate } from 'react-router-dom';
import { useAuth } from './auth/AuthContext';
import { AddTaskModalContext } from '../shared/contexts/AddTaskModalContext';
import Header from '../widgets/Header/Header';
import LandingPage from '../pages/LandingPage';
import LoginPage from '../pages/LoginPage';
import RegistrationPage from '../pages/RegistrationPage';
import DashboardPage from '../pages/DashboardPage';
import BoardPage from '../pages/BoardPage';
import TaskPage from '../pages/TaskPage';
import UserSettingsPage from '../pages/UserSettingsPage';
import ProjectSettingsPage from '../pages/ProjectSettingsPage';
import NotFoundPage from '../pages/NotFoundPage';

export const AppRouter: React.FC = () => {
  const { isAuthenticated, isLoading } = useAuth();
  const [isAddTaskModalOpen, setIsAddTaskModalOpen] = useState(false);

  const addTaskModalContextValue = {
    isModalOpen: isAddTaskModalOpen,
    openModal: () => setIsAddTaskModalOpen(true),
    closeModal: () => setIsAddTaskModalOpen(false),
  };

  if (isLoading) {
    return <div>Loading application...</div>;
  }

  return (
    <AddTaskModalContext.Provider value={addTaskModalContextValue}>
      <Header />
      <Routes>
        <Route path="/" element={isAuthenticated ? <Navigate to="/dashboard" /> : <LandingPage />} />
        <Route path="/login" element={isAuthenticated ? <Navigate to="/dashboard" /> : <LoginPage />} />
        <Route path="/register" element={isAuthenticated ? <Navigate to="/dashboard" /> : <RegistrationPage />} />
        <Route
          path="/dashboard"
          element={isAuthenticated ? <DashboardPage /> : <Navigate to="/login" />}
        />
        <Route
          path="/projects/:projectId"
          element={isAuthenticated ? <BoardPage /> : <Navigate to="/login" />}
        />
        <Route
          path="/tasks/:taskHid" 
          element={isAuthenticated ? <TaskPage /> : <Navigate to="/login" />}
        />
        <Route
          path="/settings"
          element={isAuthenticated ? <UserSettingsPage /> : <Navigate to="/login" />}
        />
        <Route
          path="/projects/:projectId/settings"
          element={isAuthenticated ? <ProjectSettingsPage /> : <Navigate to="/login" />}
        />
        <Route path="/404" element={<NotFoundPage />} />
        <Route path="*" element={<Navigate to="/404" replace />} />
      </Routes>
    </AddTaskModalContext.Provider>
  );
};

================================================
FILE: client/src/app/App.spec.tsx
================================================
// client/src/app/App.spec.tsx
import React from 'react';
import { render, screen } from '@testing-library/react';
import { MemoryRouter } from 'react-router-dom';
import { AppRouter } from './AppRouter';
import { AuthContext, AuthenticatedUser } from './auth/AuthContext';
import { AddTaskModalContext } from '../shared/contexts/AddTaskModalContext'; // ### НОВОЕ: Импортируем AddTaskModalContext

// Mock child components
vi.mock('../pages/DashboardPage', () => ({ default: () => <div>DashboardPageMock</div>}));
vi.mock('../pages/RegistrationPage', () => ({ default: () => <div>RegistrationPageMock</div>}));
vi.mock('../pages/LoginPage', () => ({ default: () => <div>LoginPageMock</div>}));
vi.mock('../pages/LandingPage', () => ({ default: () => <div>LandingPageMock</div>}));
vi.mock('../pages/ProjectSettingsPage', () => ({ default: () => <div>ProjectSettingsPageMock</div>}));
vi.mock('../pages/BoardPage', () => ({ default: () => <div>BoardPageMock</div> }));
vi.mock('../widgets/Header/Header', () => ({ default: () => <header>HeaderMock</header>}));

// ### ИЗМЕНЕНИЕ: Вспомогательная функция теперь включает AddTaskModalContext.Provider ###
const renderWithProviders = (
  ui: React.ReactElement, 
  { authValue, initialEntries = ['/'] }: { authValue: any; initialEntries?: string[] }
) => {
  const addTaskModalValue = {
    isModalOpen: false,
    openModal: vi.fn(),
    closeModal: vi.fn(),
  };

  return render(
    <MemoryRouter initialEntries={initialEntries}>
      <AuthContext.Provider value={authValue}>
        <AddTaskModalContext.Provider value={addTaskModalValue}>
          {ui}
        </AddTaskModalContext.Provider>
      </AuthContext.Provider>
    </MemoryRouter>
  );
};

describe('AppRouter Component', () => {

  it('renders loading state initially if auth is loading', () => {
    renderWithProviders(<AppRouter />, { 
      authValue: { isAuthenticated: false, isLoading: true, user: null } 
    });
    expect(screen.getByText(/Loading application/i)).toBeInTheDocument();
  });

  it('renders landing page for unauthenticated user when auth is not loading', () => {
    renderWithProviders(<AppRouter />, {
      authValue: { isAuthenticated: false, isLoading: false, user: null }
    });
    expect(screen.getByText('LandingPageMock')).toBeInTheDocument();
  });

  it('renders dashboard page for authenticated user when auth is not loading', () => {
    const mockUser: AuthenticatedUser = { name: 'Test User', email: 'test@example.com', id: '1' };
    renderWithProviders(<AppRouter />, {
      authValue: { isAuthenticated: true, isLoading: false, user: mockUser }
    });
    expect(screen.getByText('DashboardPageMock')).toBeInTheDocument();
  });
});

================================================
FILE: client/src/app/App.tsx
================================================
// client/src/app/App.tsx
import React from 'react';
import './styles/global.css';
import { ThemeProvider } from '../shared/contexts/ThemeContext';
import { AppRouter } from './AppRouter'; // Импортируем роутер

const App: React.FC = () => {
  return (
    <ThemeProvider>
      <AppRouter />
    </ThemeProvider>
  );
};

export default App;

================================================
FILE: client/src/app/auth/AuthContext.tsx
================================================
// client/src/app/auth/AuthContext.tsx
// ### ИЗМЕНЕНИЕ: 'ReactNode' импортируется как тип ###
import { createContext, useState, useContext, useEffect, useCallback, type ReactNode } from 'react';
import jwtDecode from 'jwt-decode';

export interface AuthenticatedUser {
  id: string; 
  email: string; 
  name?: string; 
}

interface DecodedJwtPayload {
  sub: string;
  email: string;
  name?: string;
  iat?: number;
  exp?: number;
}

interface AuthContextType {
  authToken: string | null;
  user: AuthenticatedUser | null;
  isAuthenticated: boolean;
  login: (token: string) => void;
  logout: () => void;
  isLoading: boolean;
}

// ### ИЗМЕНЕНИЕ: Добавляем export ###
export const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider = ({ children }: { children: ReactNode }) => {
  const [authToken, setAuthToken] = useState<string | null>(null);
  const [user, setUser] = useState<AuthenticatedUser | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  const logout = useCallback(() => {
    localStorage.removeItem('authToken');
    setAuthToken(null);
    setUser(null);
  }, []);

  useEffect(() => {
    const token = localStorage.getItem('authToken');
    if (token) {
      try {
        const decoded = jwtDecode<DecodedJwtPayload>(token);
        setUser({ id: decoded.sub, email: decoded.email, name: decoded.name });
        setAuthToken(token);
      } catch (error) {
        console.error("Failed to decode token on initial load:", error);
        localStorage.removeItem('authToken');
      }
    }
    setIsLoading(false);
  }, []);

  useEffect(() => {
    const handleAuthError = () => {
      console.log("Auth error event received, logging out.");
      logout();
    };

    window.addEventListener('auth-error', handleAuthError);

    return () => {
      window.removeEventListener('auth-error', handleAuthError);
    };
  }, [logout]);

  const login = (token: string) => {
    try {
      const decoded = jwtDecode<DecodedJwtPayload>(token);
      setUser({ id: decoded.sub, email: decoded.email, name: decoded.name });
      localStorage.setItem('authToken', token);
      setAuthToken(token);
    } catch (error) {
      console.error("Failed to decode token on login:", error);
    }
  };

  return (
    <AuthContext.Provider value={{ authToken, user, isAuthenticated: !!authToken && !!user, login, logout, isLoading }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

================================================
FILE: client/src/app/styles/global.css
================================================
@import './theme.css'; /* Import theme variables */

/* Global Styles for Mutabor */

/* 1. CSS Variables (Design Tokens) */
body {
  --color-primary: #6D28D9;
  --color-success: #10B981;
  --color-error: #EF4444;
  --color-warning: #F59E0B;
  --color-info: #3B82F6;
  --font-family-main: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  --font-family-mono: "SF Mono", "Menlo", "Consolas", "Courier New", monospace;
  --spacing-base: 8px;
  --border-radius-small: 4px;
  --border-radius-medium: 6px;
  --border-radius-large: 8px;
  --color-primary-rgb: 109, 40, 217;
  --color-error-dark: #d73737;
  --color-primary-background-hover: rgba(var(--color-primary-rgb), 0.1);
  --color-background-danger-subtle: rgba(239, 68, 68, 0.1);
  --color-background-success-subtle: rgba(16, 185, 129, 0.1);
  --shadow-focus: 0 0 0 2px rgba(var(--color-primary-rgb), 0.2);
  --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
  --shadow-small: 0 1px 3px 0 rgba(0,0,0,0.1), 0 1px 2px 0 rgba(0,0,0,0.06);
  --shadow-medium: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06);
  --shadow-modal: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
  --shadow-card-hover: 0 4px 8px -2px rgba(0,0,0,0.1), 0 2px 4px -2px rgba(0,0,0,0.06);
}

/* 2. Basic Body and HTML Styles */
html {
  box-sizing: border-box;
  font-size: 16px;
}

*, *:before, *:after {
  box-sizing: inherit;
}

body {
  margin: 0;
  padding: 0;
  font-family: var(--font-family-main);
  background-color: var(--background-color);
  color: var(--text-color);
  line-height: 1.5;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

/* 3. Basic Typography */
h1, h2, h3, h4, h5, h6 {
  margin-top: 0;
  margin-bottom: calc(var(--spacing-base) * 2);
  font-weight: 600;
}

h1 { font-size: 32px; font-weight: 700; }
h2 { font-size: 24px; }
h3 { font-size: 20px; }

p {
  margin-top: 0;
  margin-bottom: calc(var(--spacing-base) * 2);
}

a {
  color: var(--link-color);
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
  color: var(--link-hover-color);
}

/* 4. Basic Form Styling */
input[type="text"],
input[type="email"],
input[type="password"],
textarea,
select {
  font-family: var(--font-family-main);
  padding: calc(var(--spacing-base) * 1.5);
  border: 1px solid var(--input-border-color);
  border-radius: var(--border-radius-medium);
  font-size: 16px;
  background-color: var(--input-background-color);
  color: var(--input-text-color);
  width: 100%;
  margin-bottom: calc(var(--spacing-base) * 2);
}

input[type="text"]:focus,
input[type="email"]:focus,
input[type="password"]:focus,
textarea:focus,
select:focus {
  outline: none;
  border-color: var(--primary-color);
  box-shadow: var(--shadow-focus);
}

input[type="text"]:disabled,
input[type="email"]:disabled,
input[type="password"]:disabled,
textarea:disabled,
select:disabled {
  background-color: var(--background-disabled-color);
  color: var(--text-disabled-color);
  border-color: var(--border-color);
  cursor: not-allowed;
  opacity: 0.7;
}

button {
  font-family: var(--font-family-main);
  padding: calc(var(--spacing-base) * 1.25) calc(var(--spacing-base) * 2.5);
  border: none;
  border-radius: var(--border-radius-medium);
  cursor: pointer;
  font-size: 16px;
  font-weight: 500;
  transition: background-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
}

button.primary {
  background-color: var(--button-background-color);
  color: var(--button-text-color);
}

button.primary:hover {
  background-color: var(--button-hover-background-color);
}

button.secondary {
  background-color: var(--button-secondary-background-color);
  color: var(--button-secondary-text-color);
  border: 1px solid var(--button-secondary-border-color);
}

button.secondary:hover {
  background-color: var(--button-secondary-hover-background-color);
}

button.danger {
  background-color: var(--danger-background-color);
  color: var(--button-text-color);
  border: 1px solid var(--danger-border-color);
}
button.danger:hover {
  background-color: var(--color-error-dark);
  border-color: var(--color-error-dark);
}
button.danger:focus {
  box-shadow: 0 0 0 2px rgba(239, 68, 68, 0.3);
}

button:disabled,
button.primary:disabled,
button.secondary:disabled,
button.danger:disabled {
  background-color: var(--button-disabled-background-color);
  color: var(--button-disabled-text-color);
  border-color: var(--button-disabled-background-color);
  cursor: not-allowed;
  opacity: 0.7;
}

input.input-error,
textarea.input-error,
select.input-error {
  border-color: var(--danger-border-color);
  box-shadow: 0 0 0 2px rgba(239, 68, 68, 0.2);
}

input.input-error:focus,
textarea.input-error:focus,
select.input-error:focus {
  border-color: var(--danger-border-color);
  box-shadow: 0 0 0 2px rgba(239, 68, 68, 0.3);
}

/* Utility Classes */
.text-center { text-align: center; }
.mt-1 { margin-top: var(--spacing-base); }
.mb-1 { margin-bottom: var(--spacing-base); }

.text-caption {
  font-size: 14px;
  font-weight: 400;
  color: var(--text-secondary-color);
}

/* ### НОВЫЙ КЛАСС: Глобальный контейнер для страниц с формами ### */
.form-page-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  padding-top: 4rem;
  padding-bottom: 2rem;
  min-height: 80vh;
}

================================================
FILE: client/src/app/styles/theme.css
================================================
/* Light Theme Variables */
[data-theme='light'] {
  --background-color: #ffffff;
  --text-color: #000000;
  --primary-color: #007bff;
  --secondary-color: #6c757d;
  --border-color: #dee2e6;
  --link-color: #007bff;
  --button-background-color: #007bff;
  --button-text-color: #ffffff;
  --button-hover-background-color: #0056b3;
  --header-background-color: #f8f9fa;
  --header-text-color: #000000;
  --card-background-color: #ffffff;
  --card-border-color: #e0e0e0;
  --modal-background-color: #ffffff;
  --modal-text-color: #000000;

  /* Extended Semantic Variables */
  --text-secondary-color: rgba(0, 0, 0, 0.7);
  --text-tertiary-color: rgba(0, 0, 0, 0.5);
  --text-placeholder-color: rgba(0, 0, 0, 0.4);
  --text-disabled-color: rgba(0, 0, 0, 0.3);
  --link-hover-color: #0056b3;

  --element-hover-background-color: rgba(0, 0, 0, 0.03);
  --background-subtle-color: #f8f9fa;
  --border-subtle-color: #e9ecef;
  --background-disabled-color: #e9ecef;

  --input-background-color: #ffffff;
  --input-border-color: #ced4da;
  --input-text-color: #495057;

  --danger-background-color: #dc3545;
  --danger-background-subtle-color: #f8d7da;
  --danger-text-color: #721c24;
  --danger-border-color: #f5c6cb;

  --success-background-color: #28a745;
  --success-background-subtle-color: #d4edda;
  --success-text-color: #155724;
  --success-border-color: #c3e6cb;

  --button-secondary-background-color: #6c757d;
  --button-secondary-text-color: #ffffff;
  --button-secondary-border-color: #6c757d;
  --button-secondary-hover-background-color: #5a6268;

  --button-disabled-background-color: #ced4da;
  --button-disabled-text-color: #6c757d;

  --tag-background-color: #e9ecef;
  --tag-text-color: #495057;

  --backdrop-color: rgba(0, 0, 0, 0.5);
  --shadow-element: 0 2px 4px rgba(0,0,0,0.1); /* Default shadow for light theme */
}

/* Dark Theme Variables */
[data-theme='dark'] {
  --background-color: #121212;
  --text-color: #e0e0e0;
  --primary-color: #bb86fc;
  --secondary-color: #03dac6; /* Accent color */
  --border-color: #333333;
  --link-color: #bb86fc;
  --button-background-color: #bb86fc; /* Primary button */
  --button-text-color: #000000;      /* Text on primary button */
  --button-hover-background-color: #9e47f5; /* Darken primary button on hover */
  --header-background-color: #1e1e1e;
  --header-text-color: #e0e0e0;
  --card-background-color: #1e1e1e;
  --card-border-color: #444444;
  --modal-background-color: #1e1e1e;
  --modal-text-color: #e0e0e0;
  --settings-page-h2-border-color: #555555; /* Specific for UserSettingsPage */

  /* Extended Semantic Variables */
  --text-secondary-color: rgba(224, 224, 224, 0.7);
  --text-tertiary-color: rgba(224, 224, 224, 0.5);
  --text-placeholder-color: rgba(224, 224, 224, 0.4);
  --text-disabled-color: rgba(224, 224, 224, 0.3);
  --link-hover-color: #d0a0ff;

  --element-hover-background-color: rgba(255, 255, 255, 0.08);
  --background-subtle-color: #2a2a2a;
  --border-subtle-color: #2c2c2c;
  --background-disabled-color: #2a2a2a;

  --input-background-color: #2c2c2c;
  --input-border-color: #555555;
  --input-text-color: #e0e0e0;

  --danger-background-color: #cf6679; /* Material Design Dark Theme Error Color */
  --danger-background-subtle-color: rgba(207, 102, 121, 0.2);
  --danger-text-color: #cf6679;
  --danger-border-color: #cf6679;

  --success-background-color: #03dac6; /* Using secondary as a stand-in for success accent */
  --success-background-subtle-color: rgba(3, 218, 198, 0.2);
  --success-text-color: #03dac6;
  --success-border-color: #03dac6;

  --button-secondary-background-color: #373737;
  --button-secondary-text-color: #e0e0e0;
  --button-secondary-border-color: #555555;
  --button-secondary-hover-background-color: #4f4f4f;

  --button-disabled-background-color: #2a2a2a;
  --button-disabled-text-color: #555555;

  --tag-background-color: #373737;
  --tag-text-color: #e0e0e0;

  --backdrop-color: rgba(0, 0, 0, 0.7);
  --shadow-element: 0 2px 4px rgba(0,0,0,0.4); /* Subtle shadow for dark theme */
}


================================================
FILE: client/src/features/AddTaskModal/AddTaskModal.module.css
================================================
/* client/src/features/AddTaskModal/ui/AddTaskModal.module.css */

.form {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.formGroup {
  display: flex;
  flex-direction: column;
}

.formGroup label {
  margin-bottom: 0.5rem;
  font-weight: 500;
  color: var(--text-secondary-color);
}

.formInput,
.formTextarea,
.formSelect {
  width: 100%;
  padding: 0.75rem;
  box-sizing: border-box;
  border: 1px solid var(--input-border-color);
  border-radius: var(--border-radius-medium);
  background-color: var(--input-background-color);
  color: var(--input-text-color);
  font-size: 1rem;
  font-family: var(--font-family-main);
}

.formTextarea {
  min-height: 100px;
  resize: vertical;
}

.formActions {
  display: flex;
  justify-content: flex-end;
  gap: 0.75rem;
  margin-top: 1rem;
  padding-top: 1rem;
  border-top: 1px solid var(--border-subtle-color);
}

.formErrorMessage {
  color: var(--danger-text-color);
  background-color: var(--danger-background-subtle-color);
  padding: 1rem;
  border-radius: var(--border-radius-medium);
  margin-bottom: 1rem;
}

================================================
FILE: client/src/features/AddTaskModal/index.ts
================================================
// client/src/features/AddTaskModal/index.ts
export { default as AddTaskModal } from './ui/AddTaskModal';

================================================
FILE: client/src/features/AddTaskModal/ui/AddTaskModal.tsx
================================================
// client/src/features/AddTaskModal/ui/AddTaskModal.tsx
import React, { useState, useEffect, useReducer } from 'react';
import { useAddTaskModal } from '../../../shared/contexts/AddTaskModalContext';
import { Modal } from '../../../shared/ui/Modal';
import { taskService } from '../../../shared/api/taskService';
import type { CreateTaskDto, ColumnDto } from '../../../shared/api/types';
// ### ИЗМЕНЕНИЕ: Исправлен путь к файлу стилей
import styles from '../AddTaskModal.module.css';

interface AddTaskModalProps {
  projectId: number;
  columns: ColumnDto[];
}

interface AddTaskFormState {
  title: string;
  description: string;
  dueDate: string;
  type: string;
  priority: string;
  tags: string;
  columnId: string | null;
}

type FormAction =
  | { type: 'SET_FIELD'; field: keyof AddTaskFormState; payload: string | null }
  | { type: 'RESET' };

const initialFormState: AddTaskFormState = {
  title: '',
  description: '',
  dueDate: '',
  type: '',
  priority: '',
  tags: '',
  columnId: null,
};

function formReducer(state: AddTaskFormState, action: FormAction): AddTaskFormState {
  switch (action.type) {
    case 'SET_FIELD':
      return { ...state, [action.field]: action.payload };
    case 'RESET':
      return { ...initialFormState, columnId: state.columnId }; // Keep selected column
    default:
      return state;
  }
}

const AddTaskModal: React.FC<AddTaskModalProps> = ({ projectId, columns }) => {
  const { isModalOpen, closeModal } = useAddTaskModal();
  const [formState, dispatch] = useReducer(formReducer, initialFormState);
  const [isCreating, setIsCreating] = useState(false);
  const [formError, setFormError] = useState<string | null>(null);
  
  useEffect(() => {
    // Set default column when modal opens if not already set
    if (isModalOpen && columns.length > 0 && !formState.columnId) {
      dispatch({ type: 'SET_FIELD', field: 'columnId', payload: columns[0].id });
    }
  }, [isModalOpen, columns, formState.columnId]);

  const handleClose = () => {
    dispatch({ type: 'RESET' });
    setFormError(null);
    closeModal();
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setFormError(null);
    if (!formState.title.trim() || !formState.columnId) {
      setFormError('Please ensure Title and Column are filled.');
      return;
    }
    setIsCreating(true);
    try {
      const tagsArray = formState.tags.split(',').map(tag => tag.trim()).filter(Boolean);
      const taskData: CreateTaskDto = {
        title: formState.title,
        description: formState.description || undefined,
        columnId: formState.columnId,
        dueDate: formState.dueDate || undefined,
        type: formState.type || undefined,
        priority: formState.priority || undefined,
        tags: tagsArray.length > 0 ? tagsArray : undefined,
      };
      await taskService.createTask(projectId, taskData);
      handleClose();
    } catch (err: any) {
      console.error('Failed to create task:', err);
      setFormError(err.response?.data?.message || 'Failed to create task.');
    } finally {
      setIsCreating(false);
    }
  };

  return (
    <Modal
      isOpen={isModalOpen}
      onClose={handleClose}
      title="Add New Task"
    >
      <form onSubmit={handleSubmit} className={styles.form}>
        {formError && <p className={styles.formErrorMessage}>{formError}</p>}
        
        <div className={styles.formGroup}>
          <label htmlFor="taskTitle">Task Title</label>
          <input id="taskTitle" type="text" value={formState.title} onChange={(e) => dispatch({ type: 'SET_FIELD', field: 'title', payload: e.target.value })} required />
        </div>
        <div className={styles.formGroup}>
          <label htmlFor="taskDescription">Description (Optional)</label>
          <textarea id="taskDescription" value={formState.description} onChange={(e) => dispatch({ type: 'SET_FIELD', field: 'description', payload: e.target.value })} />
        </div>
        <div className={styles.formGroup}>
          <label htmlFor="columnSelect">Status/Column</label>
          <select id="columnSelect" value={formState.columnId || ''} onChange={(e) => dispatch({ type: 'SET_FIELD', field: 'columnId', payload: e.target.value })} required>
            {columns.map(column => (<option key={column.id} value={column.id}>{column.name}</option>))}
          </select>
        </div>
        <div className={styles.formGroup}>
          <label htmlFor="taskDueDate">Deadline</label>
          <input id="taskDueDate" type="date" value={formState.dueDate} onChange={(e) => dispatch({ type: 'SET_FIELD', field: 'dueDate', payload: e.target.value })} />
        </div>
        <div className={styles.formGroup}>
          <label htmlFor="taskType">Type</label>
          <input id="taskType" type="text" value={formState.type} onChange={(e) => dispatch({ type: 'SET_FIELD', field: 'type', payload: e.target.value })} placeholder="e.g., Bug, Feature, Chore" />
        </div>
        <div className={styles.formGroup}>
          <label htmlFor="taskPriority">Priority</label>
          <input id="taskPriority" type="text" value={formState.priority} onChange={(e) => dispatch({ type: 'SET_FIELD', field: 'priority', payload: e.target.value })} placeholder="e.g., High, Medium, Low" />
        </div>
        <div className={styles.formGroup}>
          <label htmlFor="taskTags">Tags (comma-separated)</label>
          <input id="taskTags" type="text" value={formState.tags} onChange={(e) => dispatch({ type: 'SET_FIELD', field: 'tags', payload: e.target.value })} placeholder="e.g., UI, Backend, Urgent" />
        </div>
        <div className={styles.formActions}>
          <button type="button" onClick={handleClose} className="button secondary">Cancel</button>
          <button type="submit" disabled={isCreating || !formState.columnId} className="button primary">
            {isCreating ? 'Creating...' : 'Create Task'}
          </button>
        </div>
      </form>
    </Modal>
  );
};

export default AddTaskModal;

================================================
FILE: client/src/features/authByEmail/api/index.ts
================================================
import axiosInstance from '../../../shared/api/axiosInstance'; // Import the configured Axios instance
import axios from 'axios'; // Keep for isAxiosError if needed, or type directly

// Define the structure of the registration data
interface RegistrationData {
  name: string;
  email: string;
  password?: string; // Password might be optional if using OAuth, but required for email registration
}

// Define the structure of the successful API response (adjust as per your actual API)
interface RegistrationResponse {
  message?: string; // Make message optional as token is primary
  access_token: string; // Add access_token
  userId?: string; // Optional: Include if your API returns the new user's ID
  // Add other relevant fields from your API response
}

// Define the structure of an API error (adjust as per your actual API)
interface ApiError {
  message: string;
  errors?: Array<{ field: string; message: string }>; // Example for field-specific errors
}

// const API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:3001'; // Base URL is now in axiosInstance

export const registerUserApi = async (userData: RegistrationData): Promise<RegistrationResponse> => {
  try {
    // Use axiosInstance for the request. Base URL is already part of it.
    const response = await axiosInstance.post<RegistrationResponse>(`/auth/register`, userData, {
      // headers: { 'Content-Type': 'application/json' } // Default in axiosInstance if set, or can be overridden
    });
    return response.data;
  } catch (error) {
    // Error handling can remain similar, but AxiosError type might come from the global axios import
    if (axios.isAxiosError(error) && error.response) {
      // The request was made and the server responded with a status code
      // that falls out of the range of 2xx
      const apiError = error.response.data as ApiError;
      throw new Error(apiError.message || `Registration failed with status: ${error.response.status}`);
    } else if (axios.isAxiosError(error) && error.request) {
      // The request was made but no response was received
      throw new Error('Registration failed: No response from server. Please check your network connection.');
    } else {
      // Something happened in setting up the request that triggered an Error
      throw new Error(`Registration failed: ${error instanceof Error ? error.message : 'An unknown error occurred'}`);
    }
  }
};

// Define the structure of the login data
interface LoginData {
  email: string;
  password?: string;
}

// Define the structure of the successful login API response
interface LoginResponse {
  message: string;
  access_token: string; // Changed from token to access_token
  // Add other relevant fields from your API response, e.g., user details
}

export const loginUserApi = async (userData: LoginData): Promise<LoginResponse> => {
  try {
    // Use axiosInstance for the request
    const response = await axiosInstance.post<LoginResponse>(`/auth/login`, userData, {
      // headers: { 'Content-Type': 'application/json' }
    });
    return response.data;
  } catch (error) {
    if (axios.isAxiosError(error) && error.response) {
      const apiError = error.response.data as ApiError; // Reuse ApiError type for consistency
      throw new Error(apiError.message || `Login failed with status: ${error.response.status}`);
    } else if (axios.isAxiosError(error) && error.request) {
      throw new Error('Login failed: No response from server. Please check your network connection.');
    } else {
      throw new Error(`Login failed: ${error instanceof Error ? error.message : 'An unknown error occurred'}`);
    }
  }
};


================================================
FILE: client/src/features/authByEmail/ui/LoginForm.tsx
================================================
import React, { useState } from 'react';
import { useNavigate, Link } from 'react-router-dom';
import styles from './RegistrationForm.module.css'; // Assuming similar styling needs
import { loginUserApi } from '../api';
import { useAuth } from '../../../app/auth/AuthContext'; // Corrected path

const LoginForm = () => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const navigate = useNavigate();
  const { login } = useAuth(); // Get login function from context

  const handleSubmit = async (event: React.FormEvent) => {
    event.preventDefault();
    setError('');

    if (!email.trim() || !password.trim()) {
      setError('Both email and password are required.');
      return;
    }
    if (!/\S+@\S+\.\S+/.test(email)) {
      setError('Email is invalid. Please enter a valid email address.');
      return;
    }

    setIsLoading(true);
    try {
      const response = await loginUserApi({ email, password });
      if (response.access_token) { // Changed from response.token
        login(response.access_token); // Changed from response.token
        navigate('/'); // Redirect to home/dashboard
      } else {
        setError(response.message || 'Login failed: No token received.');
      }
    } catch (apiError: any) {
      setError(apiError.message || 'Login failed. Please check your credentials.');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className={styles.formContainer}>
      <form onSubmit={handleSubmit}>
        <h2>Login</h2>
        {error && <p className={styles.errorMessage}>{error}</p>}

        <div className={styles.formField}>
          <label htmlFor="login-email">Email:</label>
          <input
            type="email"
            id="login-email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            disabled={isLoading}
            className={error ? 'input-error' : ''}
          />
        </div>

        <div className={styles.formField}>
          <label htmlFor="login-password">Password:</label>
          <input
            type="password"
            id="login-password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            disabled={isLoading}
            className={error ? 'input-error' : ''}
          />
        </div>

        <button type="submit" className={`primary ${styles.submitButton}`} disabled={isLoading}>
          {isLoading ? 'Logging in...' : 'Login'}
        </button>
        <p className={styles.registrationLinkContainer}>
          Don't have an account? <Link to="/register">Register here.</Link>
        </p>
      </form>
    </div>
  );
};

export default LoginForm;


================================================
FILE: client/src/features/authByEmail/ui/LogoutButton.tsx
================================================
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../../../app/auth/AuthContext'; // Adjusted path

const LogoutButton = () => {
  const { logout, isAuthenticated } = useAuth();
  const navigate = useNavigate();

  const handleLogout = () => {
    logout();
    navigate('/'); // Redirect to the landing page after logout
  };

  if (!isAuthenticated) {
    return null; // Don't show logout button if not authenticated
  }

  return (
    <button onClick={handleLogout} className="secondary"> {/* Assuming a 'secondary' class for styling */}
      Logout
    </button>
  );
};

export default LogoutButton;


================================================
FILE: client/src/features/authByEmail/ui/RegistrationForm.module.css
================================================
.formContainer {
  max-width: calc(var(--spacing-base) * 50); /* 400px */
  margin: calc(var(--spacing-base) * 4) auto; /* 32px auto */
  padding: calc(var(--spacing-base) * 3); /* 24px */
  background-color: var(--card-background-color); /* Forms are often card-like */
  border-radius: var(--border-radius-large); /* 8px */
  box-shadow: var(--shadow-medium);
  color: var(--text-color); /* Default text color for form content */
}

.formContainer h2 {
  text-align: center;
  color: var(--text-color); /* Main text color for heading */
  margin-bottom: calc(var(--spacing-base) * 3); /* 24px */
}

.formField {
  margin-bottom: calc(var(--spacing-base) * 2); /* 16px */
}

.formField label {
  display: block;
  margin-bottom: var(--spacing-base); /* 8px */
  color: var(--text-secondary-color); /* Labels can use secondary text color */
  font-weight: 500;
}

/* Input fields will use global styles by default or can use --input-background-color etc. */
/* We can add specific overrides here if needed */

.submitButton {
  /* Use the global .primary button style by adding the class in JSX */
  /* This button should use var(--button-background-color) and var(--button-text-color) via global styles */
  width: 100%;
  padding: calc(var(--spacing-base) * 1.5); /* 12px - larger for a primary action */
  font-weight: 600;
}

.errorMessage {
  color: var(--danger-text-color);
  background-color: var(--danger-background-subtle-color);
  border: 1px solid var(--danger-border-color);
  padding: calc(var(--spacing-base) * 1.5); /* 12px */
  border-radius: var(--border-radius-medium);
  margin-bottom: calc(var(--spacing-base) * 2); /* 16px */
  text-align: center;
}

.successMessage {
  color: var(--success-text-color);
  background-color: var(--success-background-subtle-color);
  border: 1px solid var(--success-border-color);
  padding: calc(var(--spacing-base) * 1.5); /* 12px */
  border-radius: var(--border-radius-medium);
  margin-bottom: calc(var(--spacing-base) * 2); /* 16px */
  text-align: center;
}

.registrationLinkContainer {
  text-align: center;
  margin-top: calc(var(--spacing-base) * 2); /* 16px, was 1rem */
}
/* Links inside this container should use var(--link-color) */
.registrationLinkContainer a {
  color: var(--link-color);
  text-decoration: none;
}
.registrationLinkContainer a:hover {
  text-decoration: underline;
  color: var(--link-hover-color);
}


================================================
FILE: client/src/features/authByEmail/ui/RegistrationForm.tsx
================================================
import React, { useState } from 'react';
import styles from './RegistrationForm.module.css'; // Import CSS Modules
import { registerUserApi } from '../api'; // Import the API function
// import { useAuth } from '../../../app/auth/AuthContext'; // 'login' больше не используется, поэтому этот импорт не нужен
import { useNavigate, Link } from 'react-router-dom'; // Import useNavigate and Link

const RegistrationForm = () => {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const [successMessage, setSuccessMessage] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  // const { login } = useAuth(); // УДАЛЕНО: 'login' больше не используется
  const navigate = useNavigate();

  const handleSubmit = async (event: React.FormEvent) => {
    event.preventDefault();
    setError('');
    setSuccessMessage('');

    if (!name.trim() || !email.trim() || !password.trim()) {
      setError('All fields are required.');
      return;
    }
    if (!/\S+@\S+\.\S+/.test(email)) {
      setError('Email is invalid. Please enter a valid email address.');
      return;
    }
    if (password.length < 8) {
      setError('Password must be at least 8 characters long.');
      return;
    }

    setIsLoading(true);
    try {
      await registerUserApi({ name, email, password });
      setSuccessMessage('Registration successful! Please log in.');
      setName('');
      setEmail('');
      setPassword('');
      setTimeout(() => {
        navigate('/login');
      }, 2000);
    } catch (apiError: any) {
      setError(apiError.message || 'Registration failed. Please try again.');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className={styles.formContainer}>
      <form onSubmit={handleSubmit}>
        <h2>Register</h2>
        {error && <p className={styles.errorMessage}>{error}</p>}
        {successMessage && <p className={styles.successMessage}>{successMessage}</p>}

        <div className={styles.formField}>
          <label htmlFor="name">Name:</label>
          <input
            type="text"
            id="name"
            value={name}
            onChange={(e) => setName(e.target.value)}
            disabled={isLoading}
            className={error ? 'input-error' : ''}
          />
        </div>

        <div className={styles.formField}>
          <label htmlFor="email">Email:</label>
          <input
            type="email"
            id="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            disabled={isLoading}
            className={error ? 'input-error' : ''}
          />
        </div>

        <div className={styles.formField}>
          <label htmlFor="password">Password:</label>
          <input
            type="password"
            id="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            disabled={isLoading}
            className={error ? 'input-error' : ''}
          />
        </div>

        <button type="submit" className={`primary ${styles.submitButton}`} disabled={isLoading}>
          {isLoading ? 'Registering...' : 'Register'}
        </button>
        <p className={styles.registrationLinkContainer}>Already have an account? <Link to="/login">Login here.</Link></p>
      </form>
    </div>
  );
};

export default RegistrationForm;

================================================
FILE: client/src/features/ColumnLane/ColumnLane.module.css
================================================
.columnLane {
  padding: 8px;
  min-width: 300px;
  max-width: 300px;
  height: calc(100vh - 150px); /* Example height, adjust as needed */
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  background-color: var(--card-background-color);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius-medium); /* Added for consistency */
  color: var(--text-color);
}

.columnLane.isOver {
  border: 2px dashed var(--primary-color);
  /* Optional: Slightly change background when item is dragged over */
  /* background-color: var(--element-hover-background-color); */
}

.columnTitle {
  text-align: center;
  margin-bottom: 10px;
  color: var(--text-color); /* Ensure title uses theme text color */
}

.noTasksText {
  font-size: 0.9em;
  color: var(--text-secondary-color); /* Use secondary text color for less emphasis */
  text-align: center;
  margin-top: 20px;
}

.addTaskButton {
  margin-top: auto; /* Push to bottom */
  width: 100%; /* Make button full width of column */
  /* Assuming global button styles or specific button component will handle theming */
}


================================================
FILE: client/src/features/ColumnLane/ColumnLane.tsx
================================================
import React from 'react';
import { SortableContext, verticalListSortingStrategy } from '@dnd-kit/sortable';
import { useDroppable } from '@dnd-kit/core';
import TaskCard from '../TaskCard/TaskCard'; // Adjust path
import type { ColumnDto as ProjectColumnDto, TaskDto } from '../../shared/api/projectService'; // Use TaskDto directly
import styles from './ColumnLane.module.css'; // Import CSS module

interface Column extends ProjectColumnDto {
  tasksList: TaskDto[]; // Use TaskDto
}

interface ColumnLaneProps {
  column: Column;
  onTaskClick: (task: TaskDto) => void; // New prop for task click
}

const ColumnLane: React.FC<ColumnLaneProps> = ({ column, onTaskClick }) => {
  const { setNodeRef, isOver } = useDroppable({ id: column.id });

  // Base class for the column lane, conditionally add 'isOver' class
  const columnClasses = isOver ? `${styles.columnLane} ${styles.isOver}` : styles.columnLane;

  const tasksContainerStyle = { // Kept inline as it's simple and layout-specific
    flexGrow: 1,
    minHeight: '50px',
  };

  return (
    <div ref={setNodeRef} className={columnClasses}>
      <h2 className={styles.columnTitle}>{column.name}</h2>
      <div style={tasksContainerStyle}>
        <SortableContext items={column.tasksList.map(task => task.id)} strategy={verticalListSortingStrategy}>
          {column.tasksList.length === 0 ? (
            <p className={styles.noTasksText}>No tasks here.</p>
          ) : (
            column.tasksList.map(task => <TaskCard key={task.id} task={task} onTaskClick={onTaskClick} />)
          )}
        </SortableContext>
      </div>
    </div>
  );
};
export default ColumnLane;


================================================
FILE: client/src/features/Comments/api.ts
================================================
// client/src/features/Comments/api.ts
// ### ИЗМЕНЕНИЕ: Убран неиспользуемый импорт projectService и добавлен нужный taskService ###
import { taskService } from '../../shared/api/taskService';
import type { CreateCommentPayloadDto, CommentDto } from '../../shared/api/types';

export const getTaskComments = (taskId: string): Promise<CommentDto[]> => {
  return taskService.getTaskComments(taskId);
};

export const addTaskComment = (taskId: string, data: CreateCommentPayloadDto): Promise<CommentDto> => {
  return taskService.addTaskComment(taskId, data);
};

================================================
FILE: client/src/features/Comments/index.ts
================================================
// client/src/features/Comments/index.ts
export { default as CommentList } from './ui/CommentList';
export { default as AddCommentForm } from './ui/AddCommentForm';


================================================
FILE: client/src/features/Comments/ui/AddCommentForm.module.css
================================================
/* client/src/features/Comments/ui/AddCommentForm.module.css */
.addCommentForm {
  margin-top: calc(var(--spacing-base) * 2); /* 16px */
}
.addCommentForm textarea {
  width: calc(100% - 22px); /* Full width minus padding/border */
  min-height: calc(var(--spacing-base) * 8); /* 64px */
  padding: calc(var(--spacing-base) * 1.5); /* 12px */
  border: 1px solid var(--input-border-color);
  border-radius: var(--border-radius-medium); /* Use variable */
  margin-bottom: calc(var(--spacing-base) * 2); /* 16px */
  background-color: var(--input-background-color);
  color: var(--input-text-color);
}
/* Default focus style is now handled by global.css */
/* Button styling is now handled by global .primary, .secondary, .danger classes */
.errorText {
  color: var(--danger-text-color);
  font-size: 14px; /* Was 0.9em, consistent with caption size */
  margin-top: calc(var(--spacing-base) / 2); /* 4px */
}


================================================
FILE: client/src/features/Comments/ui/AddCommentForm.tsx
================================================
// client/src/features/Comments/ui/AddCommentForm.tsx
import React, { useState } from 'react';
import { addTaskComment } from '../api';
// ### ИЗМЕНЕНИЕ: Импортируем типы из правильного места ###
import type { CommentDto, CreateCommentPayloadDto } from '../../../shared/api/types';
import styles from './AddCommentForm.module.css';

interface AddCommentFormProps {
  taskId: string;
  onCommentAdded: (newComment: CommentDto) => void;
}

const AddCommentForm: React.FC<AddCommentFormProps> = ({ taskId, onCommentAdded }) => {
  const [text, setText] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!text.trim()) {
      setError('Comment cannot be empty.');
      return;
    }
    setIsSubmitting(true);
    setError(null);
    try {
      const payload: CreateCommentPayloadDto = { text };
      const newComment = await addTaskComment(taskId, payload);
      onCommentAdded(newComment);
      setText(''); // Clear textarea
    } catch (err) {
      console.error('Failed to add comment:', err);
      setError('Failed to post comment. Please try again.');
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <form onSubmit={handleSubmit} className={styles.addCommentForm}>
      <textarea
        value={text}
        onChange={(e) => setText(e.target.value)}
        placeholder="Add a comment..."
        rows={3}
        disabled={isSubmitting}
        className={error ? 'input-error' : ''}
      />
      {error && <p className={styles.errorText}>{error}</p>}
      <button type="submit" disabled={isSubmitting}>
        {isSubmitting ? 'Submitting...' : 'Add Comment'}
      </button>
    </form>
  );
};
export default AddCommentForm;

================================================
FILE: client/src/features/Comments/ui/CommentItem.module.css
================================================
/* client/src/features/Comments/ui/CommentItem.module.css */
.commentItem {
  padding: var(--spacing-base) 0;
  border-bottom: 1px solid var(--border-subtle-color);
}
.commentItem:last-child {
  border-bottom: none;
}
.commentAuthor {
  font-weight: bold;
  color: var(--text-color);
  margin-bottom: calc(var(--spacing-base) / 2); /* 4px */
}
.commentText {
  font-size: 0.95em;
  color: var(--text-secondary-color);
  white-space: pre-wrap; /* Preserve line breaks */
}
.commentTimestamp {
  font-size: 0.8em;
  color: var(--text-tertiary-color);
  margin-top: calc(var(--spacing-base) / 2); /* 4px */
}


================================================
FILE: client/src/features/Comments/ui/CommentItem.tsx
================================================
// client/src/features/Comments/ui/CommentItem.tsx
import React from 'react';
// ### ИЗМЕНЕНИЕ: Импортируем типы из правильного места ###
import type { CommentDto } from '../../../shared/api/types';
import styles from './CommentItem.module.css';

interface CommentItemProps {
  comment: CommentDto;
}

const CommentItem: React.FC<CommentItemProps> = ({ comment }) => {
  return (
    <div className={styles.commentItem}>
      <div className={styles.commentAuthor}>
        {comment.author?.name || comment.author?.email || 'Anonymous'}
      </div>
      <p className={styles.commentText}>{comment.text}</p>
      <div className={styles.commentTimestamp}>
        {comment.createdAt.toLocaleString()}
      </div>
    </div>
  );
};
export default CommentItem;

================================================
FILE: client/src/features/Comments/ui/CommentList.module.css
================================================
/* client/src/features/Comments/ui/CommentList.module.css */
.commentList {
  list-style: none;
  padding: 0;
  margin-top: 10px;
}


================================================
FILE: client/src/features/Comments/ui/CommentList.tsx
================================================
// client/src/features/Comments/ui/CommentList.tsx
import React from 'react';
// ### ИЗМЕНЕНИЕ: Импортируем типы из правильного места ###
import type { CommentDto } from '../../../shared/api/types';
import CommentItem from './CommentItem';
import styles from './CommentList.module.css';

interface CommentListProps {
  comments: CommentDto[];
}

const CommentList: React.FC<CommentListProps> = ({ comments }) => {
  if (comments.length === 0) {
    return <p>No comments yet.</p>;
  }
  return (
    <div className={styles.commentList}>
      {comments.map(comment => (
        <CommentItem key={comment.id} comment={comment} />
      ))}
    </div>
  );
};
export default CommentList;

================================================
FILE: client/src/features/Notifications/api.ts
================================================
// client/src/features/Notifications/api.ts
import { notificationService } from '../../shared/api/notificationService';
import type { NotificationDto } from '../../shared/api/notificationService';

export const getUserNotifications = (): Promise<NotificationDto[]> => {
  return notificationService.getUserNotifications();
};

export const markNotificationAsRead = (notificationId: string): Promise<NotificationDto> => {
  return notificationService.markNotificationAsRead(notificationId);
};

export const markAllNotificationsAsRead = (): Promise<{ message: string }> => {
  return notificationService.markAllNotificationsAsRead();
};


================================================
FILE: client/src/features/Notifications/index.ts
================================================
// client/src/features/Notifications/index.ts
export { default as NotificationBell } from './ui/NotificationBell';


================================================
FILE: client/src/features/Notifications/ui/NotificationBell.module.css
================================================
/* client/src/features/Notifications/ui/NotificationBell.module.css */
.bellContainer {
  position: relative;
  cursor: pointer;
  padding: var(--spacing-base); /* For easier clicking */
}
.bellIcon { /* Basic representation, replace with actual SVG or font icon */
  font-size: 1.5em; /* Example size */
  color: var(--text-color); /* Default icon color */
}
.unreadBadge {
  position: absolute;
  top: 0px;
  right: 0px;
  background-color: var(--danger-background-color);
  color: var(--button-text-color); /* High contrast text for badge */
  border-radius: 50%;
  padding: 2px calc(var(--spacing-base) / 2); /* 2px 4px */
  font-size: 0.7em;
  font-weight: bold;
  min-width: 10px; /* Ensure it's circular even for single digit */
  text-align: center;
  line-height: 1;
}


================================================
FILE: client/src/features/Notifications/ui/NotificationBell.tsx
================================================
// client/src/features/Notifications/ui/NotificationBell.tsx
import React, { useState, useEffect, useCallback } from 'react';
import { useNavigate } from 'react-router-dom';
import { getUserNotifications, markNotificationAsRead, markAllNotificationsAsRead } from '../api';
import type { NotificationDto } from '../../../shared/api/notificationService';
import NotificationDropdown from './NotificationDropdown';
import { socket } from '../../../shared/lib/socket';
import { joinUserRoom } from '../../../shared/lib/socket';
import styles from './NotificationBell.module.css';
import { useAuth } from '../../../app/auth/AuthContext'; // Import useAuth hook

const NotificationBell: React.FC = () => {
  const [notifications, setNotifications] = useState<NotificationDto[]>([]);
  const [isDropdownOpen, setIsDropdownOpen] = useState(false);
  
  const auth = useAuth();
  const navigate = useNavigate();

  const unreadCount = notifications.filter(n => !n.isRead).length;

  const fetchNotifications = useCallback(async () => {
    try {
      const fetchedNotifications = await getUserNotifications();
      setNotifications(fetchedNotifications.sort((a,b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()));
    } catch (err) {
      console.error('Failed to fetch notifications:', err);
    }
  }, []);

  useEffect(() => {
    if (auth?.user?.id) {
      fetchNotifications();
      if (!socket.connected) socket.connect();

      const onSocketConnect = () => {
        if (auth.user) {
          console.log('Socket connected for notifications, joining user room:', auth.user.id);
          joinUserRoom(auth.user.id);
        }
      };

      socket.on('connect', onSocketConnect);
      if(socket.connected) onSocketConnect();

      const handleNewNotification = (newNotification: NotificationDto) => {
        console.log('notification:new event received', newNotification);
        setNotifications(prev =>
          [newNotification, ...prev].sort((a,b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())
        );
      };
      
      // ### НОВОЕ: Обработчик события прочтения уведомления ###
      const handleReadNotification = (readNotification: NotificationDto) => {
        console.log('notification:read event received', readNotification);
        setNotifications(prev => 
          prev.map(n => n.id === readNotification.id ? { ...n, isRead: true } : n)
        );
      };

      socket.on('notification:new', handleNewNotification);
      socket.on('notification:read', handleReadNotification); // ### НОВОЕ: Подписываемся на событие

      return () => {
        socket.off('connect', onSocketConnect);
        socket.off('notification:new', handleNewNotification);
        socket.off('notification:read', handleReadNotification); // ### НОВОЕ: Отписываемся от события
      };
    } else if (auth?.isAuthenticated) {
        console.warn("User is authenticated, but user ID is not available in AuthContext for NotificationBell.");
    }
  }, [auth?.user?.id, auth?.isAuthenticated, fetchNotifications]);

  const handleNotificationClick = async (notification: NotificationDto) => {
    if (notification.sourceUrl) {
      navigate(notification.sourceUrl);
    }
    if (!notification.isRead) {
      try {
        await markNotificationAsRead(notification.id);
        // Состояние обновится автоматически через WebSocket событие 'notification:read'
      } catch (err) {
        console.error('Failed to mark notification as read:', err);
      }
    }
    setIsDropdownOpen(false);
  };

  const handleMarkAllRead = async () => {
    try {
      await markAllNotificationsAsRead();
      // Состояние обновится автоматически через WebSocket события
    } catch (err) {
      console.error('Failed to mark all notifications as read:', err);
    }
  };

  if (!auth?.user?.id) {
      return null;
  }

  return (
    <div className={styles.bellContainer}>
      <span className={styles.bellIcon} onClick={() => setIsDropdownOpen(prev => !prev)}>
        🔔
        {unreadCount > 0 && <span className={styles.unreadBadge}>{unreadCount}</span>}
      </span>
      {isDropdownOpen && (
        <NotificationDropdown
          notifications={notifications}
          onNotificationClick={handleNotificationClick}
          onMarkAllRead={handleMarkAllRead}
          unreadCount={unreadCount}
        />
      )}
    </div>
  );
};
export default NotificationBell;

================================================
FILE: client/src/features/Notifications/ui/NotificationDropdown.module.css
================================================
/* client/src/features/Notifications/ui/NotificationDropdown.module.css */
.dropdown {
  position: absolute;
  top: calc(var(--spacing-base) * 6); /* 48px, was 50px */
  right: 0;
  width: calc(var(--spacing-base) * 44); /* 352px, was 350px */
  max-height: calc(var(--spacing-base) * 50); /* 400px */
  overflow-y: auto;
  background-color: var(--card-background-color); /* Dropdowns are card-like elements */
  border: 1px solid var(--card-border-color);
  border-radius: var(--border-radius-small); /* 4px */
  box-shadow: var(--shadow-medium);
  z-index: 1100; /* Higher than other elements */
  color: var(--text-color); /* Ensure default text color for dropdown content */
}
.dropdownHeader {
  padding: calc(var(--spacing-base) * 1.5); /* 12px, was 10px */
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-bottom: 1px solid var(--border-subtle-color); /* Use subtle border for internal divisions */
}
.dropdownHeader h4 { margin: 0; }
.markAllButton {
  font-size: 0.8em;
  padding: calc(var(--spacing-base) / 2) var(--spacing-base); /* 4px 8px */
  /* cursor: pointer; moved to global button style */
  /* Assuming this will be a button styled with global classes like .button .secondary */
}
.noNotifications {
  padding: calc(var(--spacing-base) * 2.5); /* 20px */
  text-align: center;
  color: var(--text-secondary-color);
}


================================================
FILE: client/src/features/Notifications/ui/NotificationDropdown.tsx
================================================
// client/src/features/Notifications/ui/NotificationDropdown.tsx
import React from 'react';
import type { NotificationDto } from '../../../shared/api/notificationService';
import NotificationItem from './NotificationItem';
import styles from './NotificationDropdown.module.css';

interface NotificationDropdownProps {
  notifications: NotificationDto[];
  onNotificationClick: (notification: NotificationDto) => void;
  onMarkAllRead: () => void;
  unreadCount: number; // To decide if "Mark all read" should be enabled/shown
}

const NotificationDropdown: React.FC<NotificationDropdownProps> = ({ notifications, onNotificationClick, onMarkAllRead, unreadCount }) => {
  return (
    <div className={styles.dropdown}>
      <div className={styles.dropdownHeader}>
        <h4>Notifications</h4>
        {unreadCount > 0 && (
          <button onClick={onMarkAllRead} className={styles.markAllButton}>
            Mark all as read
          </button>
        )}
      </div>
      {notifications.length === 0 ? (
        <p className={styles.noNotifications}>No notifications yet.</p>
      ) : (
        notifications.map(notif => (
          <NotificationItem key={notif.id} notification={notif} onNotificationClick={onNotificationClick} />
        ))
      )}
    </div>
  );
};
export default NotificationDropdown;


================================================
FILE: client/src/features/Notifications/ui/NotificationItem.module.css
================================================
/* client/src/features/Notifications/ui/NotificationItem.module.css */
.notificationItem {
  padding: calc(var(--spacing-base) * 1.5); /* 12px, was 10px */
  border-bottom: 1px solid var(--border-subtle-color);
  cursor: pointer;
  background-color: transparent; /* Inherit from dropdown, or use card-background-color if items are distinct */
}
.notificationItem:last-child {
  border-bottom: none;
}
.notificationItem.unread {
  background-color: var(--background-subtle-color); /* Slightly different background for unread */
  font-weight: bold; /* Keep bold for unread emphasis */
}
.notificationItem:hover {
  background-color: var(--element-hover-background-color);
}
.notificationText {
  font-size: 14px; /* Was 0.9em, consistent with caption size */
  color: var(--text-color); /* Main text color for notification content */
  margin-bottom: calc(var(--spacing-base) / 2); /* 4px */
}
.notificationTimestamp {
  font-size: 0.75em;
  color: var(--text-secondary-color);
}


================================================
FILE: client/src/features/Notifications/ui/NotificationItem.tsx
================================================
// client/src/features/Notifications/ui/NotificationItem.tsx
import React from 'react';
import type { NotificationDto } from '../../../shared/api/notificationService';
import styles from './NotificationItem.module.css';

interface NotificationItemProps {
  notification: NotificationDto;
  onNotificationClick: (notification: NotificationDto) => void;
}

const NotificationItem: React.FC<NotificationItemProps> = ({ notification, onNotificationClick }) => {
  return (
    <div
      className={`${styles.notificationItem} ${!notification.isRead ? styles.unread : ''}`}
      onClick={() => onNotificationClick(notification)}
    >
      <div className={styles.notificationText}>{notification.text}</div>
      <div className={styles.notificationTimestamp}>
        {new Date(notification.createdAt).toLocaleString()}
      </div>
    </div>
  );
};
export default NotificationItem;


================================================
FILE: client/src/features/TaskCard/TaskCard.module.css
================================================
.taskCard {
  background-color: var(--card-background-color);
  border: 1px solid var(--card-border-color);
  border-radius: var(--border-radius-large); /* 8px */
  padding: var(--spacing-base); /* 8px */
  transition: all 0.2s ease-out;
  margin-bottom: var(--spacing-base); /* Add some margin between cards */
  cursor: grab; /* Indicate draggable */
  color: var(--text-color); /* Ensure default text color is applied */
}

.taskCard:hover {
  box-shadow: var(--shadow-card-hover);
  transform: translateY(-2px);
  /* Consider adding a subtle background change on hover if desired */
  /* background-color: var(--element-hover-background-color); */
}

.taskCardDragging {
  opacity: 0.8;
  transform: rotate(3deg); /* Example dragging style */
  box-shadow: var(--shadow-modal); /* More prominent shadow when dragging */
}

.taskTitle {
  font-size: 1rem; /* 16px */
  font-weight: 600;
  margin-bottom: calc(var(--spacing-base) / 2); /* 4px */
  color: var(--text-color); /* Explicitly use main text color for titles */
}

.taskDescription {
  font-size: 0.875rem; /* 14px */
  color: var(--text-secondary-color);
  margin-bottom: var(--spacing-base); /* 8px */
  /* Hide long descriptions, show more in modal */
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.taskMeta {
  font-size: 0.75rem; /* 12px */
  color: var(--text-tertiary-color);
}


================================================
FILE: client/src/features/TaskCard/TaskCard.tsx
================================================
import React from 'react';
import { useSortable } from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';
import type { TaskDto } from '../../shared/api/projectService'; // CORRECTED PATH
import styles from './TaskCard.module.css';

interface TaskCardProps {
  task: TaskDto;
  onTaskClick: (task: TaskDto) => void;
}

const TaskCard: React.FC<TaskCardProps> = ({ task, onTaskClick }) => {
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging,
  } = useSortable({ id: task.id });

  const dndKitStyles = {
    transform: CSS.Transform.toString(transform),
    transition,
  };

  const cardClasses = `${styles.taskCard} ${isDragging ? styles.taskCardDragging : ''}`;

  return (
    <div
      ref={setNodeRef}
      style={dndKitStyles}
      className={cardClasses}
      {...attributes}
      {...listeners}
      onClick={() => onTaskClick(task)}
    >
      <div className={styles.taskTitle}>
        {`${task.human_readable_id ? `${task.human_readable_id}: ` : ''}${task.title}`}
      </div>
      {task.description && (
        <div className={styles.taskDescription}>
          {task.description}
        </div>
      )}
      <div className={styles.taskMeta}>
        {task.priority && (
          <span className={`${styles.metaItem} ${styles.priority} ${styles['priority' + task.priority.charAt(0).toUpperCase() + task.priority.slice(1)]}`}>
            Priority: {task.priority}
          </span>
        )}
        {task.due_date && (
          <span className={styles.metaItem}>
            Due: {new Date(task.due_date).toLocaleDateString('en-US', { month: 'short', day: 'numeric', timeZone: 'UTC' })}
          </span>
        )}
      </div>
      {task.tags && task.tags.length > 0 && (
        <div className={styles.tagsContainer}>
          {task.tags.slice(0, 3).map((tag: string) => (
            <span key={tag} className={styles.tag}>{tag}</span>
          ))}
          {task.tags.length > 3 && (
            <span className={styles.tagMore}>+{task.tags.length - 3} more</span>
          )}
        </div>
      )}
    </div>
  );
};
export default TaskCard;

================================================
FILE: client/src/features/TaskDetailModal/index.ts
================================================
// client/src/features/TaskDetailModal/index.ts
export { default as TaskDetailModal } from './ui/TaskDetailModal';


================================================
FILE: client/src/features/TaskDetailModal/ui/EditableField.tsx
================================================
import React from 'react';
import styles from './TaskDetailModal.module.css';

export interface EditableFieldProps {
  label?: string;
  value: string | undefined | null | string[];
  editableValue: string;
  isEditing: boolean;
  isUpdating: boolean;
  error: string | null;
  onEdit: () => void;
  onCancel: () => void;
  onSave: () => Promise<void>;
  onChange: (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => void;
  inputType?: 'text' | 'textarea' | 'date';
  inputPlaceholder?: string;
  viewModeClassName?: string;
  editModeClassName?: string;
  labelClassName?: string;
  valueDisplayFormatter?: (val: string | undefined | null | string[]) => React.ReactNode;
  children?: React.ReactNode; // For custom content in view mode (e.g., tags map), takes precedence over value/valueDisplayFormatter

  // Class for the span that directly wraps the displayed value text/formatted value in view mode
  valueTextClassName?: string;
  // Class for the container of (value + edit button) in view mode
  valueAreaClassName?: string;
  editButtonClassName?: string;
  inputSpecificClassName?: string;
  controlsClassName?: string; // For the div wrapping save/cancel buttons
}

const EditableField: React.FC<EditableFieldProps> = ({
  label,
  value,
  editableValue,
  isEditing,
  isUpdating,
  error,
  onEdit,
  onCancel,
  onSave,
  onChange,
  inputType = 'text',
  inputPlaceholder,
  viewModeClassName = '',    // Applied to the root div in view mode
  editModeClassName = '',    // Applied to the root div in edit mode
  labelClassName = '',       // Applied to the label (strong tag)
  valueDisplayFormatter,
  children,
  valueTextClassName = '',   // Applied to the span wrapping the value text
  valueAreaClassName = '',   // Applied to the div wrapping (value text + edit button)
  editButtonClassName = '',  // Applied to the edit button
  inputSpecificClassName = '', // Applied to the input/textarea element
  controlsClassName = '',    // Applied to the div wrapping save/cancel buttons
}) => {

  const renderValueInViewMode = () => {
    if (children) {
      return children; // Children take precedence for custom view rendering
    }
    const displayedValue = valueDisplayFormatter ? valueDisplayFormatter(value) : (Array.isArray(value) ? value.join(', ') : (value || 'Not set'));
    return <span className={`${valueTextClassName} ${styles.editableFieldValueText}`}>{displayedValue}</span>;
  };

  if (!isEditing) {
    return (
      <div className={`${viewModeClassName}`}>
        {label && <strong className={`${labelClassName} ${styles.editableFieldLabel}`}>{label}</strong>}
        <div className={`${valueAreaClassName || styles.defaultValueArea}`}>
          {renderValueInViewMode()}
          <button
            onClick={onEdit}
            className={`${styles.button} ${styles.buttonLink} ${styles.editIcon} ${editButtonClassName}`}
          >
            Edit
          </button>
        </div>
      </div>
    );
  }

  // Edit Mode
  return (
    <div className={`${editModeClassName}`}>
      {/* Label can be optionally displayed in edit mode too, if structure requires it, handled by parent if needed */}
      {label && <strong className={`${labelClassName} ${styles.editableFieldLabel}`}>{label}</strong>}
      {inputType === 'textarea' ? (
        <textarea
          value={editableValue}
          onChange={onChange}
          placeholder={inputPlaceholder}
          className={`${inputSpecificClassName || styles.formTextareaFull}`}
          disabled={isUpdating}
        />
      ) : (
        <input
          type={inputType}
          value={editableValue}
          onChange={onChange}
          placeholder={inputPlaceholder}
          className={`${inputSpecificClassName || (inputType === 'date' ? styles.formInput : styles.formInputFull)}`}
          disabled={isUpdating}
        />
      )}
      <div className={`${controlsClassName || styles.inlineEditSectionControls}`}>
        <button
          onClick={onSave}
          className={`${styles.button} ${styles.buttonSmall} ${styles.buttonPrimary}`}
          disabled={isUpdating}
        >
          {isUpdating ? 'Saving...' : 'Save'}
        </button>
        <button
          onClick={onCancel}
          className={`${styles.button} ${styles.buttonSmall} ${styles.buttonSecondary}`}
          disabled={isUpdating}
        >
          Cancel
        </button>
      </div>
      {error && <p className={styles.errorTextSmall}>{error}</p>}
    </div>
  );
};

export default EditableField;


================================================
FILE: client/src/features/TaskDetailModal/ui/TaskDetailModal.module.css
================================================
/* client/src/features/TaskDetailModal/ui/TaskDetailModal.module.css */
.modalOverlay {
  position: fixed; top: 0; left: 0; right: 0; bottom: 0;
  background-color: var(--backdrop-color);
  display: flex; justify-content: center; align-items: center;
  z-index: 1050;
}
.modalContent {
  background-color: var(--modal-background-color);
  color: var(--modal-text-color); /* Default text color for modal content */
  padding: calc(var(--spacing-base) * 3);
  border-radius: var(--border-radius-large);
  min-width: calc(var(--spacing-base) * 63); /* 504px */
  max-width: calc(var(--spacing-base) * 90); /* 720px, increased max-width */
  max-height: 85vh; /* Increased max-height */
  box-shadow: var(--shadow-modal);
  display: flex;
  flex-direction: column;
  overflow-y: auto; /* Allow modal content itself to scroll if needed */
}
.taskDetails {
  /* Removed fixed margin-bottom, sections will handle their own */
}
.taskDetails h2 {
  margin-top: 0;
  color: var(--modal-text-color); /* Ensure h2 uses modal text color */
}
/* .taskDetails p { white-space: pre-wrap; } Defined in .description specific styles */

.commentsSection {
  border-top: 1px solid var(--border-subtle-color); /* Use subtle border */
  padding-top: calc(var(--spacing-base) * 2);
  margin-top: calc(var(--spacing-base) * 2); /* Added margin-top for separation */
  overflow-y: auto;
  flex-shrink: 0; /* Prevent comments section from shrinking excessively */
}

/* Edit Icon Styling */
.editIcon {
  background: none;
  border: none;
  color: var(--link-color);
  cursor: pointer;
  margin-left: var(--spacing-base-small); /* Reduced margin for "Edit" */
  font-size: 0.85em; /* Slightly smaller */
  padding: var(--spacing-base-small) 0; /* Add some vertical padding for easier clicking */
  vertical-align: middle; /* Align with text better */
  line-height: 1; /* Prevent extra line height issues */
}
.editIcon:hover {
  text-decoration: underline;
  color: var(--link-hover-color);
}

/* Shared styles for sections within taskDetails */
.taskDetailsSection {
  margin-bottom: calc(var(--spacing-base) * 1.5); /* Consistent bottom margin for sections */
}

.taskHeader {
  composes: taskDetailsSection;
}
.taskHeader h2 {
  flex-grow: 1;
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 1.8em;
  color: var(--modal-text-color); /* Ensure this h2 also uses modal text color */
}
.taskHeader h2 .inlineEditSection { /* Specifically for title's edit mode form */
  flex-grow: 1; /* Allow the form to take space */
  margin-left: var(--spacing-base-small); /* Space after "Task ID:" span */
}


.description {
  composes: taskDetailsSection;
  line-height: 1.6;
  color: var(--modal-text-color); /* Description text */
}
.descriptionView {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  width: 100%;
}
.descriptionText {
  flex-grow: 1;
  white-space: pre-wrap;
}


.metaGrid {
  composes: taskDetailsSection;
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(230px, 1fr));
  gap: calc(var(--spacing-base) * 1.5);
}
.metaGridItem { /* Root class for an EditableField in the meta grid (view or edit) */
  display: flex;
  flex-direction: column;
  gap: var(--spacing-base-small);
}
.metaGridItemLabel {
  font-weight: var(--font-weight-bold);
  color: var(--text-secondary-color); /* Use themed secondary text color */
  font-size: 0.9em;
}
.metaGridItemValueArea { /* Container for (value + edit button) in view mode for meta items */
  display: flex;
  align-items: center;
  justify-content: space-between; /* Push edit button to the right */
  flex-wrap: wrap;
  gap: var(--spacing-base-small);
  width: 100%;
}
.metaGridItemValueText { /* Class for the actual text value span itself */
  flex-grow: 1; /* Allow text to take available space */
  word-break: break-word; /* Break long words if necessary */
  color: var(--modal-text-color); /* Ensure value text uses modal text color */
}


.tagsSection {
  composes: taskDetailsSection;
}
.tagsSectionLabel {
  font-weight: var(--font-weight-bold);
  color: var(--text-secondary-color); /* Use themed secondary text color */
  font-size: 0.9em;
  margin-bottom: var(--spacing-base-small);
  display: block;
}
.tagsViewArea { /* Container for (tag list + edit button) in view mode for tags */
  display: flex;
  align-items: center;
  justify-content: space-between;
  flex-wrap: wrap;
  gap: var(--spacing-base);
}
.tagsDisplay {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  gap: var(--spacing-base-small);
  flex-grow: 1; /* Allow tags to take space */
}
.tagItem {
  background-color: var(--tag-background-color);
  color: var(--tag-text-color);
  padding: var(--spacing-base-small) var(--spacing-base);
  border-radius: var(--border-radius-medium);
  font-size: 0.9em;
  display: inline-block;
}

/* Default styles for parts of EditableField if not overridden by specific context classes */
.editableFieldLabel { /* Default for label rendered by EditableField */
  display: block;
  font-weight: var(--font-weight-bold);
  color: var(--text-secondary-color); /* Use themed secondary text color */
  font-size: 0.9em;
  margin-bottom: var(--spacing-base-extra-small);
}
.editableFieldValueText { /* Default for value span rendered by EditableField */
  word-break: break-word;
  color: var(--modal-text-color); /* Default value text */
}
.defaultValueArea { /* Default for container of (value + edit button) */
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: var(--spacing-base-small);
  width: 100%;
}


/* Inline Editing Forms */
.inlineEditSection {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-base);
  width: 100%;
}
.inlineEditSectionControls {
  display: flex;
  gap: var(--spacing-base-small);
  align-items: center;
}

.inlineEditSectionCompact { /* Used as editModeClassName for meta fields */
  display: flex;
  flex-direction: column;
  gap: var(--spacing-base-small);
  width: 100%;
}
.inlineEditSectionCompactControls {
  display: flex;
  align-items: center;
  width: 100%;
  gap: var(--spacing-base-small);
}
.inlineEditSectionCompactControls input {
  flex-grow: 1;
  min-width: 80px;
}


/* Form Inputs */
.formInputFull,
.formTextareaFull {
  width: 100%;
  padding: var(--spacing-base);
  border: 1px solid var(--input-border-color);
  border-radius: var(--border-radius-medium);
  box-sizing: border-box;
  background-color: var(--input-background-color);
  color: var(--input-text-color);
}
.formTextareaFull {
  min-height: 100px;
  resize: vertical;
}
.formInput {
  padding: var(--spacing-base-small) var(--spacing-base);
  border: 1px solid var(--input-border-color);
  border-radius: var(--border-radius-medium);
  box-sizing: border-box;
  background-color: var(--input-background-color);
  color: var(--input-text-color);
}
input::placeholder, textarea::placeholder {
  color: var(--text-placeholder-color);
  opacity: 1;
}
input:disabled, textarea:disabled {
  background-color: var(--background-disabled-color);
  color: var(--text-disabled-color); /* Add disabled text color */
  cursor: not-allowed;
}


/* Error Messages */
.errorTextSmall {
  color: var(--danger-text-color);
  font-size: 0.85em;
  width: 100%;
}


/* Buttons */
.button {
  padding: var(--spacing-base) calc(var(--spacing-base) * 1.5);
  border: none;
  border-radius: var(--border-radius-medium);
  cursor: pointer;
  font-weight: var(--font-weight-bold);
  transition: background-color 0.2s ease-in-out, opacity 0.2s ease-in-out, color 0.2s ease-in-out, border-color 0.2s ease-in-out;
  text-align: center;
}
.buttonPrimary {
  background-color: var(--button-background-color); /* Themed primary button */
  color: var(--button-text-color);
}
.buttonPrimary:hover:not(:disabled) {
  background-color: var(--button-hover-background-color);
}
.buttonPrimary:disabled {
  background-color: var(--button-disabled-background-color);
  color: var(--button-disabled-text-color);
  cursor: not-allowed;
}
.buttonSecondary {
  background-color: var(--button-secondary-background-color);
  color: var(--button-secondary-text-color);
  border: 1px solid var(--button-secondary-border-color);
}
.buttonSecondary:hover:not(:disabled) {
  background-color: var(--button-secondary-hover-background-color);
  /* border-color might also change on hover if desired */
}
.buttonSecondary:disabled {
  background-color: var(--button-disabled-background-color);
  color: var(--button-disabled-text-color);
  border-color: var(--button-disabled-background-color); /* Or a specific disabled border */
  cursor: not-allowed;
}
.buttonLink {
  background: none;
  border: none;
  color: var(--link-color);
  text-decoration: none;
  padding: 0;
  font-weight: normal;
}
.buttonLink:hover {
  text-decoration: underline;
  color: var(--link-hover-color);
}
.buttonSmall {
  padding: var(--spacing-base-small) var(--spacing-base);
  font-size: 0.9em;
}

.closeButtonModal {
  margin-top: calc(var(--spacing-base) * 2.5);
  /* align-self: flex-end; Removed to allow centering or other layouts in modalActions */
  composes: button buttonSecondary; /* Moved composition here */
}

.modalActions {
  display: flex;
  justify-content: space-between; /* Distributes items: link to left, button to right */
  align-items: center;
  margin-top: calc(var(--spacing-base) * 2.5);
  padding-top: calc(var(--spacing-base) * 1.5);
  border-top: 1px solid var(--border-subtle-color); /* Optional: visual separation, use subtle */
}

/* Ensure the link within modalActions looks like a button if desired, or style as a link */
.modalActions .buttonLink {
  /* If it should look like a button, inherit from .button or define similar styles */
  /* For example, to make it look like a secondary button: */
  /* composes: button; */
  /* composes: buttonSecondary; */
  /* Or, if it's a true link, ensure it's styled appropriately */
  color: var(--link-color); /* Use themed link color */
  text-decoration: none;
  padding: var(--spacing-base) 0; /* Adjust padding as needed */
}
.modalActions .buttonLink:hover {
  text-decoration: underline;
  color: var(--link-hover-color); /* Use themed link hover color */
}

/* Style for the close button if it's inside modalActions */
.modalActions .closeButtonModal {
  margin-top: 0; /* Reset margin-top if it's now part of modalActions */
  /* Add other specific styles if needed, e.g., make it a primary button */
  /* composes: button buttonSecondary; */ /* Removed from here */
}


================================================
FILE: client/src/features/TaskDetailModal/ui/TaskDetailModal.tsx
================================================
// client/src/features/TaskDetailModal/ui/TaskDetailModal.tsx
import React, { useEffect, useState, useCallback } from 'react';
import { Link } from 'react-router-dom';
import type { TaskDto } from '../../../shared/api/projectService';
import { taskService, transformCommentDto } from '../../../shared/api/taskService';
// ### ИЗМЕНЕНИЕ: Импортируем типы из правильного места ###
import type { UpdateTaskDto, CommentDto, ApiCommentDto } from '../../../shared/api/types';

import { getTaskComments } from '../../Comments/api';
import { CommentList, AddCommentForm } from '../../Comments';
import { socket } from '../../../shared/lib/socket';
import styles from './TaskDetailModal.module.css';
import EditableField from './EditableField';

interface TaskDetailModalProps {
  task: TaskDto | null;
  isOpen: boolean;
  onClose: () => void;
  projectId: number | null;
}

const TaskDetailModal: React.FC<TaskDetailModalProps> = ({ task, isOpen, onClose, projectId }) => {
  const [comments, setComments] = useState<CommentDto[]>([]);
  const [isLoadingComments, setIsLoadingComments] = useState(false);
  const [errorComments, setErrorComments] = useState<string | null>(null);

  const [editableTitle, setEditableTitle] = useState('');
  const [editableDescription, setEditableDescription] = useState('');
  const [editableDueDate, setEditableDueDate] = useState('');
  const [editableType, setEditableType] = useState('');
  const [editablePriority, setEditablePriority] = useState('');
  const [editableTags, setEditableTags] = useState('');

  const [isEditingTitle, setIsEditingTitle] = useState(false);
  const [isEditingDescription, setIsEditingDescription] = useState(false);
  const [isEditingDueDate, setIsEditingDueDate] = useState(false);
  const [isEditingType, setIsEditingType] = useState(false);
  const [isEditingPriority, setIsEditingPriority] = useState(false);
  const [isEditingTags, setIsEditingTags] = useState(false);

  const [isUpdatingTitle, setIsUpdatingTitle] = useState(false);
  const [titleUpdateError, setTitleUpdateError] = useState<string | null>(null);
  const [isUpdatingDescription, setIsUpdatingDescription] = useState(false);
  const [descriptionUpdateError, setDescriptionUpdateError] = useState<string | null>(null);
  const [isUpdatingDueDate, setIsUpdatingDueDate] = useState(false);
  const [dueDateUpdateError, setDueDateUpdateError] = useState<string | null>(null);
  const [isUpdatingType, setIsUpdatingType] = useState(false);
  const [typeUpdateError, setTypeUpdateError] = useState<string | null>(null);
  const [isUpdatingPriority, setIsUpdatingPriority] = useState(false);
  const [priorityUpdateError, setPriorityUpdateError] = useState<string | null>(null);
  const [isUpdatingTags, setIsUpdatingTags] = useState(false);
  const [tagsUpdateError, setTagsUpdateError] = useState<string | null>(null);

  useEffect(() => {
    if (task) {
      if (!isEditingTitle) setEditableTitle(task.title);
      if (!isEditingDescription) setEditableDescription(task.description || '');
      if (!isEditingDueDate) setEditableDueDate(task.due_date ? new Date(task.due_date).toISOString().split('T')[0] : '');
      if (!isEditingType) setEditableType(task.type || '');
      if (!isEditingPriority) setEditablePriority(task.priority || '');
      if (!isEditingTags) setEditableTags(task.tags ? task.tags.join(', ') : '');
    }
  }, [task, isOpen, isEditingTitle, isEditingDescription, isEditingDueDate, isEditingType, isEditingPriority, isEditingTags]);

  const fetchComments = useCallback(async () => {
    if (!task) return;
    setIsLoadingComments(true);
    setErrorComments(null);
    try {
      const fetchedComments = await getTaskComments(task.id);
      setComments(fetchedComments);
    } catch (error) {
      console.error('Failed to fetch comments:', error);
      setErrorComments('Could not load comments.');
    } finally {
      setIsLoadingComments(false);
    }
  }, [task]);

  useEffect(() => {
    if (isOpen && task) {
      fetchComments();
    }
  }, [isOpen, task, fetchComments]);

  useEffect(() => {
    if (!isOpen || !task || !projectId) return;
    const handleCommentCreated = (newComment: ApiCommentDto) => {
      if (newComment.task_id === task.id) {
        const commentToDisplay = transformCommentDto(newComment);
        setComments(prev => [...prev.filter(c => c.id !== commentToDisplay.id), commentToDisplay].sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime()));
      }
    };
    socket.on('comment:created', handleCommentCreated);
    return () => {
      socket.off('comment:created', handleCommentCreated);
    };
  }, [isOpen, task, projectId]);

  const handleCommentAdded = (newComment: CommentDto) => {
    setComments(prevComments => [...prevComments, newComment].sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime()));
  };

  if (!isOpen || !task) return null;

  const handleSaveField = async (
    fieldName: string,
    updateDtoPartial: Partial<UpdateTaskDto>,
    setIsUpdating: React.Dispatch<React.SetStateAction<boolean>>,
    setUpdateError: React.Dispatch<React.SetStateAction<string | null>>,
    setIsEditing: React.Dispatch<React.SetStateAction<boolean>>
  ) => {
    if (!task) return;
    setIsUpdating(true);
    setUpdateError(null);
    try {
      await taskService.updateTask(task.id, updateDtoPartial);
      setIsEditing(false);
    } catch (error: any) {
      setUpdateError(error.message || `Failed to update ${fieldName}.`);
    } finally {
      setIsUpdating(false);
    }
  };

  const handleSaveTitle = async () => handleSaveField('title', { title: editableTitle }, setIsUpdatingTitle, setTitleUpdateError, setIsEditingTitle);
  const handleSaveDescription = async () => handleSaveField('description', { description: editableDescription }, setIsUpdatingDescription, setDescriptionUpdateError, setIsEditingDescription);
  const handleSaveDueDate = async () => handleSaveField('dueDate', { dueDate: editableDueDate || null }, setIsUpdatingDueDate, setDueDateUpdateError, setIsEditingDueDate);
  const handleSaveType = async () => handleSaveField('type', { type: editableType }, setIsUpdatingType, setTypeUpdateError, setIsEditingType);
  const handleSavePriority = async () => handleSaveField('priority', { priority: editablePriority }, setIsUpdatingPriority, setPriorityUpdateError, setIsEditingPriority);
  const handleSaveTags = async () => {
    const tagsArray = editableTags.trim() ? editableTags.split(',').map(tag => tag.trim()).filter(tag => tag) : [];
    await handleSaveField('tags', { tags: tagsArray }, setIsUpdatingTags, setTagsUpdateError, setIsEditingTags);
  };

  const formatDate = (dateString?: string) => {
    if (!dateString) return 'Not set';
    return new Date(dateString).toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric', timeZone: 'UTC' });
  };

  return (
    <div className={styles.modalOverlay} onClick={onClose}>
      <div className={styles.modalContent} onClick={(e) => e.stopPropagation()}>
        <>
          <div className={styles.taskDetails}>
            <div className={styles.taskHeader}>
              <h2>
                {isEditingTitle ? (
                  <>
                    <span>{task.human_readable_id}: </span>
                    <EditableField
                      value={task.title}
                      editableValue={editableTitle}
                      isEditing={true}
                      isUpdating={isUpdatingTitle}
                      error={titleUpdateError}
                      onEdit={() => {}}
                      onCancel={() => { setIsEditingTitle(false); setEditableTitle(task.title); setTitleUpdateError(null); }}
                      onSave={handleSaveTitle}
                      onChange={(e) => setEditableTitle(e.target.value)}
                      inputType="text"
                      editModeClassName={styles.inlineEditSection}
                      inputSpecificClassName={styles.formInputFull}
                      controlsClassName={styles.inlineEditSectionControls}
                    />
                  </>
                ) : (
                  <>
                    <span>{task.human_readable_id}: {task.title}</span>
                    <button onClick={() => { setIsEditingTitle(true); setTitleUpdateError(null); }} className={`${styles.button} ${styles.buttonLink} ${styles.editIcon}`}>Edit</button>
                  </>
                )}
              </h2>
            </div>
            <div className={styles.description}>
              <EditableField
                value={task.description}
                editableValue={editableDescription}
                isEditing={isEditingDescription}
                isUpdating={isUpdatingDescription}
                error={descriptionUpdateError}
                onEdit={() => { setIsEditingDescription(true); setDescriptionUpdateError(null); }}
                onCancel={() => { setIsEditingDescription(false); setEditableDescription(task.description || ''); setDescriptionUpdateError(null); }}
                onSave={handleSaveDescription}
                onChange={(e) => setEditableDescription(e.target.value)}
                inputType="textarea"
                viewModeClassName={styles.descriptionView}
                valueTextClassName={styles.descriptionText}
                valueAreaClassName={styles.defaultValueArea}
                editModeClassName={styles.inlineEditSection}
                inputSpecificClassName={styles.formTextareaFull}
                controlsClassName={styles.inlineEditSectionControls}
              />
            </div>
            <div className={styles.metaGrid}>
              <EditableField
                label="Due Date:" value={task.due_date} editableValue={editableDueDate} isEditing={isEditingDueDate}
                isUpdating={isUpdatingDueDate} error={dueDateUpdateError} onEdit={() => { setIsEditingDueDate(true); setDueDateUpdateError(null); }}
                onCancel={() => { setIsEditingDueDate(false); setEditableDueDate(task.due_date ? new Date(task.due_date).toISOString().split('T')[0] : ''); setDueDateUpdateError(null); }}
                onSave={handleSaveDueDate} onChange={(e) => setEditableDueDate(e.target.value)} inputType="date" valueDisplayFormatter={(val) => formatDate(val as string | undefined)}
                viewModeClassName={styles.metaGridItem} labelClassName={styles.metaGridItemLabel} valueAreaClassName={styles.metaGridItemValueArea}
                valueTextClassName={styles.metaGridItemValueText} editModeClassName={styles.inlineEditSectionCompact} inputSpecificClassName={styles.formInput}
                controlsClassName={styles.inlineEditSectionCompactControls}
              />
              <EditableField
                label="Type:" value={task.type} editableValue={editableType} isEditing={isEditingType} isUpdating={isUpdatingType}
                error={typeUpdateError} onEdit={() => { setIsEditingType(true); setTypeUpdateError(null); }}
                onCancel={() => { setIsEditingType(false); setEditableType(task.type || ''); setTypeUpdateError(null); }} onSave={handleSaveType}
                onChange={(e) => setEditableType(e.target.value)} inputPlaceholder="e.g., Bug, Feature" viewModeClassName={styles.metaGridItem}
                labelClassName={styles.metaGridItemLabel} valueAreaClassName={styles.metaGridItemValueArea} valueTextClassName={styles.metaGridItemValueText}
                editModeClassName={styles.inlineEditSectionCompact} inputSpecificClassName={styles.formInput} controlsClassName={styles.inlineEditSectionCompactControls}
              />
              <EditableField
                label="Priority:" value={task.priority} editableValue={editablePriority} isEditing={isEditingPriority} isUpdating={isUpdatingPriority}
                error={priorityUpdateError} onEdit={() => { setIsEditingPriority(true); setPriorityUpdateError(null); }}
                onCancel={() => { setIsEditingPriority(false); setEditablePriority(task.priority || ''); setPriorityUpdateError(null); }}
                onSave={handleSavePriority} onChange={(e) => setEditablePriority(e.target.value)} inputPlaceholder="e.g., High, Medium, Low"
                viewModeClassName={styles.metaGridItem} labelClassName={styles.metaGridItemLabel} valueAreaClassName={styles.metaGridItemValueArea}
                valueTextClassName={styles.metaGridItemValueText} editModeClassName={styles.inlineEditSectionCompact} inputSpecificClassName={styles.formInput}
                controlsClassName={styles.inlineEditSectionCompactControls}
              />
            </div>
            <div className={styles.tagsSection}>
              <EditableField
                label="Tags:" value={task.tags} editableValue={editableTags} isEditing={isEditingTags} isUpdating={isUpdatingTags}
                error={tagsUpdateError} onEdit={() => { setIsEditingTags(true); setTagsUpdateError(null); }}
                onCancel={() => { setIsEditingTags(false); setEditableTags(task.tags ? task.tags.join(', ') : ''); setTagsUpdateError(null); }}
                onSave={handleSaveTags} onChange={(e) => setEditableTags(e.target.value)} inputPlaceholder="e.g., UI, Backend"
                labelClassName={styles.tagsSectionLabel} valueAreaClassName={styles.tagsViewArea} editModeClassName={styles.inlineEditSection}
                inputSpecificClassName={styles.formInputFull} controlsClassName={styles.inlineEditSectionControls}
              >
                <div className={styles.tagsDisplay}>
                  {task.tags && task.tags.length > 0 ? task.tags.map(tag => <span key={tag} className={styles.tagItem}>{tag}</span>) : <span>No tags.</span>}
                </div>
              </EditableField>
            </div>
          </div>
          <div className={styles.commentsSection}>
            <h3>Comments</h3>
            {isLoadingComments && <p>Loading comments...</p>}
            {errorComments && <p style={{color: 'red'}}>{errorComments}</p>}
            {!isLoadingComments && <CommentList comments={comments} />}
            <AddCommentForm taskId={task.id} onCommentAdded={handleCommentAdded} />
          </div>
        </>
        <div className={styles.modalActions}>
          {/* ### ИЗМЕНЕНИЕ: Ссылка теперь указывает на правильный маршрут /tasks/HID ### */}
          <Link to={`/tasks/${task.human_readable_id}`} className={`${styles.button} ${styles.buttonLink}`}>
            Open in New Page
          </Link>
          <button onClick={onClose} className={`${styles.button} ${styles.closeButtonModal}`}>Close</button>
        </div>
      </div>
    </div>
  );
};
export default TaskDetailModal;

================================================
FILE: client/src/main.tsx
================================================
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom'; // ### НОВОЕ: Импортируем BrowserRouter
import App from './app/App.tsx';
import { AuthProvider } from './app/auth/AuthContext';

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <BrowserRouter>
      <AuthProvider>
        <App />
      </AuthProvider>
    </BrowserRouter>
  </StrictMode>,
);

================================================
FILE: client/src/pages/BoardPage.module.css
================================================
/* client/src/pages/BoardPage.module.css */

/* Стили для модальной формы удалены, так как они теперь в AddTaskModal.module.css */

.pageHeader {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: calc(var(--spacing-base) * 2);
  padding-bottom: calc(var(--spacing-base) * 2);
  border-bottom: 1px solid var(--border-color);
}

.pageHeader h1 {
  margin: 0;
}

================================================
FILE: client/src/pages/BoardPage.tsx
================================================
import React, { useEffect, useState, useCallback } from 'react';
import { useParams, useNavigate, Link } from 'react-router-dom';
import {
  DndContext,
  closestCorners,
  DragOverlay,
  PointerSensor,
  useSensor,
  useSensors,
} from '@dnd-kit/core';
import type { DragEndEvent, DragOverEvent, DragStartEvent } from '@dnd-kit/core';

import { projectService } from '../shared/api/projectService';
import type { FullProjectDto, ColumnDto as ProjectColumnDto, TaskDto } from '../shared/api/projectService';
import { taskService } from '../shared/api/taskService';
import { socket, joinProjectRoom, leaveProjectRoom } from '../shared/lib/socket';

import styles from './BoardPage.module.css';
import ColumnLane from '../features/ColumnLane/ColumnLane';
import { TaskDetailModal } from '../features/TaskDetailModal';
import { AddTaskModal } from '../features/AddTaskModal';

interface Column extends ProjectColumnDto {
  tasksList: TaskDto[];
}

interface BoardData extends Omit<FullProjectDto, 'columns'> {
  columns: Column[];
}

const BoardPage: React.FC = () => {
  const { projectId } = useParams<{ projectId: string }>();
  const navigate = useNavigate();
  const [boardData, setBoardData] = useState<BoardData | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [activeDragId, setActiveDragId] = useState<string | null>(null);
  const [selectedTask, setSelectedTask] = useState<TaskDto | null>(null);

  const numericProjectId = projectId ? parseInt(projectId, 10) : null;

  const sensors = useSensors(
    useSensor(PointerSensor, {
      activationConstraint: {
        distance: 5,
      },
    })
  );

  const fetchBoardData = useCallback(async () => {
    if (numericProjectId === null || isNaN(numericProjectId)) {
        setError("Invalid Project ID format.");
        setIsLoading(false);
        return;
    }
    try {
      setIsLoading(true);
      const projectDetails = await projectService.getProjectById(numericProjectId);
      const transformedColumns = projectDetails.columns?.map(col => ({
        ...col,
        tasksList: col.tasks?.sort((a, b) => a.position - b.position) || [],
      })).sort((a,b) => a.position - b.position) || [];

      if (!projectDetails || Object.keys(projectDetails).length === 0) {
        navigate('/404');
        return;
      }

      setBoardData({ ...projectDetails, columns: transformedColumns });
      setError(null);
    } catch (err: any) {
      if (err.response?.status === 404) {
        navigate('/404');
      } else {
        setError('Failed to fetch board data.');
        console.error(err);
      }
    } finally {
      setIsLoading(false);
    }
  }, [numericProjectId, navigate]);

  useEffect(() => {
    fetchBoardData();
    if (projectId) {
      if (!socket.connected) socket.connect();

      const onConnect = () => joinProjectRoom(projectId);
      socket.once('connect', onConnect);
      if (socket.connected) onConnect();

      const handleTaskEvent = (task: TaskDto) => {
        setBoardData((prev) => {
          if (!prev || task.project_id !== numericProjectId) return prev;
      
          let newColumns = JSON.parse(JSON.stringify(prev.columns)) as Column[];
      
          // Remove task from its old position in all cases
          newColumns = newColumns.map(col => ({
            ...col,
            tasksList: col.tasksList.filter(t => t.id !== task.id)
          }));
      
          // Add/Update task in its new/current column
          const targetColumnIndex = newColumns.findIndex(col => col.id === task.column_id);
          if (targetColumnIndex !== -1) {
            newColumns[targetColumnIndex].tasksList.push(task);
            // Always sort the tasks in the affected column
            newColumns[targetColumnIndex].tasksList.sort((a, b) => a.position - b.position);
          }
      
          return { ...prev, columns: newColumns };
        });
      };
      
      socket.on('task:created', handleTaskEvent);
      socket.on('task:moved', handleTaskEvent);
      socket.on('task:updated', handleTaskEvent);

      return () => {
        socket.off('connect', onConnect);
        socket.off('task:created', handleTaskEvent);
        socket.off('task:moved', handleTaskEvent);
        socket.off('task:updated', handleTaskEvent);
        if (projectId) leaveProjectRoom(projectId);
      };
    }
  }, [projectId, fetchBoardData, numericProjectId]);


  const handleTaskClick = (task: TaskDto) => {
    setSelectedTask(task);
  };

  const findColumnContainingTask = (taskId: string): Column | undefined => {
    return boardData?.columns.find(column => column.tasksList.some(task => task.id === taskId));
  };

  const handleDragStart = (event: DragStartEvent) => {
    setActiveDragId(event.active.id as string);
  };

  const handleDragOver = (event: DragOverEvent) => {
    const { active, over } = event;
    if (!over || !boardData) return;
    const activeId = active.id as string;
    const overId = over.id as string;

    if (activeId === overId) return;

    const activeColumn = findColumnContainingTask(activeId);
    const overColumn = boardData.columns.find(col => col.id === overId) || findColumnContainingTask(overId);

    if (!activeColumn || !overColumn) return;

    const activeTask = activeColumn.tasksList.find(t => t.id === activeId);
    if (!activeTask) return;

    setBoardData(prev => {
      if (!prev) return null;
      const columnsCopy = JSON.parse(JSON.stringify(prev.columns)) as Column[];
      const sourceColIndex = columnsCopy.findIndex(c => c.id === activeColumn.id);
      const destColIndex = columnsCopy.findIndex(c => c.id === overColumn.id);
      const sourceTaskIndex = columnsCopy[sourceColIndex].tasksList.findIndex(t => t.id === activeId);
      const [movedTask] = columnsCopy[sourceColIndex].tasksList.splice(sourceTaskIndex, 1);
      let destTaskIndex = columnsCopy[destColIndex].tasksList.findIndex(t => t.id === overId);
      if (destTaskIndex === -1) {
        destTaskIndex = columnsCopy[destColIndex].tasksList.length;
      }
      columnsCopy[destColIndex].tasksList.splice(destTaskIndex, 0, movedTask);
      return { ...prev, columns: columnsCopy };
    });
  };

  const handleDragEnd = async (event: DragEndEvent) => {
    setActiveDragId(null);
    const { active, over } = event;

    if (!over || !boardData) {
      fetchBoardData();
      return;
    }

    const activeId = active.id as string;
    const finalParentColumn = boardData.columns.find(col => col.tasksList.some(task => task.id === activeId));
    if (!finalParentColumn) {
      fetchBoardData();
      return;
    }

    const newColumnId = finalParentColumn.id;
    const newPosition = finalParentColumn.tasksList.findIndex(task => task.id === activeId);

    if (newPosition === -1) {
      fetchBoardData();
      return;
    }

    try {
      await taskService.moveTask(activeId, { newColumnId, newPosition });
    } catch (err) {
      console.error('Failed to move task:', err);
      setError('Failed to save task position. Reverting changes.');
      fetchBoardData();
    }
  };

  if (isLoading && !boardData) return <p>Loading board...</p>;
  if (error) return <p style={{ color: 'red' }}>{error}</p>;
  if (!boardData || !numericProjectId) return <p>No board data found or project ID is invalid.</p>;

  return (
    <>
      <DndContext
        sensors={sensors}
        collisionDetection={closestCorners}
        onDragStart={handleDragStart}
        onDragOver={handleDragOver}
        onDragEnd={handleDragEnd}
      >
        <div>
          <div className={styles.pageHeader}>
            <h1>{boardData.name}{boardData.task_prefix ? ` (${boardData.task_prefix})` : ''}</h1>
            <Link to={`/projects/${numericProjectId}/settings`} className="button secondary">
                Project Settings ⚙️
            </Link>
          </div>
          <AddTaskModal projectId={numericProjectId} columns={boardData.columns} />
          <div style={{ display: 'flex', gap: '16px', overflowX: 'auto', padding: '10px', minHeight: 'calc(100vh - 100px)' }}>
            {boardData.columns.map((column) => (
              <ColumnLane key={column.id} column={column} onTaskClick={handleTaskClick} />
            ))}
          </div>
        </div>
      </DndContext>
      {selectedTask && (
        <TaskDetailModal
          task={selectedTask}
          isOpen={!!selectedTask}
          onClose={() => setSelectedTask(null)}
          projectId={numericProjectId}
        />
      )}
      <DragOverlay>{activeDragId ? <div style={{ border: '1px solid gray', padding: '10px', backgroundColor: 'lightyellow' }}>Dragging Task</div> : null}</DragOverlay>
    </>
  );
};
export default BoardPage;

================================================
FILE: client/src/pages/DashboardPage.module.css
================================================
.table {
  width: 100%;
  border-collapse: collapse;
  margin-top: 20px;
  background-color: var(--card-background-color); /* Use card background for table */
  color: var(--text-color); /* Ensure text color contrasts with background */
}

.table th,
.table td {
  border: 1px solid var(--border-color); /* Use theme border color */
  padding: 8px;
  text-align: left;
}

.table th {
  background-color: var(--background-subtle-color); /* Use a subtle background for header */
  font-weight: bold;
  color: var(--text-color); /* Ensure header text is readable */
}

.table tbody tr:hover {
  background-color: var(--element-hover-background-color); /* Use theme hover color */
}

.link a {
  color: var(--link-color); /* Use theme link color */
  text-decoration: none;
}

.link a:hover {
  text-decoration: underline;
  color: var(--link-hover-color); /* Use theme link hover color */
}

/* Styles for the modal form elements */
.formInput {
  width: 100%;
  padding: 8px;
  box-sizing: border-box;
  margin-bottom: 10px;
  border: 1px solid var(--input-border-color); /* Use theme input border color */
  border-radius: 4px;
  background-color: var(--input-background-color); /* Use theme input background color */
  color: var(--input-text-color); /* Use theme input text color */
}

.formActions {
  display: flex;
  justify-content: flex-end;
  gap: 10px;
  margin-top: 20px;
}

.button {
  padding: 8px 15px;
  border-radius: 4px;
  border: 1px solid transparent;
  cursor: pointer;
}

.buttonPrimary {
  background-color: var(--button-background-color);
  color: var(--button-text-color);
  border-color: var(--button-background-color);
}

.buttonPrimary:disabled {
  background-color: var(--button-disabled-background-color);
  color: var(--button-disabled-text-color);
  opacity: 0.65; /* Keep opacity for visual cue, though colors also change */
  cursor: not-allowed;
}

.buttonSecondary {
  background-color: var(--button-secondary-background-color);
  color: var(--button-secondary-text-color);
  border-color: var(--button-secondary-border-color);
}


================================================
FILE: client/src/pages/DashboardPage.tsx
================================================
import React, { useEffect, useState } from 'react';
import { Link } from 'react-router-dom';
import { projectService } from '../shared/api/projectService';
import type { ProjectListDto, CreateProjectDto } from '../shared/api/projectService';
import { Modal } from '../shared/ui/Modal';
import styles from './DashboardPage.module.css';

const DashboardPage: React.FC = () => {
  const [projects, setProjects] = useState<ProjectListDto[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const [isModalOpen, setIsModalOpen] = useState(false);
  const [newProjectName, setNewProjectName] = useState('');
  const [newProjectPrefix, setNewProjectPrefix] = useState('');
  const [isCreating, setIsCreating] = useState(false);
  const [formError, setFormError] = useState<string | null>(null); // ### НОВОЕ: Состояние для ошибки в модальном окне

  const fetchProjects = async () => {
    try {
      setIsLoading(true);
      const userProjects = await projectService.getUserProjects();
      setProjects(userProjects);
      setError(null);
    } catch (err) {
      setError('Failed to fetch projects.');
      console.error(err);
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchProjects();
  }, []);

  const handleCreateProject = async (e: React.FormEvent) => {
    e.preventDefault();
    setFormError(null); // ### НОВОЕ: Сбрасываем ошибку перед новой попыткой

    if (!newProjectName.trim() || !newProjectPrefix.trim()) {
      setFormError('Project name and prefix are required.'); // ### ИЗМЕНЕНИЕ: Вместо alert()
      return;
    }
    setIsCreating(true);
    try {
      const newProjectData: CreateProjectDto = { name: newProjectName, prefix: newProjectPrefix.toUpperCase() };
      await projectService.createProject(newProjectData);
      setNewProjectName('');
      setNewProjectPrefix('');
      setIsModalOpen(false);
      fetchProjects(); // Refresh the list
    } catch (err: any) { // ### ИЗМЕНЕНИЕ: Обрабатываем ошибку API
      console.error('Failed to create project:', err);
      // Устанавливаем сообщение об ошибке, полученное от API, или общее сообщение
      setFormError(err.response?.data?.message || 'Failed to create project. Check if the prefix is unique.');
    } finally {
      setIsCreating(false);
    }
  };

  // ### НОВОЕ: Функция для закрытия модального окна, которая также сбрасывает ошибки
  const handleCloseModal = () => {
    setIsModalOpen(false);
    setFormError(null);
    setNewProjectName('');
    setNewProjectPrefix('');
  };

  if (isLoading) return <p>Loading projects...</p>;
  if (error) return <p style={{ color: 'red' }}>{error}</p>;

  return (
    <div>
      <h1>My Projects</h1>
      <button onClick={() => setIsModalOpen(true)}>+ Create New Project</button>

      <Modal
        isOpen={isModalOpen}
        onClose={handleCloseModal}
        title="Create New Project"
      >
        <form onSubmit={handleCreateProject}>
          {/* ### НОВОЕ: Отображение ошибки внутри модального окна ### */}
          {formError && <p style={{ color: 'red', marginBottom: '10px' }}>{formError}</p>}
          <div>
            <label htmlFor="projectName">Project Name:</label>
            <input
              id="projectName"
              type="text"
              value={newProjectName}
              onChange={(e) => setNewProjectName(e.target.value)}
              required
              className={styles.formInput}
            />
          </div>
          <div>
            <label htmlFor="projectPrefix">Project Prefix (e.g., PROJ):</label>
            <input
              id="projectPrefix"
              type="text"
              value={newProjectPrefix}
              onChange={(e) => setNewProjectPrefix(e.target.value)}
              maxLength={10}
              required
              className={styles.formInput}
            />
          </div>
          <div className={styles.formActions}>
            <button
              type="button"
              onClick={handleCloseModal}
              className={`${styles.button} ${styles.buttonSecondary}`}
            >
              Cancel
            </button>
            <button
              type="submit"
              disabled={isCreating}
              className={`${styles.button} ${styles.buttonPrimary}`}
            >
              {isCreating ? 'Creating...' : 'Create Project'}
            </button>
          </div>
        </form>
      </Modal>

      {projects.length === 0 ? (
        <p>No projects yet. Create one to get started!</p>
      ) : (
        <table className={styles.table}>
          <thead>
            <tr>
              <th scope="col">Project Name</th>
              <th scope="col">Prefix</th>
              <th scope="col">Link</th>
            </tr>
          </thead>
          <tbody>
            {projects.map((project) => (
              <tr key={project.id}>
                <td>{project.name}</td>
                <td>{project.task_prefix}</td>
                <td className={styles.link}>
                  <Link to={`/projects/${project.id}`}>View Board</Link>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      )}
    </div>
  );
};

export default DashboardPage;

================================================
FILE: client/src/pages/LandingPage.tsx
================================================
import React from 'react';
import { Link } from 'react-router-dom';

// Basic inline styles for demonstration
const styles = {
  container: {
    display: 'flex',
    flexDirection: 'column' as 'column', // Type assertion for 'column'
    alignItems: 'center',
    justifyContent: 'center',
    minHeight: '100vh',
    textAlign: 'center' as 'center', // Type assertion for 'center'
    padding: '20px',
  },
  heading: {
    marginBottom: '20px',
  },
  paragraph: {
    marginBottom: '30px',
    fontSize: '1.1em',
    maxWidth: '600px',
  },
  navLinks: {
    display: 'flex',
    gap: '20px',
  },
  linkButton: {
    padding: '10px 20px',
    textDecoration: 'none',
    backgroundColor: '#007bff',
    color: 'white',
    borderRadius: '5px',
    fontSize: '1em',
  }
};

const LandingPage: React.FC = () => {
  return (
    <div style={styles.container}>
      <h1 style={styles.heading}>Welcome to Mutabor Task Manager!</h1>
      <p style={styles.paragraph}>
        Mutabor helps you manage your tasks efficiently, collaborate with your team,
        and leverage AI to boost your productivity. Get started by logging in or
        creating a new account.
      </p>
      <div style={styles.navLinks}>
        <Link to="/login" style={styles.linkButton}>Login</Link>
        <Link to="/register" style={styles.linkButton}>Register</Link>
      </div>
    </div>
  );
};

export default LandingPage;


================================================
FILE: client/src/pages/LoginPage.tsx
================================================
import LoginForm from '../features/authByEmail/ui/LoginForm';

const LoginPage = () => {
  return (
    <div className="form-page-container">
      <h1>Login</h1>
      <LoginForm />
    </div>
  );
};

export default LoginPage;

================================================
FILE: client/src/pages/NotFoundPage.tsx
================================================
import React from 'react';
import { Link } from 'react-router-dom';
import { useAuth } from '../app/auth/AuthContext';

// Basic inline styles for demonstration
const styles = {
  container: {
    display: 'flex',
    flexDirection: 'column' as 'column',
    alignItems: 'center',
    justifyContent: 'center',
    minHeight: '80vh', // Use less than 100vh if there's a header/footer
    textAlign: 'center' as 'center',
    padding: '20px',
  },
  heading: {
    fontSize: '2.5em',
    marginBottom: '20px',
    color: '#333',
  },
  message: {
    fontSize: '1.2em',
    marginBottom: '30px',
    color: '#555',
  },
  link: {
    padding: '10px 20px',
    textDecoration: 'none',
    backgroundColor: '#007bff',
    color: 'white',
    borderRadius: '5px',
    fontSize: '1em',
  }
};

const NotFoundPage: React.FC = () => {
  const { isAuthenticated } = useAuth();
  const destinationPath = isAuthenticated ? '/dashboard' : '/';
  const linkText = isAuthenticated ? 'Go to Dashboard' : 'Go to Homepage';

  return (
    <div style={styles.container}>
      <h1 style={styles.heading}>404 - Page Not Found</h1>
      <p style={styles.message}>
        Sorry, the page you are looking for does not exist or you may not have permission to view it.
      </p>
      <Link to={destinationPath} style={styles.link}>
        {linkText}
      </Link>
    </div>
  );
};

export default NotFoundPage;


================================================
FILE: client/src/pages/ProjectSettings/GeneralSettingsTab.tsx
================================================
// client/src/pages/ProjectSettings/GeneralSettingsTab.tsx
import React, { useState, useEffect } from 'react';
import { projectService } from '../../shared/api/projectService';
import type { UpdateProjectSettingsPayload } from '../../shared/api/types';
import styles from '../ProjectSettingsPage.module.css';

interface GeneralSettingsTabProps {
  projectId: number;
  initialName: string;
  initialPrefix: string;
  onSettingsChanged: (newName: string) => void;
}

const GeneralSettingsTab: React.FC<GeneralSettingsTabProps> = ({ projectId, initialName, initialPrefix, onSettingsChanged }) => {
  const [projectName, setProjectName] = useState(initialName);
  const [projectPrefix, setProjectPrefix] = useState(initialPrefix);
  const [isSaving, setIsSaving] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);

  useEffect(() => {
    setProjectName(initialName);
    setProjectPrefix(initialPrefix);
  }, [initialName, initialPrefix]);

  const handleSubmit = async (event: React.FormEvent) => {
    event.preventDefault();
    if (isSaving) return;

    setIsSaving(true);
    setError(null);
    setSuccess(null);

    const payload: UpdateProjectSettingsPayload = {};
    if (projectName !== initialName) payload.name = projectName;
    if (projectPrefix !== initialPrefix) payload.prefix = projectPrefix;
    
    if (Object.keys(payload).length === 0) {
      setError("No changes to save.");
      setIsSaving(false);
      return;
    }

    try {
      await projectService.updateProjectSettings(projectId, payload);
      setSuccess("Settings saved successfully!");
      onSettingsChanged(projectName);
    } catch (err: any) {
      setError(err.response?.data?.message || 'Failed to save settings.');
    } finally {
      setIsSaving(false);
      setTimeout(() => setSuccess(null), 3000);
    }
  };

  return (
    <div>
      <h2>General</h2>
      <form onSubmit={handleSubmit}>
        {error && <p className={styles.error}>{error}</p>}
        {success && <p className={`${styles.error} ${styles.success}`}>{success}</p>}
        <div className={styles.formGroup}>
          <label htmlFor="projectName">Project Name</label>
          <input type="text" id="projectName" value={projectName} onChange={(e) => setProjectName(e.target.value)} required />
        </div>
        <div className={styles.formGroup}>
          <label htmlFor="projectPrefix">Task Prefix</label>
          <input type="text" id="projectPrefix" value={projectPrefix} onChange={(e) => setProjectPrefix(e.target.value.toUpperCase())} maxLength={10} required />
        </div>
        <button type="submit" className={`${styles.button} primary ${styles.submitButton}`} disabled={isSaving}>
          {isSaving ? 'Saving...' : 'Save General Settings'}
        </button>
      </form>
    </div>
  );
};

export default GeneralSettingsTab;

================================================
FILE: client/src/pages/ProjectSettings/MembersSettingsTab.tsx
================================================
// client/src/pages/ProjectSettings/MembersSettingsTab.tsx
import React, { useState, useEffect, useCallback } from 'react';
import { projectService } from '../../shared/api/projectService';
import type { AllParticipantsDto } from '../../shared/api/types';
import { Modal } from '../../shared/ui/Modal'; 
import styles from '../ProjectSettingsPage.module.css';

interface MembersSettingsTabProps {
  projectId: number;
}

const MembersSettingsTab: React.FC<MembersSettingsTabProps> = ({ projectId }) => {
  const [participants, setParticipants] = useState<AllParticipantsDto[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [addMemberEmail, setAddMemberEmail] = useState('');
  const [addMemberRole, setAddMemberRole] = useState<'editor' | 'viewer'>('editor');
  const [isAddingMember, setIsAddingMember] = useState(false);
  const [addMemberError, setAddMemberError] = useState<string | null>(null);

  const [isConfirmModalOpen, setIsConfirmModalOpen] = useState(false);
  const [memberToRemove, setMemberToRemove] = useState<AllParticipantsDto | null>(null);
  const [isRemoving, setIsRemoving] = useState(false);

  const fetchParticipants = useCallback(async () => {
    setIsLoading(true);
    try {
      const data = await projectService.getAllProjectParticipants(projectId);
      setParticipants(data || []);
      setError(null);
    } catch (err: any) {
      setError(err.response?.data?.message || 'Failed to load members.');
    } finally {
      setIsLoading(false);
    }
  }, [projectId]);

  useEffect(() => {
    fetchParticipants();
  }, [fetchParticipants]);
  
  const handleAddMember = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!addMemberEmail) {
        setAddMemberError("Email is required.");
        return;
    }
    setIsAddingMember(true);
    setAddMemberError(null);
    try {
        const newMember = await projectService.addProjectMember(projectId, { email: addMemberEmail, role: addMemberRole });
        // ### ИЗМЕНЕНИЕ: исправлена сортировка, чтобы использовать обе переменные ###
        setParticipants(prev => [...prev, newMember].sort((a, b) => {
          if (a.role === 'owner') return -1;
          if (b.role === 'owner') return 1;
          return (a.name || a.email).localeCompare(b.name || b.email);
        }));
        setAddMemberEmail('');
        setAddMemberRole('editor');
    } catch (err: any) {
        setAddMemberError(err.response?.data?.message || 'Failed to add member.');
    } finally {
        setIsAddingMember(false);
    }
  };

  const handleUpdateMemberRole = async (userId: string, newRole: 'editor' | 'viewer') => {
    try {
        const updatedMember = await projectService.updateProjectMember(projectId, userId, { role: newRole });
        setParticipants(prev => prev.map(p => p.id === userId ? updatedMember : p));
        setError(null);
    } catch(err: any) {
        setError(err.response?.data?.message || "Failed to update role.");
    }
  };

  const promptRemoveMember = (member: AllParticipantsDto) => {
    setMemberToRemove(member);
    setIsConfirmModalOpen(true);
  };

  const confirmRemoveMember = async () => {
    if (!memberToRemove) return;
    setIsRemoving(true);
    setError(null);
    try {
        await projectService.removeProjectMember(projectId, memberToRemove.id);
        setParticipants(prev => prev.filter(p => p.id !== memberToRemove.id));
        setIsConfirmModalOpen(false);
        setMemberToRemove(null);
    } catch (err: any) {
        setError(err.response?.data?.message || "Failed to remove member.");
        setIsConfirmModalOpen(false); 
    } finally {
        setIsRemoving(false);
    }
  };

  if (isLoading) return <p>Loading members...</p>;

  return (
    <div>
      <h2>Members</h2>
      {error && <p className={styles.error}>{error}</p>}
      <div className={styles.memberList}>
        {participants.map(p => (
          <div key={p.id} className={styles.memberItem} data-testid={`member-item-${p.id}`}>
            <div className={styles.memberInfo}>
              <span className={styles.memberName}>{p.name || p.email}</span>
              <span className={styles.memberEmail}>{p.email}</span>
            </div>
            <div className={styles.memberControls}>
              {p.role === 'owner' ? (
                <span className={styles.ownerTag}>Owner</span>
              ) : (
                <>
                  <select value={p.role} onChange={(e) => handleUpdateMemberRole(p.id, e.target.value as 'editor' | 'viewer')}>
                    <option value="editor">Editor</option>
                    <option value="viewer">Viewer</option>
                  </select>
                  <button className={`${styles.button} danger`} onClick={() => promptRemoveMember(p)}>Remove</button>
                </>
              )}
            </div>
          </div>
        ))}
      </div>
      <form className={styles.addMemberForm} onSubmit={handleAddMember}>
        <h3>Add Member</h3>
        {addMemberError && <p className={styles.error}>{addMemberError}</p>}
        <div className={styles.formGroup}>
          <input type="email" placeholder="User's email" value={addMemberEmail} onChange={e => setAddMemberEmail(e.target.value)} />
          <select value={addMemberRole} onChange={e => setAddMemberRole(e.target.value as 'editor' | 'viewer')}>
            <option value="editor">Editor</option>
            <option value="viewer">Viewer</option>
          </select>
          <button type="submit" className={`${styles.button} primary`} disabled={isAddingMember}>
            {isAddingMember ? "Adding..." : "Add"}
          </button>
        </div>
      </form>

      <Modal 
        isOpen={isConfirmModalOpen} 
        onClose={() => setIsConfirmModalOpen(false)}
        title="Confirm Removal"
      >
        <div>
          <p>Are you sure you want to remove <strong>{memberToRemove?.name || memberToRemove?.email}</strong> from the project?</p>
          <div className={styles.formActions}>
            <button className="button secondary" onClick={() => setIsConfirmModalOpen(false)} disabled={isRemoving}>
              Cancel
            </button>
            <button className="button danger" onClick={confirmRemoveMember} disabled={isRemoving}>
              {isRemoving ? "Removing..." : "Remove Member"}
            </button>
          </div>
        </div>
      </Modal>

    </div>
  );
};

export default MembersSettingsTab;

================================================
FILE: client/src/pages/ProjectSettingsPage.module.css
================================================
/* client/src/pages/ProjectSettingsPage.module.css */

.settingsPage h1 {
  text-align: center;
  font-size: 2rem;
  margin-bottom: 2rem;
  color: var(--text-color);
  padding-bottom: 1rem;
  border-bottom: 1px solid var(--border-color);
}

.settingsLayout {
  display: flex;
  gap: 2rem;
  max-width: 1000px;
  margin: 0 auto;
}

.sidebar {
  flex: 0 0 200px; /* Фиксированная ширина сайдбара */
  border-right: 1px solid var(--border-color);
  padding-right: 2rem;
}

.sidebarNav {
  list-style: none;
  padding: 0;
  margin: 0;
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.navItem a {
  display: block;
  padding: 0.75rem 1rem;
  border-radius: var(--border-radius-medium);
  text-decoration: none;
  color: var(--text-secondary-color);
  font-weight: 500;
  transition: background-color 0.2s ease, color 0.2s ease;
}

.navItem a:hover {
  background-color: var(--element-hover-background-color);
  color: var(--text-color);
}

.navItem a.active {
  background-color: var(--color-primary-background-hover);
  color: var(--color-primary);
  font-weight: 600;
}

.contentArea {
  flex-grow: 1;
  min-width: 0; /* Предотвращает переполнение flex-элементов */
  background-color: var(--card-background-color);
  padding: 2rem;
  border-radius: var(--border-radius-large);
  box-shadow: var(--shadow-small);
}

.contentArea h2 {
  font-size: 1.5rem;
  margin-top: 0;
  margin-bottom: 1.5rem;
  padding-bottom: 0.5rem;
  border-bottom: 1px solid var(--border-subtle-color);
  color: var(--text-color);
}

.loading,
.error,
.success {
  text-align: center;
  margin-bottom: 1rem;
  font-size: 1rem;
  padding: 1rem;
  border-radius: var(--border-radius-medium);
}

.error {
  color: var(--color-error);
  background-color: var(--color-background-danger-subtle);
}

.success {
  color: var(--color-success);
  background-color: var(--color-background-success-subtle);
}

.formGroup {
  margin-bottom: 1.5rem;
}

.formGroup label {
  display: block;
  margin-bottom: 0.5rem;
  font-weight: 500;
  color: var(--text-secondary-color);
}

.formGroup input[type="text"],
.formGroup input[type="url"],
.formGroup textarea,
.formGroup select {
  width: 100%;
  padding: 0.75rem;
  border: 1px solid var(--input-border-color);
  border-radius: var(--border-radius-medium);
  background-color: var(--input-background-color);
  color: var(--input-text-color);
  font-size: 1rem;
  box-sizing: border-box;
}

.formGroup input:focus,
.formGroup textarea:focus,
.formGroup select:focus {
  outline: none;
  border-color: var(--color-primary);
  box-shadow: var(--shadow-focus);
}

.listEditor {
  margin-bottom: 1rem;
}

.listItem {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  margin-bottom: 0.5rem;
}

.listItem input[type="text"] {
  flex-grow: 1;
}

.listItem select {
  padding: 0.5rem;
}

.button {
  padding: 0.6rem 1.2rem;
  border-radius: var(--border-radius-medium);
  cursor: pointer;
  font-size: 0.9rem;
  font-weight: 500;
  transition: background-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
  text-decoration: none;
  display: inline-block;
  text-align: center;
}

.addListItemButton {
  margin-top: 0.5rem;
  font-size: 0.9rem;
  padding: 0.5rem 1rem;
}

.submitButton {
  display: inline-block;
  width: auto;
  margin-top: 1rem;
  padding: 0.8rem 1.5rem;
  font-size: 1.1rem;
}


/* ### Стили для управления участниками ### */
.membersSection {
  margin-top: 0;
}

.memberList {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  margin-bottom: 1.5rem;
}

.memberItem {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.75rem;
  background-color: var(--background-subtle-color);
  border: 1px solid var(--border-subtle-color);
  border-radius: var(--border-radius-medium);
}

.memberInfo {
  display: flex;
  flex-direction: column;
}

.memberName {
  font-weight: 500;
  color: var(--text-color);
}

.memberEmail {
  font-size: 0.85rem;
  color: var(--text-secondary-color);
}

.memberControls {
  display: flex;
  align-items: center;
  gap: 0.75rem;
}

.ownerTag {
  font-weight: 500;
  color: var(--text-secondary-color);
  padding: 0.25rem 0.5rem;
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius-small);
}

.addMemberForm {
  margin-top: 1rem;
}

.addMemberForm .formGroup {
  display: flex;
  gap: 0.5rem;
  align-items: flex-end;
}

.addMemberForm .formGroup input {
  flex-grow: 1;
}

================================================
FILE: client/src/pages/ProjectSettingsPage.spec.tsx
================================================
// client/src/pages/ProjectSettingsPage.spec.tsx

import React from 'react';
import { render, screen, waitFor, within } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import '@testing-library/jest-dom';
import { MemoryRouter, Route, Routes } from 'react-router-dom';
import ProjectSettingsPage from './ProjectSettingsPage';
import { projectService } from '../shared/api/projectService';
import type { ProjectSettingsResponse, AllParticipantsDto } from '../shared/api/types';

// Мокируем дочерние компоненты (вкладки), чтобы изолированно тестировать контейнер
vi.mock('./ProjectSettings/GeneralSettingsTab', () => ({
  default: ({ onSettingsChanged }) => <div data-testid="general-tab">General Tab <button onClick={() => onSettingsChanged('new name')}>_</button></div>
}));
vi.mock('./ProjectSettings/StatusesSettingsTab', () => ({
  default: () => <div data-testid="statuses-tab">Statuses Tab</div>
}));
vi.mock('./ProjectSettings/TypesSettingsTab', () => ({
  default: () => <div data-testid="types-tab">Types Tab</div>
}));
vi.mock('./ProjectSettings/MembersSettingsTab', () => ({
  default: () => <div data-testid="members-tab">Members Tab</div>
}));

vi.mock('../shared/api/projectService');
const mockProjectService = projectService as jest.Mocked<typeof projectService>;

const mockSettingsData: ProjectSettingsResponse = {
  id: 1,
  name: 'Test Project',
  prefix: 'TEST',
  settings_statuses: ['To Do', 'In Progress'],
  settings_types: ['Bug', 'Feature'],
};

// Функция рендеринга, которая позволяет нам изменять начальный маршрут
const renderComponent = (initialEntry: string) => {
  return render(
    <MemoryRouter initialEntries={[initialEntry]}>
      <Routes>
        <Route path="/projects/:projectId/settings" element={<ProjectSettingsPage />} />
      </Routes>
    </MemoryRouter>
  );
};

describe('ProjectSettingsPage Container', () => {

  beforeEach(() => {
    vi.clearAllMocks();
    mockProjectService.getProjectSettings.mockResolvedValue(mockSettingsData);
  });

  const waitForLoadingToFinish = async () => {
    await waitFor(() => {
      expect(screen.queryByText(/loading project settings/i)).not.toBeInTheDocument();
    });
    await screen.findByRole('heading', { name: /Project Settings: Test Project/i });
  };

  test('renders loading state initially, then fetches data and renders default tab', async () => {
    renderComponent('/projects/1/settings');
    expect(screen.getByText(/loading project settings/i)).toBeInTheDocument();
    await waitForLoadingToFinish();
    
    // Проверяем, что по умолчанию отрендерилась вкладка General
    expect(screen.getByTestId('general-tab')).toBeInTheDocument();
    expect(screen.queryByTestId('members-tab')).not.toBeInTheDocument();
  });

  test('displays an error message if fetching settings fails', async () => {
    mockProjectService.getProjectSettings.mockRejectedValue(new Error('API Error'));
    renderComponent('/projects/1/settings');
    
    expect(await screen.findByText(/Failed to load project settings/i)).toBeInTheDocument();
  });

  test('renders the correct tab based on the "tab" search parameter', async () => {
    renderComponent('/projects/1/settings?tab=members');
    await waitForLoadingToFinish();
    
    // Проверяем, что отрендерилась вкладка Members
    expect(screen.getByTestId('members-tab')).toBeInTheDocument();
    expect(screen.queryByTestId('general-tab')).not.toBeInTheDocument();
  });

  test('changes the rendered tab when a sidebar link is clicked', async () => {
    const user = userEvent.setup();
    renderComponent('/projects/1/settings');
    await waitForLoadingToFinish();

    // Изначально видна вкладка General
    expect(screen.getByTestId('general-tab')).toBeInTheDocument();
    
    // Кликаем на ссылку Members
    const membersLink = screen.getByRole('link', { name: 'Members' });
    await user.click(membersLink);

    // Теперь должна быть видна вкладка Members
    await waitFor(() => {
        expect(screen.getByTestId('members-tab')).toBeInTheDocument();
    });
    expect(screen.queryByTestId('general-tab')).not.toBeInTheDocument();

    // Кликаем на ссылку Statuses
    const statusesLink = screen.getByRole('link', { name: 'Statuses' });
    await user.click(statusesLink);
    
    await waitFor(() => {
        expect(screen.getByTestId('statuses-tab')).toBeInTheDocument();
    });
    expect(screen.queryByTestId('members-tab')).not.toBeInTheDocument();
  });

  test('updates the page title when settings are changed in a child component', async () => {
    const user = userEvent.setup();
    renderComponent('/projects/1/settings');
    await waitForLoadingToFinish();
    
    // Начальный заголовок
    expect(screen.getByRole('heading', { name: /Project Settings: Test Project/i })).toBeInTheDocument();

    // Имитируем изменение в дочернем компоненте через мок
    const changeButton = within(screen.getByTestId('general-tab')).getByRole('button');
    await user.click(changeButton);

    // Проверяем, что заголовок обновился
    await waitFor(() => {
        expect(screen.getByRole('heading', { name: /Project Settings: new name/i })).toBeInTheDocument();
    });
  });
});

================================================
FILE: client/src/pages/ProjectSettingsPage.tsx
================================================
// client/src/pages/ProjectSettingsPage.tsx

import React, { useState, useEffect, useCallback } from 'react';
import { useParams, useSearchParams } from 'react-router-dom';
import { projectService } from '../shared/api/projectService'; // ### ИЗМЕНЕНИЕ: Исправлен путь ###
import type { ProjectSettingsResponse } from '../shared/api/types';
import GeneralSettingsTab from './ProjectSettings/GeneralSettingsTab';
import MembersSettingsTab from './ProjectSettings/MembersSettingsTab';
import StatusesSettingsTab from './ProjectSettings/StatusesSettingsTab';
import TypesSettingsTab from './ProjectSettings/TypesSettingsTab';
import styles from './ProjectSettingsPage.module.css';

const ProjectSettingsPage: React.FC = () => {
  const { projectId } = useParams<{ projectId: string }>();
  const [searchParams, setSearchParams] = useSearchParams();
  const activeTab = searchParams.get('tab') || 'general';

  const [settings, setSettings] = useState<ProjectSettingsResponse | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const numProjectId = Number(projectId);

  const fetchSettingsData = useCallback(async () => {
    if (isNaN(numProjectId)) {
        setError('Invalid Project ID.');
        setIsLoading(false);
        return;
    }
    setIsLoading(true);
    try {
        const settingsData = await projectService.getProjectSettings(numProjectId);
        setSettings(settingsData);
        setError(null);
    } catch (err: any) {
        console.error('Failed to fetch project settings:', err);
        setError(err.response?.data?.message || 'Failed to load project settings.');
    } finally {
        setIsLoading(false);
    }
  }, [numProjectId]);

  const handleSettingsChanged = (newName: string) => {
    if (settings) {
      setSettings({...settings, name: newName});
    }
  }

  useEffect(() => {
    fetchSettingsData();
  }, [fetchSettingsData]);

  const renderActiveTab = () => {
    if (!settings) return null;

    switch (activeTab) {
      case 'general':
        return <GeneralSettingsTab projectId={numProjectId} initialName={settings.name} initialPrefix={settings.prefix} onSettingsChanged={handleSettingsChanged} />;
      case 'statuses':
        return <StatusesSettingsTab projectId={numProjectId} initialStatuses={settings.settings_statuses || []} />;
      case 'types':
        return <TypesSettingsTab projectId={numProjectId} initialTypes={settings.settings_types || []} />;
      case 'members':
        return <MembersSettingsTab projectId={numProjectId} />;
      default:
        return <GeneralSettingsTab projectId={numProjectId} initialName={settings.name} initialPrefix={settings.prefix} onSettingsChanged={handleSettingsChanged} />;
    }
  };

  if (isLoading) return <div className={styles.loading}>Loading project settings...</div>;
  if (error || !settings) return <div className={styles.error}>{error || 'Project not found.'}</div>;
  
  return (
    <div>
      <h1>Project Settings: {settings.name}</h1>
      <div className={styles.settingsLayout}>
        <aside className={styles.sidebar}>
          <ul className={styles.sidebarNav}>
            <li className={styles.navItem}>
              <a href="#general" onClick={(e) => { e.preventDefault(); setSearchParams({ tab: 'general' }); }} className={activeTab === 'general' ? styles.active : ''}>General</a>
            </li>
            <li className={styles.navItem}>
              <a href="#statuses" onClick={(e) => { e.preventDefault(); setSearchParams({ tab: 'statuses' }); }} className={activeTab === 'statuses' ? styles.active : ''}>Statuses</a>
            </li>
            <li className={styles.navItem}>
              <a href="#types" onClick={(e) => { e.preventDefault(); setSearchParams({ tab: 'types' }); }} className={activeTab === 'types' ? styles.active : ''}>Types</a>
            </li>
            <li className={styles.navItem}>
              <a href="#members" onClick={(e) => { e.preventDefault(); setSearchParams({ tab: 'members' }); }} className={activeTab === 'members' ? styles.active : ''}>Members</a>
            </li>
          </ul>
        </aside>
        <main className={styles.contentArea}>
          {renderActiveTab()}
        </main>
      </div>
    </div>
  );
};

export default ProjectSettingsPage;

================================================
FILE: client/src/pages/ProjectSettings/StatusesSettingsTab.tsx
================================================
// client/src/pages/ProjectSettings/StatusesSettingsTab.tsx
import React, { useState, useEffect } from 'react';
import { projectService } from '../../shared/api/projectService';
import styles from '../ProjectSettingsPage.module.css';

interface StatusesSettingsTabProps {
  projectId: number;
  initialStatuses: string[];
}

const StatusesSettingsTab: React.FC<StatusesSettingsTabProps> = ({ projectId, initialStatuses }) => {
  const [statuses, setStatuses] = useState(initialStatuses);
  const [isSaving, setIsSaving] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);
  
  useEffect(() => {
    setStatuses(initialStatuses);
  }, [initialStatuses]);

  const handleListChange = (index: number, value: string) => {
    setStatuses(prevList => {
      const newList = [...prevList];
      newList[index] = value;
      return newList;
    });
  };

  const addListItem = () => setStatuses(prev => [...prev, '']);
  const removeListItem = (index: number) => setStatuses(prevList => prevList.filter((_, i) => i !== index));

  const handleSubmit = async (event: React.FormEvent) => {
    event.preventDefault();
    if (isSaving) return;

    setIsSaving(true);
    setError(null);
    setSuccess(null);

    const filteredStatuses = statuses.filter(s => s.trim() !== '');
    if (JSON.stringify(filteredStatuses) === JSON.stringify(initialStatuses)) {
      setError("No changes to save.");
      setIsSaving(false);
      return;
    }

    try {
      await projectService.updateProjectSettings(projectId, { statuses: filteredStatuses });
      setSuccess("Statuses saved successfully!");
    } catch (err: any) {
      setError(err.response?.data?.message || 'Failed to save statuses.');
    } finally {
      setIsSaving(false);
      setTimeout(() => setSuccess(null), 3000);
    }
  };

  return (
    <div>
      <h2>Task Statuses</h2>
      <form onSubmit={handleSubmit}>
        {error && <p className={styles.error}>{error}</p>}
        {success && <p className={`${styles.error} ${styles.success}`}>{success}</p>}
        <div className={styles.listEditor}>
          {statuses.map((status, index) => (
            <div key={index} className={styles.listItem}>
              <input type="text" value={status} onChange={(e) => handleListChange(index, e.target.value)} placeholder="Status name" />
              <button type="button" className={`${styles.button} danger`} onClick={() => removeListItem(index)}>Remove</button>
            </div>
          ))}
          <button type="button" className={`${styles.button} ${styles.addListItemButton}`} onClick={addListItem}>Add Status</button>
        </div>
        <button type="submit" className={`${styles.button} primary ${styles.submitButton}`} disabled={isSaving}>
          {isSaving ? 'Saving...' : 'Save Statuses'}
        </button>
      </form>
    </div>
  );
};

export default StatusesSettingsTab;

================================================
FILE: client/src/pages/ProjectSettings/TypesSettingsTab.tsx
================================================
// client/src/pages/ProjectSettings/TypesSettingsTab.tsx
import React, { useState, useEffect } from 'react';
import { projectService } from '../../shared/api/projectService';
import styles from '../ProjectSettingsPage.module.css';

interface TypesSettingsTabProps {
  projectId: number;
  initialTypes: string[];
}

const TypesSettingsTab: React.FC<TypesSettingsTabProps> = ({ projectId, initialTypes }) => {
  const [types, setTypes] = useState(initialTypes);
  const [isSaving, setIsSaving] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);

  useEffect(() => {
    setTypes(initialTypes);
  }, [initialTypes]);

  const handleListChange = (index: number, value: string) => {
    setTypes(prevList => {
      const newList = [...prevList];
      newList[index] = value;
      return newList;
    });
  };

  const addListItem = () => setTypes(prev => [...prev, '']);
  const removeListItem = (index: number) => setTypes(prevList => prevList.filter((_, i) => i !== index));

  const handleSubmit = async (event: React.FormEvent) => {
    event.preventDefault();
    if (isSaving) return;

    setIsSaving(true);
    setError(null);
    setSuccess(null);

    const filteredTypes = types.filter(t => t.trim() !== '');
    if (JSON.stringify(filteredTypes) === JSON.stringify(initialTypes)) {
      setError("No changes to save.");
      setIsSaving(false);
      return;
    }

    try {
      await projectService.updateProjectSettings(projectId, { types: filteredTypes });
      setSuccess("Task types saved successfully!");
    } catch (err: any) {
      setError(err.response?.data?.message || 'Failed to save task types.');
    } finally {
      setIsSaving(false);
      setTimeout(() => setSuccess(null), 3000);
    }
  };

  return (
    <div>
      <h2>Task Types</h2>
      <form onSubmit={handleSubmit}>
        {error && <p className={styles.error}>{error}</p>}
        {success && <p className={`${styles.error} ${styles.success}`}>{success}</p>}
        <div className={styles.listEditor}>
          {types.map((type, index) => (
            <div key={index} className={styles.listItem}>
              <input type="text" value={type} onChange={(e) => handleListChange(index, e.target.value)} placeholder="Type name" />
              <button type="button" className={`${styles.button} danger`} onClick={() => removeListItem(index)}>Remove</button>
            </div>
          ))}
          <button type="button" className={`${styles.button} ${styles.addListItemButton}`} onClick={addListItem}>Add Type</button>
        </div>
        <button type="submit" className={`${styles.button} primary ${styles.submitButton}`} disabled={isSaving}>
          {isSaving ? 'Saving...' : 'Save Types'}
        </button>
      </form>
    </div>
  );
};

export default TypesSettingsTab;

================================================
FILE: client/src/pages/RegistrationPage.tsx
================================================
import RegistrationForm from '../features/authByEmail/ui/RegistrationForm';

const RegistrationPage = () => {
  return (
    <div className="form-page-container">
      <h1>User Registration</h1>
      <RegistrationForm />
    </div>
  );
};

export default RegistrationPage;

================================================
FILE: client/src/pages/TaskPage.module.css
================================================
/* client/src/pages/TaskPage.module.css */
.pageContainer {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-large); /* Assuming --spacing-large is globally defined or replace if necessary */
  padding: var(--spacing-large); /* Assuming --spacing-large is globally defined or replace if necessary */
  max-width: 900px;
  margin: 0 auto;
  background-color: var(--background-color); /* Use main background color */
}

.taskContent {
  background-color: var(--card-background-color); /* Use theme card background */
  padding: var(--spacing-medium); /* Assuming --spacing-medium is globally defined */
  border-radius: var(--border-radius-medium); /* Assuming --border-radius-medium is globally defined */
  box-shadow: var(--shadow-element);
  color: var(--text-color); /* Default text color for content inside */
}

.taskTitle {
  font-size: 2em;
  color: var(--text-color); /* Use theme main text color */
  margin-bottom: var(--spacing-medium);
  border-bottom: 1px solid var(--border-color); /* Use theme border color */
  padding-bottom: var(--spacing-small);
}

.taskMeta {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: var(--spacing-medium);
  margin-bottom: var(--spacing-medium);
  font-size: 0.9em;
}
.taskMeta p {
  margin: 0;
  color: var(--text-secondary-color); /* Use theme secondary text color */
}
.taskMeta strong {
  color: var(--text-color); /* Use theme main text color for emphasis */
}

.taskDescription {
  margin-bottom: var(--spacing-medium);
}
.taskDescription h3 {
  font-size: 1.2em;
  color: var(--text-color); /* Use theme main text color */
  margin-bottom: var(--spacing-small);
}
.taskDescription p {
  line-height: 1.6;
  color: var(--text-secondary-color); /* Use theme secondary text color */
  white-space: pre-wrap;
}

.taskTags {
  margin-bottom: var(--spacing-medium);
}
.taskTags h3 {
  font-size: 1.2em;
  color: var(--text-color); /* Use theme main text color */
  margin-bottom: var(--spacing-small);
}
.tagsContainer {
  display: flex;
  flex-wrap: wrap;
  gap: var(--spacing-small);
}
.tagItem {
  background-color: var(--tag-background-color); /* Use theme tag background color */
  color: var(--tag-text-color); /* Use theme tag text color */
  padding: var(--spacing-base-small) var(--spacing-base);
  border-radius: var(--border-radius-small);
  font-size: 0.85em;
}

.commentsSection {
  background-color: var(--card-background-color); /* Use theme card background */
  padding: var(--spacing-medium);
  border-radius: var(--border-radius-medium);
  box-shadow: var(--shadow-element);
  color: var(--text-color); /* Default text color for content inside */
}
.commentsSection h2 {
  font-size: 1.5em;
  color: var(--text-color); /* Use theme main text color */
  margin-bottom: var(--spacing-medium);
  border-bottom: 1px solid var(--border-color); /* Use theme border color */
  padding-bottom: var(--spacing-small);
}

/* For loading and error states if you use .container for them */
.container {
  padding: var(--spacing-large);
  text-align: center;
  color: var(--text-color); /* Ensure container text is themeable */
}
.errorText {
  color: var(--danger-text-color); /* Use theme danger text color */
  font-weight: var(--font-weight-bold); /* Assuming --font-weight-bold is globally defined */
}


================================================
FILE: client/src/pages/TaskPage.tsx
================================================
// client/src/pages/TaskPage.tsx
import React, { useEffect, useState } from 'react';
import { useParams } from 'react-router-dom';
import { taskService } from '../shared/api/taskService';
// ### ИЗМЕНЕНИЕ: Импортируем типы из правильного места ###
import type { CommentDto } from '../shared/api/types';
import type { TaskDto } from '../shared/api/projectService';
import { CommentList, AddCommentForm } from '../features/Comments';
import styles from './TaskPage.module.css';

const TaskPage: React.FC = () => {
  // ### ИЗМЕНЕНИЕ: Получаем taskHid из URL
  const { taskHid } = useParams<{ taskHid: string }>();
  const [task, setTask] = useState<TaskDto | null>(null);
  const [comments, setComments] = useState<CommentDto[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchTaskDetails = async () => {
      if (!taskHid) return;
      setIsLoading(true);
      setError(null);
      try {
        // ### ИЗМЕНЕНИЕ: Вызываем правильный метод для получения задачи по HID
        const taskData = await taskService.getTaskByHumanId(taskHid);
        setTask(taskData);

        // ### ИЗМЕНЕНИЕ: Получаем комментарии после того, как получили задачу и ее UUID
        const commentsData = await taskService.getTaskComments(taskData.id);
        setComments(commentsData);

      } catch (err) {
        setError('Failed to load task details.');
        console.error(err);
      } finally {
        setIsLoading(false);
      }
    };

    fetchTaskDetails();
  }, [taskHid]);

  const handleCommentAdded = (newComment: CommentDto) => {
    setComments(prevComments =>
      [...prevComments, newComment].sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime())
    );
  };

  if (isLoading) {
    return <div className={styles.container}><p>Loading task details...</p></div>;
  }

  if (error) {
    return <div className={styles.container}><p className={styles.errorText}>{error}</p></div>;
  }

  if (!task) {
    return <div className={styles.container}><p>Task not found.</p></div>;
  }

  const formatDate = (dateString?: string | Date | null) => {
    if (!dateString) return 'Not set';
    return new Date(dateString).toLocaleDateString('en-US', {
      year: 'numeric', month: 'long', day: 'numeric', timeZone: 'UTC'
    });
  };

  return (
    <div className={styles.pageContainer}>
      <div className={styles.taskContent}>
        <h1 className={styles.taskTitle}>{task.human_readable_id}: {task.title}</h1>

        <div className={styles.taskMeta}>
          <p><strong>Priority:</strong> {task.priority || 'Not set'}</p>
          <p><strong>Type:</strong> {task.type || 'Not set'}</p>
          <p><strong>Due Date:</strong> {formatDate(task.due_date)}</p>
          <p><strong>Created At:</strong> {formatDate(task.created_at)}</p>
          <p><strong>Updated At:</strong> {formatDate(task.updated_at)}</p>
        </div>

        {task.description && (
          <div className={styles.taskDescription}>
            <h3>Description</h3>
            <p>{task.description}</p>
          </div>
        )}

        {task.tags && task.tags.length > 0 && (
          <div className={styles.taskTags}>
            <h3>Tags</h3>
            <div className={styles.tagsContainer}>
              {task.tags.map((tag: string) => <span key={tag} className={styles.tagItem}>{tag}</span>)}
            </div>
          </div>
        )}
      </div>

      <div className={styles.commentsSection}>
        <h2>Comments</h2>
        <CommentList comments={comments} />
        <AddCommentForm taskId={task.id} onCommentAdded={handleCommentAdded} />
      </div>
    </div>
  );
};

export default TaskPage;

================================================
FILE: client/src/pages/UserSettingsPage.module.css
================================================
.settingsPage {
  padding: 20px;
  max-width: 600px;
  margin: 0 auto;
}

.settingsPage h2 {
  margin-bottom: 20px;
  /* Uses --border-color for light theme and specific var for dark, if needed */
  border-bottom: 1px solid var(--border-color);
  padding-bottom: 10px;
}

.themeSettings {
  margin-bottom: 30px;
}

.themeSettings h3 {
  margin-bottom: 10px;
}

.radioGroup label {
  display: block;
  margin-bottom: 8px;
  cursor: pointer;
}

.radioGroup input[type="radio"] {
  margin-right: 8px;
}

/* Add some basic styling for light and dark themes for the page itself */
/* These would ideally be part of a global stylesheet or more comprehensive theming solution */
[data-theme="light"] .settingsPage {
  background-color: #ffffff;
  color: #333333;
}

[data-theme="dark"] .settingsPage {
  background-color: #333333;
  color: #ffffff;
}

[data-theme="dark"] .settingsPage h2 {
  border-bottom-color: var(--settings-page-h2-border-color); /* Use CSS variable */
}

/* Example of how variables from global.css might be used */
/* Ensure --border-color is defined in your global styles */
/*
:root {
  --border-color: #e0e0e0;
}

[data-theme="dark"] {
  --border-color: #555555;
}
*/


================================================
FILE: client/src/pages/UserSettingsPage.tsx
================================================
import React from 'react';
import { useTheme, type ThemeOption } from '../shared/contexts/ThemeContext';
import styles from './UserSettingsPage.module.css'; // We'll create this CSS module next

const themeOptionsConfig: { value: ThemeOption; label: string }[] = [
  { value: 'system', label: 'System' },
  { value: 'light', label: 'Light' },
  { value: 'dark', label: 'Dark' },
];

const UserSettingsPage: React.FC = () => {
  const { themeOption, setThemeOption, effectiveTheme } = useTheme();

  const handleThemeChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    setThemeOption(event.target.value as ThemeOption);
  };

  return (
    <div className={styles.settingsPage}>
      <h2>User Settings</h2>
      <section className={styles.themeSettings}>
        <h3>Theme</h3>
        <p>Current effective theme: {effectiveTheme}</p>
        <div className={styles.radioGroup}>
          {themeOptionsConfig.map((option) => (
            <label key={option.value}>
              <input
                type="radio"
                name="theme"
                value={option.value}
                checked={themeOption === option.value}
                onChange={handleThemeChange}
              />
              {option.label}
            </label>
          ))}
        </div>
      </section>
    </div>
  );
};

export default UserSettingsPage;


================================================
FILE: client/src/setupTests.ts
================================================
// Import Jest DOM matchers like expect(...).toBeInTheDocument()
import '@testing-library/jest-dom';


================================================
FILE: client/src/shared/api/axiosInstance.ts
================================================
import axios from 'axios';

const API_BASE_URL = `${import.meta.env.VITE_API_URL || 'http://localhost:3001'}/api/v1`;

const axiosInstance = axios.create({
  baseURL: API_BASE_URL,
});

axiosInstance.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('authToken');
    if (token) {
      config.headers['Authorization'] = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// ### ИЗМЕНЕНИЕ: Логика обработки 401 ошибки ###
axiosInstance.interceptors.response.use(
  (response) => {
    return response;
  },
  (error) => {
    // Если получена ошибка 401
    if (error.response && error.response.status === 401) {
      // Проверяем, был ли токен в localStorage.
      // Это предотвращает срабатывание при обычном 401 (например, на странице логина),
      // и реагирует только на невалидный/просроченный токен.
      if (localStorage.getItem('authToken')) {
        // Удаляем невалидный токен
        localStorage.removeItem('authToken');
        // Генерируем глобальное событие, на которое подпишется AuthContext
        window.dispatchEvent(new Event('auth-error'));
        console.error('Unauthorized access - 401. Token might be invalid or expired. Dispatched auth-error event.');
      }
    }
    return Promise.reject(error);
  }
);

export default axiosInstance;

================================================
FILE: client/src/shared/api/notificationService.ts
================================================
// client/src/shared/api/notificationService.ts
import apiClient from './axiosInstance';

export interface NotificationDto {
  id: string;
  text: string;
  isRead: boolean;
  recipientId: string;
  sourceUrl?: string | null;
  taskId?: string | null;
  createdAt: string; // Assuming ISO string
  updatedAt: string;
}

export const notificationService = {
  getUserNotifications: async (): Promise<NotificationDto[]> => {
    const response = await apiClient.get<NotificationDto[]>('/notifications');
    return response.data;
  },

  markNotificationAsRead: async (notificationId: string): Promise<NotificationDto> => {
    const response = await apiClient.patch<NotificationDto>(`/notifications/${notificationId}/read`);
    return response.data;
  },

  markAllNotificationsAsRead: async (): Promise<{ message: string }> => {
    // Backend controller uses POST for this route
    const response = await apiClient.post<{ message: string }>('/notifications/mark-all-read');
    return response.data;
  },
};


================================================
FILE: client/src/shared/api/projectService.ts
================================================
// client/src/shared/api/projectService.ts

import apiClient from './axiosInstance';
import type { 
  ProjectSettingsResponse, 
  UpdateProjectSettingsPayload, 
  AllParticipantsDto, 
  UpdateMemberRoleDto,
  AddMemberDto,
  CreateProjectDto,
  FullProjectDto,
  ProjectListDto,
} from './types';

// Экспортируем типы, которые могут понадобиться в других местах UI (например, на страницах)
export type { 
  TaskDto, 
  ColumnDto, 
  FullProjectDto, 
  ProjectListDto,
  CreateProjectDto,
  AllParticipantsDto,
  AddMemberDto,
} from './types';


export const projectService = {
  createProject: async (data: CreateProjectDto): Promise<FullProjectDto> => {
    const response = await apiClient.post<FullProjectDto>('/projects', data);
    return response.data;
  },

  getUserProjects: async (): Promise<ProjectListDto[]> => {
    const response = await apiClient.get<ProjectListDto[]>('/projects');
    return response.data;
  },

  getProjectById: async (projectId: number): Promise<FullProjectDto> => {
    const response = await apiClient.get<FullProjectDto>(`/projects/${projectId}`);
    return response.data;
  },

  addProjectMember: async (projectId: number, data: AddMemberDto): Promise<AllParticipantsDto> => {
    const response = await apiClient.post<AllParticipantsDto>(`/projects/${projectId}/members`, data);
    return response.data;
  },
  
  getAllProjectParticipants: async (projectId: number): Promise<AllParticipantsDto[]> => {
    const response = await apiClient.get<AllParticipantsDto[]>(`/projects/${projectId}/members`);
    return response.data;
  },

  updateProjectMember: async (projectId: number, userId: string, data: UpdateMemberRoleDto): Promise<AllParticipantsDto> => {
    const response = await apiClient.patch<AllParticipantsDto>(`/projects/${projectId}/members/${userId}`, data);
    return response.data;
  },
  
  removeProjectMember: async (projectId: number, userId: string): Promise<void> => {
    await apiClient.delete(`/projects/${projectId}/members/${userId}`);
  },

  getProjectSettings: async (projectId: number): Promise<ProjectSettingsResponse> => {
    const response = await apiClient.get<ProjectSettingsResponse>(`/projects/${projectId}/settings`);
    return response.data;
  },

  updateProjectSettings: async (projectId: number, data: UpdateProjectSettingsPayload): Promise<ProjectSettingsResponse> => {
    const response = await apiClient.put<ProjectSettingsResponse>(`/projects/${projectId}/settings`, data);
    return response.data;
  },
};

================================================
FILE: client/src/shared/api/taskService.ts
================================================
// client/src/shared/api/taskService.ts

import apiClient from './axiosInstance';
// ### ИЗМЕНЕНИЕ: Импортируем все DTO из types.ts ###
import type { 
  TaskDto as FullTaskDto, 
  CreateTaskDto,
  UpdateTaskDto,
  MoveTaskDto,
  ApiCommentDto,
  CommentDto,
  CreateCommentPayloadDto,
} from './types'; 

// ### ИЗМЕНЕНИЕ: Все локальные определения DTO удалены ###

// Хелпер для трансформации остается здесь, так как это логика сервиса
export const transformCommentDto = (apiComment: ApiCommentDto): CommentDto => ({
  ...apiComment,
  taskId: apiComment.task_id,
  authorId: apiComment.author_id,
  createdAt: new Date(apiComment.created_at),
  updatedAt: new Date(apiComment.updated_at),
});

export const taskService = {
  createTask: async (projectId: number, data: CreateTaskDto): Promise<FullTaskDto> => {
    const response = await apiClient.post<FullTaskDto>(`/projects/${projectId}/tasks`, data);
    return response.data;
  },

  moveTask: async (taskId: string, data: MoveTaskDto): Promise<FullTaskDto> => {
    const response = await apiClient.patch<FullTaskDto>(`/tasks/${taskId}/move`, data);
    return response.data;
  },

  updateTask: async (taskId: string, data: UpdateTaskDto): Promise<FullTaskDto> => {
    const response = await apiClient.patch<FullTaskDto>(`/tasks/${taskId}`, data);
    return response.data;
  },

  getTaskComments: async (taskId: string): Promise<CommentDto[]> => {
    const response = await apiClient.get<ApiCommentDto[]>(`/tasks/${taskId}/comments`);
    return response.data.map(transformCommentDto);
  },

  addTaskComment: async (taskId: string, data: CreateCommentPayloadDto): Promise<CommentDto> => {
    const response = await apiClient.post<ApiCommentDto>(`/tasks/${taskId}/comments`, data);
    return transformCommentDto(response.data);
  },

  getTaskByHumanId: async (humanReadableId: string): Promise<FullTaskDto> => {
    const response = await apiClient.get<FullTaskDto>(`/tasks/${humanReadableId}`);
    return response.data;
  },
};

================================================
FILE: client/src/shared/api/types.ts
================================================
// client/src/shared/api/types.ts

// --- Типы для Проектов и Участников ---

export interface ProjectSettingsResponse {
  id: number;
  name: string;
  prefix: string;
  settings_statuses?: string[];
  settings_types?: string[];
}

export interface UpdateProjectSettingsPayload {
  name?: string;
  prefix?: string;
  statuses?: string[];
  types?: string[];
}

export interface AllParticipantsDto {
  id: string;
  name: string | null;
  email: string;
  role: string;
}

export interface UpdateMemberRoleDto {
  role: 'editor' | 'viewer';
}

export interface AddMemberDto {
  email: string;
  role: 'editor' | 'viewer';
}

export interface ProjectListDto {
  id: number;
  name: string;
  task_prefix: string;
  owner_id: string;
  created_at: string;
  updated_at: string;
}

export interface CreateProjectDto {
  name: string;
  prefix: string;
}

export interface FullProjectDto extends ProjectListDto {
  columns?: ColumnDto[];
  tasks?: TaskDto[];
  settings_statuses?: string[];
  settings_types?: string[];
}


// --- Типы для Задач и Колонок ---

export interface TaskDto {
  id: string;
  human_readable_id: string; 
  title: string;
  description?: string | null;
  position: number;
  project_id: number;
  column_id: string;
  assignee_id?: string | null;
  creator_id: string;
  due_date?: string | null;
  type?: string | null;
  priority?: string | null;
  tags?: string[] | null;
  created_at: string;
  updated_at: string;
}

export interface CreateTaskDto {
  title: string;
  description?: string;
  columnId: string;
  assigneeId?: string;
  dueDate?: string;
  type?: string;
  priority?: string;
  tags?: string[];
}

// ### НОВОЕ: Типы для обновления и перемещения задачи перенесены сюда ###
export interface UpdateTaskDto {
  title?: string;
  description?: string | null;
  assigneeId?: string | null;
  dueDate?: string | null;
  type?: string | null;
  priority?: string | null;
  tags?: string[] | null;
}

export interface MoveTaskDto {
  newColumnId: string;
  newPosition: number;
}


export interface ColumnDto {
  id: string;
  name: string;
  position: number;
  project_id: number;
  tasks?: TaskDto[];
  created_at: string;
  updated_at: string;
}

// --- Типы для Комментариев ---
export interface CommentAuthorDto {
  id: string;
  name?: string | null;
  email: string;
}

export interface ApiCommentDto {
  id: string;
  text: string;
  task_id: string;
  author_id: string | null;
  created_at: string;
  updated_at: string;
  author?: CommentAuthorDto | null;
}

export interface CommentDto {
  id: string;
  text: string;
  taskId: string;
  authorId: string | null;
  createdAt: Date;
  updatedAt: Date;
  author?: CommentAuthorDto | null;
}

export interface CreateCommentPayloadDto {
  text: string;
}


// --- Общие типы ---

export interface ApiError {
  message: string;
  statusCode?: number;
  error?: string;
}

================================================
FILE: client/src/shared/contexts/AddTaskModalContext.tsx
================================================
import { createContext, useContext } from 'react';

interface AddTaskModalContextType {
  isModalOpen: boolean;
  openModal: () => void;
  closeModal: () => void;
}

export const AddTaskModalContext = createContext<AddTaskModalContextType | undefined>(undefined);

export const useAddTaskModal = () => {
  const context = useContext(AddTaskModalContext);
  if (!context) {
    throw new Error('useAddTaskModal must be used within an AddTaskModalProvider');
  }
  return context;
};

================================================
FILE: client/src/shared/contexts/ThemeContext.tsx
================================================
import React, { createContext, useState, useContext, useEffect, useCallback } from 'react';
import type { ReactNode } from 'react';

export type ThemeOption = 'system' | 'light' | 'dark';
type Theme = 'light' | 'dark';

interface ThemeContextType {
  themeOption: ThemeOption;
  setThemeOption: (themeOption: ThemeOption) => void;
  effectiveTheme: Theme; // To be used by components for styling
}

const ThemeContext = createContext<ThemeContextType | null>(null);

// Custom hook to manage theme setup
const useThemeSetup = (effectiveTheme: Theme) => {
  useEffect(() => {
    document.documentElement.setAttribute('data-theme', effectiveTheme);
  }, [effectiveTheme]);
};

const THEME_STORAGE_KEY = 'themeOption';

export const ThemeProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [themeOption, setThemeOption] = useState<ThemeOption>(() => {
    const storedTheme = localStorage.getItem(THEME_STORAGE_KEY);
    return (storedTheme as ThemeOption) || 'system'; // Default to 'system' if nothing is stored
  });
  const [effectiveTheme, setEffectiveTheme] = useState<Theme>('light');

  const applyTheme = useCallback(() => {
    if (themeOption === 'system') {
      const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      setEffectiveTheme(systemPrefersDark ? 'dark' : 'light');
    } else {
      setEffectiveTheme(themeOption);
    }
  }, [themeOption]);

  useEffect(() => {
    applyTheme();
    // Listen for changes in system preference if 'system' is selected
    if (themeOption === 'system') {
      const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
      mediaQuery.addEventListener('change', applyTheme);
      return () => mediaQuery.removeEventListener('change', applyTheme);
    }
  }, [themeOption, applyTheme]);

  useThemeSetup(effectiveTheme); // Apply theme to documentElement

  const handleSetThemeOption = (newThemeOption: ThemeOption) => {
    localStorage.setItem(THEME_STORAGE_KEY, newThemeOption);
    setThemeOption(newThemeOption);
  };

  return (
    <ThemeContext.Provider value={{ themeOption, setThemeOption: handleSetThemeOption, effectiveTheme }}>
      {children}
    </ThemeContext.Provider>
  );
};

export const useTheme = (): ThemeContextType => {
  const context = useContext(ThemeContext);
  if (context === null) {
    throw new Error('useTheme must be used within a ThemeProvider. Make sure a ThemeProvider wraps your component.');
  }
  return context;
};


================================================
FILE: client/src/shared/lib/socket.ts
================================================
import { io, Socket } from 'socket.io-client';

const SOCKET_URL = import.meta.env.VITE_SOCKET_URL || 'http://localhost:3001'; // Ensure backend URL is correct

export const socket: Socket = io(SOCKET_URL, {
  autoConnect: false, // Connect manually when needed, e.g., when a user enters a board
  // transports: ['websocket'], // Optional: force websocket transport
});

// Optional: Add logging for socket events for debugging
socket.on('connect', () => {
  console.log('Socket connected:', socket.id);
});

socket.on('disconnect', (reason) => {
  console.log('Socket disconnected:', reason);
});

socket.on('connect_error', (error) => {
  console.error('Socket connection error:', error);
});

// Function to join a project room
export const joinProjectRoom = (projectId: string) => {
  if (socket.connected) {
    socket.emit('joinProjectRoom', projectId);
    console.log(`Attempted to join project room: ${projectId}`);
  } else {
    console.warn('Socket not connected, cannot join room. Attempting to connect...');
    // Attempt to connect if not connected, then join
    socket.connect();
    socket.once('connect', () => {
        console.log('Socket reconnected, joining room:', projectId);
        socket.emit('joinProjectRoom', projectId);
    });
  }
};

// Function to leave a project room
export const leaveProjectRoom = (projectId: string) => {
  if (socket.connected) {
    socket.emit('leaveProjectRoom', projectId);
    console.log(`Attempted to leave project room: ${projectId}`);
  } else {
    console.warn('Socket not connected, cannot leave room.');
  }
};

export const joinUserRoom = (userId: string) => {
  if (socket.connected) {
    socket.emit('joinUserRoom', userId);
    console.log(`Attempted to join user room: user:${userId}`);
  } else {
    // Queue or handle error: socket not connected when trying to join room
    console.warn('Socket not connected. Cannot join user room immediately.');
    // Could use socket.once('connect', () => socket.emit('joinUserRoom', userId));
    // Or, if connect is called elsewhere, rely on onConnect handler in NotificationBell
  }
};
// No need for leaveUserRoom for now based on current gateway setup


================================================
FILE: client/src/shared/ui/index.ts
================================================
export * from './Modal';


================================================
FILE: client/src/shared/ui/Modal/index.ts
================================================
export { default as Modal } from './Modal';


================================================
FILE: client/src/shared/ui/Modal/Modal.module.css
================================================
.backdrop {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: var(--backdrop-color, rgba(0, 0, 0, 0.5));
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.modalContent {
  background: var(--modal-background-color, white);
  color: var(--modal-text-color, black);
  padding: 20px;
  border-radius: 8px;
  box-shadow: var(--shadow-modal, 0 4px 6px rgba(0, 0, 0, 0.1));
  min-width: 300px;
  max-width: 90%;
  max-height: 90vh;
  overflow-y: auto;
  position: relative;
}

.modalHeader {
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-bottom: 1px solid var(--border-color, #eee);
  padding-bottom: 10px;
  margin-bottom: 20px;
}

.modalTitle {
  margin: 0;
  font-size: 1.25rem;
  color: inherit;
}

.closeButton {
  background: none;
  border: none;
  font-size: 1.5rem;
  cursor: pointer;
  padding: 0;
  line-height: 1;
  color: inherit;
}

.modalBody {
  /* Styles for the modal body if needed */
}

================================================
FILE: client/src/shared/ui/Modal/Modal.spec.tsx
================================================
import React from 'react';
import { render, screen, fireEvent, cleanup } from '@testing-library/react';
import '@testing-library/jest-dom';
import { vi } from 'vitest';
import Modal from './Modal';

describe('Modal Component', () => {
  const mockOnClose = vi.fn();
  const modalTitle = 'Test Modal Title';
  const modalChildText = 'This is the modal content.';

  beforeEach(() => {
    mockOnClose.mockClear();
  });

  afterEach(() => {
    cleanup(); // Clean up DOM after each test
  });

  test('renders null when isOpen is false', () => {
    const { container } = render(
      <Modal isOpen={false} onClose={mockOnClose} title={modalTitle}>
        <p>{modalChildText}</p>
      </Modal>
    );
    expect(screen.queryByRole('dialog')).not.toBeInTheDocument();
    expect(screen.queryByText(modalTitle)).not.toBeInTheDocument();
    expect(container.firstChild).toBeNull();
  });

  test('renders correctly with title and children when isOpen is true', () => {
    render(
      <Modal isOpen={true} onClose={mockOnClose} title={modalTitle}>
        <p>{modalChildText}</p>
      </Modal>
    );
    expect(screen.getByRole('dialog', { name: modalTitle })).toBeVisible();
    expect(screen.getByText(modalChildText)).toBeVisible();
    expect(screen.getByRole('button', { name: /close modal/i })).toBeVisible();
  });

  test('renders correctly without title when isOpen is true', () => {
    render(
      <Modal isOpen={true} onClose={mockOnClose}>
        <p>{modalChildText}</p>
      </Modal>
    );
    expect(screen.getByRole('dialog')).toBeVisible();
    expect(screen.queryByText(modalTitle)).not.toBeInTheDocument();
    expect(screen.getByText(modalChildText)).toBeVisible();
  });


  test('calls onClose when the close button is clicked', () => {
    render(
      <Modal isOpen={true} onClose={mockOnClose} title={modalTitle}>
        <p>{modalChildText}</p>
      </Modal>
    );
    fireEvent.click(screen.getByRole('button', { name: /close modal/i }));
    expect(mockOnClose).toHaveBeenCalledTimes(1);
  });

  test('calls onClose when the backdrop is clicked', () => {
    render(
      <Modal isOpen={true} onClose={mockOnClose} title={modalTitle}>
        <p>{modalChildText}</p>
      </Modal>
    );
    const dialogElement = screen.getByRole('dialog', { name: modalTitle });
    if (dialogElement.parentElement) {
      fireEvent.click(dialogElement.parentElement);
    } else {
      throw new Error("Dialog parent element (backdrop) not found");
    }
    expect(mockOnClose).toHaveBeenCalledTimes(1);
  });

  test('does not call onClose when the modal content (dialog itself) is clicked', () => {
    render(
      <Modal isOpen={true} onClose={mockOnClose} title={modalTitle}>
        <p>{modalChildText}</p>
      </Modal>
    );
    fireEvent.click(screen.getByRole('dialog', { name: modalTitle }));
    expect(mockOnClose).not.toHaveBeenCalled();
  });

  test('does not call onClose when a child element within modal content is clicked', () => {
    render(
      <Modal isOpen={true} onClose={mockOnClose} title={modalTitle}>
        <p>{modalChildText}</p>
      </Modal>
    );
    fireEvent.click(screen.getByText(modalChildText));
    expect(mockOnClose).not.toHaveBeenCalled();
  });

  test('calls onClose when the Escape key is pressed', () => {
    render(
      <Modal isOpen={true} onClose={mockOnClose} title={modalTitle}>
        <p>{modalChildText}</p>
      </Modal>
    );
    fireEvent.keyDown(document, { key: 'Escape', code: 'Escape' });
    expect(mockOnClose).toHaveBeenCalledTimes(1);
  });

  test('renders children correctly', () => {
    render(
      <Modal isOpen={true} onClose={mockOnClose} title={modalTitle}>
        <div>
          <span>{modalChildText}</span>
          <button>Another Action</button>
        </div>
      </Modal>
    );
    expect(screen.getByText(modalChildText)).toBeInTheDocument();
    expect(screen.getByRole('button', { name: 'Another Action' })).toBeInTheDocument();
  });

  test('manages document event listener for Escape key correctly', () => {
    const addEventListenerSpy = vi.spyOn(document, 'addEventListener');
    const removeEventListenerSpy = vi.spyOn(document, 'removeEventListener');

    const { rerender, unmount } = render( // Use unmount from render
      <Modal isOpen={true} onClose={mockOnClose} title="Esc Test">
        Content
      </Modal>
    );
    expect(addEventListenerSpy).toHaveBeenCalledWith('keydown', expect.any(Function));

    const escapeKeyHandler = addEventListenerSpy.mock.calls.find(call => call[0] === 'keydown')[1];

    rerender(
      <Modal isOpen={false} onClose={mockOnClose} title="Esc Test">
        Content
      </Modal>
    );
    expect(removeEventListenerSpy).toHaveBeenCalledWith('keydown', escapeKeyHandler);

    rerender(
      <Modal isOpen={true} onClose={mockOnClose} title="Esc Test">
        Content
      </Modal>
    );
    expect(addEventListenerSpy).toHaveBeenCalledWith('keydown', expect.any(Function));
    const newEscapeKeyHandler = addEventListenerSpy.mock.calls.reverse().find(call => call[0] === 'keydown')[1];

    unmount(); // Call unmount
    expect(removeEventListenerSpy).toHaveBeenCalledWith('keydown', newEscapeKeyHandler);

    addEventListenerSpy.mockRestore();
    removeEventListenerSpy.mockRestore();
  });
});


================================================
FILE: client/src/shared/ui/Modal/Modal.tsx
================================================
import React, { useEffect } from 'react';
import styles from './Modal.module.css';

interface ModalProps {
  isOpen: boolean;
  onClose: () => void;
  title?: string;
  children: React.ReactNode;
}

const Modal: React.FC<ModalProps> = ({ isOpen, onClose, title, children }) => {
  useEffect(() => {
    const handleEscKey = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        onClose();
      }
    };

    if (isOpen) {
      document.addEventListener('keydown', handleEscKey);
    }

    return () => {
      document.removeEventListener('keydown', handleEscKey);
    };
  }, [isOpen, onClose]);

  if (!isOpen) {
    return null;
  }

  return (
    <div className={styles.backdrop} onClick={onClose}>
      <div className={styles.modalContent} onClick={(e) => e.stopPropagation()} role="dialog" aria-modal="true" aria-labelledby={title ? "modal-title-id" : undefined}>
        <header className={styles.modalHeader}>
          {title && <h2 className={styles.modalTitle} id="modal-title-id">{title}</h2>}
          <button onClick={onClose} className={styles.closeButton} aria-label="Close modal">
            &times;
          </button>
        </header>
        <div className={styles.modalBody}>
          {children}
        </div>
      </div>
    </div>
  );
};

export default Modal;


================================================
FILE: client/src/vite-env.d.ts
================================================
/// <reference types="vite/client" />


================================================
FILE: client/src/widgets/Header/Header.module.css
================================================
.header {
  background-color: var(--header-background-color);
  padding: 0 calc(var(--spacing-base) * 3); /* 0 24px */
  border-bottom: 1px solid var(--border-color);
  box-shadow: var(--shadow-sm);
}

.headerContainer {
  display: flex;
  justify-content: space-between;
  align-items: center;
  height: calc(var(--spacing-base) * 8); /* 64px */
  max-width: calc(var(--spacing-base) * 150); /* 1200px */
  margin: 0 auto; /* Center header content */
}

.logo {
  font-size: 24px;
  font-weight: 600;
  color: var(--primary-color);
  text-decoration: none;
}

.logo:hover {
  text-decoration: none; /* Ensure no underline on hover for logo */
  color: var(--link-hover-color); /* Use link hover color */
}

.navigation ul {
  list-style: none;
  margin: 0;
  padding: 0;
  display: flex;
  align-items: center;
}

.navigation li {
  margin-left: calc(var(--spacing-base) * 3); /* 24px */
}

.navigation a,
.navigation button { /* For LogoutButton styling consistency */
  text-decoration: none;
  color: var(--header-text-color); /* Use header specific text color */
  font-weight: 400;
  padding: calc(var(--spacing-base) * 0.5) calc(var(--spacing-base) * 1); /* 4px 8px */
  border-radius: var(--border-radius-medium); /* Using defined variable */
  transition: color 0.2s ease-in-out, background-color 0.2s ease-in-out;
}

.navigation a:hover,
.navigation button:not(.secondary):hover { /* Apply hover to general buttons, not specifically styled secondary ones */
  color: var(--link-hover-color); /* Use link hover color for text */
  background-color: var(--element-hover-background-color); /* Subtle background for hover */
}

/* Style for active link if needed, requires NavLink from react-router-dom */
.navigation a.active {
  color: var(--primary-color);
  font-weight: 700;
}

/* Ensure LogoutButton integrates well */
.navigation button {
  background-color: transparent; /* Default for link-like buttons */
  border: none;
  cursor: pointer;
}

/* Styling for a button that should look like a secondary action button */
.navigation button.secondary {
    color: var(--button-secondary-text-color);
    background-color: var(--button-secondary-background-color);
    border: 1px solid var(--button-secondary-border-color);
    /* padding will be inherited from .navigation button */
}

.navigation button.secondary:hover {
    color: var(--button-secondary-text-color); /* Text color might not change or could be defined in theme */
    background-color: var(--button-secondary-hover-background-color);
    border-color: var(--button-secondary-hover-background-color); /* Or a specific hover border color */
}


================================================
FILE: client/src/widgets/Header/Header.spec.tsx
================================================
import { render, screen } from '@testing-library/react';
import { MemoryRouter } from 'react-router-dom';
import Header from './Header';
import { useAuth, AuthenticatedUser } from '../../app/auth/AuthContext';
import { useAddTaskModal } from '../../shared/contexts/AddTaskModalContext';

// Mock hooks
vi.mock('../../app/auth/AuthContext');
vi.mock('../../shared/contexts/AddTaskModalContext');

// Mock child components
vi.mock('../../features/Notifications', () => ({
  NotificationBell: () => <div data-testid="notification-bell">NotificationBell</div>,
}));
vi.mock('../../features/authByEmail/ui/LogoutButton', () => ({
  default: () => <button>Logout</button>,
}));

describe('Header Component', () => {
  const mockUseAuth = useAuth as vi.Mock;
  const mockUseAddTaskModal = useAddTaskModal as vi.Mock;

  beforeEach(() => {
    mockUseAddTaskModal.mockReturnValue({ openModal: vi.fn() });
  });

  afterEach(() => {
    vi.clearAllMocks();
  });

  describe('Authenticated User', () => {
    const mockUser: AuthenticatedUser = { id: '1', name: 'Test User', email: 'test@example.com' };
    beforeEach(() => {
      mockUseAuth.mockReturnValue({
        isAuthenticated: true,
        isLoading: false,
        user: mockUser,
      });
      render(
        <MemoryRouter initialEntries={['/dashboard']}>
          <Header />
        </MemoryRouter>
      );
    });

    it('should display Dashboard link', () => {
      expect(screen.getByRole('link', { name: /Dashboard/i })).toBeInTheDocument();
    });

    it('should display welcome message with user name', () => {
      expect(screen.getByText(/Welcome, Test User/i)).toBeInTheDocument();
    });

    it('should display NotificationBell', () => {
      expect(screen.getByTestId('notification-bell')).toBeInTheDocument();
    });

    it('should display LogoutButton', () => {
      expect(screen.getByRole('button', { name: /Logout/i })).toBeInTheDocument();
    });

    it('should NOT display Login link', () => {
      expect(screen.queryByRole('link', { name: /Login/i })).not.toBeInTheDocument();
    });

    it('should NOT display Register link', () => {
      expect(screen.queryByRole('link', { name: /Register/i })).not.toBeInTheDocument();
    });
  });

  describe('Authenticated User (displays email if name is not available)', () => {
    beforeEach(() => {
      const mockUserWithoutName: AuthenticatedUser = { id: '1', email: 'test@example.com' };
      mockUseAuth.mockReturnValue({
        isAuthenticated: true,
        isLoading: false,
        user: mockUserWithoutName,
      });
      render(
        <MemoryRouter>
          <Header />
        </MemoryRouter>
      );
    });
    it('should display welcome message with user email if name is not available', () => {
      expect(screen.getByText(/Welcome, test@example.com/i)).toBeInTheDocument();
    });
  });

  describe('Unauthenticated User', () => {
    beforeEach(() => {
      mockUseAuth.mockReturnValue({
        isAuthenticated: false,
        isLoading: false,
        user: null,
      });
      render(
        <MemoryRouter>
          <Header />
        </MemoryRouter>
      );
    });

    it('should display Home link', () => {
      expect(screen.getByRole('link', { name: /Home/i })).toBeInTheDocument();
    });

    it('should display Login link', () => {
      expect(screen.getByRole('link', { name: /Login/i })).toBeInTheDocument();
    });

    it('should display Register link', () => {
      expect(screen.getByRole('link', { name: /Register/i })).toBeInTheDocument();
    });

    it('should NOT display welcome message', () => {
      expect(screen.queryByText(/Welcome,/i)).not.toBeInTheDocument();
    });

    it('should NOT display NotificationBell', () => {
      expect(screen.queryByTestId('notification-bell')).not.toBeInTheDocument();
    });

    it('should NOT display LogoutButton', () => {
      expect(screen.queryByRole('button', { name: /Logout/i })).not.toBeInTheDocument();
    });
  });

  describe('Loading State', () => {
    it('should display loading message when isLoading is true', () => {
      mockUseAuth.mockReturnValue({
        isAuthenticated: false,
        isLoading: true,
        user: null,
      });
      render(
        <MemoryRouter>
          <Header />
        </MemoryRouter>
      );
      expect(screen.getByText(/Loading\.\.\./i)).toBeInTheDocument();
    });
  });
});

================================================
FILE: client/src/widgets/Header/Header.tsx
================================================
import { Link, NavLink, useLocation } from 'react-router-dom';
import { useAuth } from '../../app/auth/AuthContext';
import LogoutButton from '../../features/authByEmail/ui/LogoutButton';
import { NotificationBell } from '../../features/Notifications';
// ThemeSwitcher is removed as its functionality will be on the UserSettingsPage
import styles from './Header.module.css';
import { useAddTaskModal } from '../../shared/contexts/AddTaskModalContext';

const Header: React.FC = () => {
  const { isAuthenticated, isLoading, user } = useAuth();
  const { openModal } = useAddTaskModal();
  const location = useLocation();

  // Show "+ Add Task" button only on the board page
  const showAddTaskButton = isAuthenticated && location.pathname.startsWith('/projects/');

  return (
    <header className={styles.header}>
      <div className={styles.headerContainer}>
        <Link to="/" className={styles.logo}>
          Mutabor
        </Link>
        <nav className={styles.navigation}>
          <ul>
            {isLoading ? (
              <li>Loading...</li>
            ) : isAuthenticated && user ? (
              <>
                <li>
                  <NavLink to="/dashboard" className={({ isActive }) => isActive ? styles.active : ''}>Dashboard</NavLink>
                </li>
                {showAddTaskButton && (
                  <li>
                    <button onClick={openModal} className={styles.addTaskButtonHeader}>
                      + Add Task
                    </button>
                  </li>
                )}
                <li className={styles.welcomeMessage}>
                  <span>Welcome, {user.name || user.email}</span>
                </li>
                <li>
                  <NotificationBell />
                </li>
                <li>
                  <NavLink to="/settings" className={({ isActive }) => isActive ? styles.active : ''}>Settings</NavLink>
                </li>
                {/* ThemeSwitcher component removed from here */}
                <li>
                  <LogoutButton />
                </li>
              </>
            ) : (
              <>
                <li>
                  <NavLink to="/" className={({ isActive }) => isActive ? styles.active : ''}>Home</NavLink>
                </li>
                <li>
                  <NavLink to="/register" className={({ isActive }) => isActive ? styles.active : ''}>Register</NavLink>
                </li>
                <li>
                  <NavLink to="/login" className={({ isActive }) => isActive ? styles.active : ''}>Login</NavLink>
                </li>
              </>
            )}
          </ul>
        </nav>
      </div>
    </header>
  );
};

export default Header;

================================================
FILE: client/src/widgets/Layout/MainLayout.module.css
================================================
.layoutContainer {
  display: flex;
  flex-direction: column;
  min-height: 100vh;
  background-color: var(--background-color);
}

.mainContent {
  flex-grow: 1;
  padding: calc(var(--spacing-base) * 3); /* 24px */
  /* Centering content within the main area if needed */
  /* display: flex; */
  /* flex-direction: column; */
  /* align-items: center; */
  width: 100%;
  max-width: calc(var(--spacing-base) * 150); /* 1200px, Max width for content area */
  margin: 0 auto; /* Center the content area */
}

.footer {
  padding: calc(var(--spacing-base) * 2) calc(var(--spacing-base) * 3); /* 16px 24px */
  text-align: center;
  background-color: var(--card-background-color); /* Using card background for footer area */
  border-top: 1px solid var(--border-color);
  color: var(--text-secondary-color); /* Footer text can be secondary */
  /* font-size moved to .text-caption utility class to be applied in TSX */
}

.footer p {
  margin: 0;
}


================================================
FILE: client/src/widgets/Layout/MainLayout.tsx
================================================
import type { ReactNode } from 'react';
import Header from '../Header/Header';
import styles from './MainLayout.module.css';

interface MainLayoutProps {
  children: ReactNode;
}

const MainLayout = ({ children }: MainLayoutProps) => {
  return (
    <div className={styles.layoutContainer}>
      <Header />
      <main className={styles.mainContent}>
        {children}
      </main>
      <footer className={styles.footer}>
        <p className="text-caption">&copy; {new Date().getFullYear()} Mutabor. All rights reserved.</p>
      </footer>
    </div>
  );
};

export default MainLayout;

================================================
FILE: client/tsconfig.app.json
================================================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true,
    "types": ["vitest/globals", "@testing-library/jest-dom"]
  },
  "include": ["src"],
  "exclude": ["node_modules", "dist", "**/*.spec.tsx", "**/*.test.tsx"]
}


================================================
FILE: client/tsconfig.json
================================================
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}


================================================
FILE: client/tsconfig.node.json
================================================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}


================================================
FILE: client/vite.config.ts
================================================
/// <reference types="vitest" />
import { defineConfig } from 'vitest/config'
import react from '@vitejs/plugin-react'
import path from 'path';

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    // ### ИЗМЕНЕНИЕ: Явно указываем Vite использовать порт 3000 ###
    // Это нужно, чтобы он соответствовал настройке "ports" в docker-compose.dev.yml ("8080:3000")
    port: 3000,
    watch: {
      // Эта настройка остается - она важна для стабильности в monorepo
      ignored: [
        path.resolve(__dirname, '../api/dist/**'),
      ],
    },
  },
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: ['./src/setupTests.ts'],
    css: true,
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      reportsDirectory: './coverage',
      all: true,
      include: ['src/**/*.{ts,tsx}'],
      exclude: [
        'src/main.tsx', 
        'src/vite-env.d.ts', 
        'src/setupTests.ts',
        '**/*.d.ts',
        '**/*.spec.{ts,tsx}',
        '**/*.test.{ts,tsx}',
        'src/app/styles',
        'src/shared/lib/socket.ts'
      ],
    },
  },
})

================================================
FILE: docker-compose.dev.yml
================================================
services:
  client:
    build:
      context: ./client
      dockerfile: Dockerfile.dev
    container_name: mutabor_dev_client
    ports:
      - "8080:3000"
    depends_on:
      api:
        condition: service_started
    environment:
      - VITE_API_URL=http://localhost:8081
      - CHOKIDAR_USEPOLLING=true
    volumes:
      - ./client:/app
      - /app/node_modules
    # ### ИЗМЕНЕНИЕ: Секция healthcheck удалена для dev-режима клиента ###
    # Это уберет "unhealthy" статус, который нерелевантен для Vite dev server.

  api:
    build:
      context: ./api
      dockerfile: Dockerfile.dev
    container_name: mutabor_dev_api
    ports:
      - "8081:3001"
    depends_on:
      db_dev:
        condition: service_healthy
    env_file:
      - ./api/.env.dev
    environment:
      - PORT=3001
      - NODE_ENV=development
      - DB_HOST=db_dev
      - DB_PORT=5432
      - DB_USER=user
      - DB_PASSWORD=password
      - DB_NAME=mutabor_dev
      - DATABASE_URL=postgresql://user:password@db_dev:5432/mutabor_dev?schema=public
      - CHOKIDAR_USEPOLLING=true
    volumes:
      - ./api:/app
      - /app/node_modules
      - /app/dist
    healthcheck:
      test: ["CMD", "curl", "--fail", "http://localhost:3001/health"]
      interval: 15s
      timeout: 5s
      retries: 5
      start_period: 45s

  db_dev:
    image: postgres:13
    container_name: mutabor_dev_db
    ports:
      - "54322:5432"
    environment:
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
      POSTGRES_DB: mutabor_dev
    volumes:
      - postgres_dev_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U user -d mutabor_dev"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s

volumes:
  postgres_dev_data:

================================================
FILE: docker-compose.test.yml
================================================
services:
  api-test:
    build:
      context: ./api
      dockerfile: Dockerfile.test
    container_name: mutabor_test_api_runner
    depends_on:
      db_test:
        condition: service_healthy
    env_file:
      - ./api/.env.test
    environment:
      - NODE_ENV=test
      - DATABASE_URL=postgresql://user:password@db_test:5432/mutabor_test?schema=public
      - DB_HOST=db_test
      - DB_PORT=5432
      - DB_USER=user
      - DB_PASSWORD=password
      - DB_NAME=mutabor_test
    volumes:
      - ./api/coverage:/app/coverage

  db_test:
    image: postgres:13
    container_name: mutabor_test_db
    ports:
      - "54323:5432"
    environment:
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
      POSTGRES_DB: mutabor_test
    volumes:
      - postgres_test_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U user -d mutabor_test"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 5s

volumes:
  postgres_test_data:

================================================
FILE: docker-compose.yml
================================================
services:
  client:
    build:
      context: ./client
      dockerfile: Dockerfile
    container_name: mutabor_prod_client
    ports:
      - "3000:3000"
    depends_on:
      api:
        condition: service_healthy
    environment:
      - VITE_API_URL=http://localhost:3001
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s

  api:
    build:
      context: ./api
      dockerfile: Dockerfile
    container_name: mutabor_prod_api
    ports:
      - "3001:3001"
    depends_on:
      db:
        condition: service_healthy
    env_file:
      - ./api/.env
    environment:
      - PORT=3001
      - NODE_ENV=production
      - DATABASE_URL=postgresql://user:password@db:5432/mutabor?schema=public
      - DB_HOST=db
      - DB_PORT=5432
      - DB_USER=user
      - DB_PASSWORD=password
      - DB_NAME=mutabor
    healthcheck:
      test: ["CMD", "curl", "--fail", "http://localhost:3001/health"]
      interval: 15s
      timeout: 5s
      retries: 5
      start_period: 30s

  db:
    image: postgres:13
    container_name: mutabor_prod_db
    ports:
      - "54321:5432"
    environment:
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
      POSTGRES_DB: mutabor
    volumes:
      - postgres_prod_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U user -d mutabor"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 5s

volumes:
  postgres_prod_data:

================================================
FILE: docs/Contracts.md
================================================
# Contracts: Mutabor

Этот документ является единым источником истины для всех взаимодействий внутри и снаружи системы. Он определяет форматы данных (DTO), интерфейсы сервисов и публичный API.

## 1. API Contract (OpenAPI / Swagger)

-   **Назначение:** Формальный договор между Frontend и Backend.
-   **Расположение:** Генерируется автоматически и доступен по адресу `/api-docs` после запуска бэкенда.
-   **Версионирование:** API использует версионирование через URL. Текущая версия: `v1`. Все эндпоинты доступны по префиксу `/api/v1`.
-   **Ключевые эндпоинты:**
    -   `GET /api/v1/projects/{id}`: Получение проекта по его числовому ID.
    -   `GET /api/v1/tasks/{hid}`: Получение задачи по ее человеко-читаемому ID (например, `PROJ-123`).

---

## 2. Data Contracts (Data Transfer Objects - DTO)

**Назначение:** Гарантируют, что данные, пересекающие границы слоев, имеют строгую и предсказуемую структуру.

### Project DTOs
```typescript
// DTO для создания проекта
export class CreateProjectDto {
  name: string;
  prefix: string; // Уникальный префикс для задач (uppercase, alphanumeric)
}

// DTO для добавления участника в проект
export class AddMemberDto {
  email: string;
  role: 'editor' | 'viewer'; // Владелец назначается при создании проекта
}

// DTO для обновления роли участника
export class UpdateMemberDto {
  role: 'editor' | 'viewer';
}

// DTO для обновления настроек проекта
export class UpdateProjectSettingsDto {
  name?: string;
  prefix?: string;
  // Полный список колонок (статусов). Бэкенд обновит их имена и порядок.
  statuses?: string[];
  // Полный список типов задач. Бэкенд синхронизирует таблицу `project_task_types` с этим списком.
  types?: string[];
}

// DTO для создания колонки
export class CreateColumnDto {
  name: string;
}

// DTO для обновления одной колонки
export class UpdateColumnDto {
  name: string;
}

// DTO с полной информацией о проекте, возвращаемый клиенту
export class ProjectDetailsDto {
  id: number;
  name: string;
  prefix: string;
  owner: { id: string; name: string; email: string; };
  members: { id: string; name: string; email: string; role: string; }[];
  columns: { id: string; name: string; position: number; tasks: TaskDto[] }[];
  availableTaskTypes: string[];
}
```

### Task & Comment DTOs
```typescript
// DTO для создания задачи. projectId передается через URL: POST /api/v1/projects/{projectId}/tasks
export class CreateTaskDto {
  title: string;
  description?: string;
  columnId: string;
  assigneeId?: string;
  dueDate?: string; // ISO Date String
  type?: string;
  priority?: string;
  tags?: string[];
}

// DTO для обновления задачи
export class UpdateTaskDto {
  title?: string;
  description?: string | null;
  assigneeId?: string | null;
  dueDate?: string | null;
  type?: string | null;
  priority?: string | null;
  tags?: string[] | null;
}

// DTO для перемещения задачи
export class MoveTaskDto {
  newColumnId: string;
  newPosition: number;
}

// DTO для создания комментария
export class CreateCommentDto {
  text: string;
}
```

### User & Profile DTOs
```typescript
// DTO для регистрации
export class RegisterUserDto {
  name: string;
  email: string;
  password: string; // min 8 characters
}

// DTO для логина
export class LoginUserDto {
  email: string;
  password: string;
}

// DTO для обновления профиля
export class UpdateProfileDto {
    name?: string;
}

// DTO для смены пароля
export class ChangePasswordDto {
    oldPassword: string;
    newPassword: string; // min 8 characters
}
```

### Notification DTO
```typescript
// DTO для уведомления, возвращаемый клиенту
export class NotificationDto {
  id: string;
  recipient_id: string;
  text: string;
  isRead: boolean;
  sourceUrl?: string | null;
  taskId?: string | null;
  createdAt: Date;
}
```


================================================
FILE: docs/Contribution Guidelines.md
================================================
# Contribution Guidelines: Mutabor

## 1. Общие принципы

Привет! Спасибо за ваш вклад в развитие "Mutabor". Этот документ — свод правил, который помогает нам работать слаженно, поддерживать высокое качество кода и делать процесс разработки предсказуемым и эффективным.

## 2. Git Workflow: GitHub Flow

Мы используем простую и эффективную модель **GitHub Flow**.

1.  Ветка `main` — это наш единственный источник истины. Она всегда должна быть стабильной и готовой к развертыванию.
2.  **Не коммитьте напрямую в `main`**.
3.  Для любой новой работы создавайте ветку от актуальной версии `main`.
4.  Когда работа завершена, создайте Pull Request (PR) в `main`.
5.  После успешного ревью и прохождения всех автоматических проверок, ваш PR будет слит в `main`.

## 3. Именование веток

Название ветки должно содержать тип изменений, номер задачи из "Mutabor" и краткое описание. Это позволяет мгновенно связать код с бизнес-контекстом.

**Формат:** `type/TASK-123-short-description-in-kebab-case`

-   **`type`**: Тип изменений (`feat`, `fix`, `refactor`, `docs`, `test`, `chore`).
-   **`TASK-123`**: ID задачи из нашего таск-менеджера "Mutabor".
-   **`short-description`**: Краткое описание на английском языке.

-   **Примеры:**
    -   `feat/MUT-42-add-task-comments`
    -   `fix/MUT-45-fix-login-form-validation`
    -   `docs/MUT-51-update-contribution-guide`

## 4. Формат коммитов: Conventional Commits

Мы придерживаемся стандарта **Conventional Commits**. Это позволяет нам поддерживать читаемую историю, автоматически генерировать списки изменений (changelog) и управлять версиями.

**Формат:** `type(scope): subject`

-   **`type`**: Тип коммита (`feat`, `fix`, и т.д.).
-   **`scope`** (опционально): Часть приложения (`auth`, `tasks`, `api`, `ui`).
-   **`subject`**: Краткое, осмысленное описание в настоящем времени. В конце сообщения можно указать номер задачи: `(closes MUT-42)`.

-   **Примеры:**
    -   `feat(tasks): add comments section to task modal (closes MUT-42)`
    -   `fix(auth): correctly handle JWT expiration error (closes MUT-45)`
    -   `refactor(api): simplify user service logic`

## 5. Процесс Pull Request (PR) и Code Review

PR — это основной инструмент для обсуждения и проверки кода. Мы стремимся к максимальной автоматизации этого процесса.

### Создание PR
-   Убедитесь, что ваш код соответствует всем правилам из `Layer Guides` и `Design System`.
-   Заполните описание вашего PR, используя **шаблон**, который появится автоматически. Он включает поля:
    -   **Что сделано?** (Краткое описание изменений)
    -   **Как проверить?** (Пошаговая инструкция для тестирования)
    -   **Связанная задача:** (Ссылка на задачу в Mutabor, например, `Closes MUT-42`)
-   Назначьте как минимум одного ревьюера из команды.

### Процесс ревью
-   Для слияния PR требуется как минимум **одно одобрение** (`Approve`) от другого члена команды.
-   **Локальные проверки (тесты, линтер) должны быть пройдены успешно.** Перед отправкой PR на ревью убедитесь, что все тесты (`npm run test` в соответствующей директории) и линтеры (`npm run lint`) проходят локально. PR с очевидными проблемами, которые могли быть выявлены локально, может быть отклонен до исправления.
-   **(В будущем) CI-проверки:** Мы планируем внедрить автоматические CI-проверки (тесты, линтер) на стороне сервера. После их внедрения, они также должны будут быть "зелеными" для возможности слияния PR.
-   **Конструктивная критика:** Все обсуждения должны быть уважительными и по делу. Цель ревью — улучшить продукт.

### Слияние PR
-   После получения необходимого количества одобрений и успешного прохождения всех проверок (включая локальные и, в будущем, CI), PR будет слит в ветку `main`.
-   Предпочтительным методом слияния является **"Squash and merge"**, чтобы история коммитов в `main` оставалась чистой и каждый коммит соответствовал одному PR. Это обычно выполняется одним из мэйнтейнеров проекта.
-   После слияния PR, ветка фичи должна быть удалена. Это можно сделать через интерфейс GitHub или локально (`git branch -d type/TASK-123-short-description`). (В будущем это также может быть автоматизировано).

Мы стремимся к большей автоматизации этого процесса в будущем для обеспечения безопасности, предотвращения случайных ошибок и экономии времени.

================================================
FILE: docs/Database Schema.md
================================================
# Database Schema: Mutabor

Note: This project uses PostgreSQL, managed via Docker, as the database platform. The schema is managed via Liquibase migrations defined in `api/db/changelog/`.

## 1. ERD (Entity-Relationship Diagram)

Эта диаграмма является визуальным представлением финальной структуры базы данных, связей и ключевых ограничений целостности данных.

```mermaid
erDiagram
    users {
        string id PK
        string email UK
        string name nullable
        string password_hash
        string role "NOT NULL, DEFAULT 'user'"
        datetime created_at
        datetime updated_at
    }

    projects {
        int id PK "SERIAL"
        string name
        string task_prefix UK
        int last_task_number
        string owner_id FK
        datetime created_at
        datetime updated_at
    }

    project_members {
        int project_id PK, FK
        string user_id PK, FK
        string role
    }

    project_task_types {
        int id PK "SERIAL"
        string name "UK(name, project_id)"
        int project_id FK
    }

    columns {
        string id PK "UUID"
        string name "UK(name, project_id)"
        int position
        int project_id FK
    }

    tasks {
        string id PK "UUID"
        string human_readable_id UK
        int task_number "UK(project_id, task_number)"
        string title
        string description nullable
        int position
        string type nullable
        string priority nullable
        string_array tags nullable
        int project_id FK
        string column_id FK
        string assignee_id FK "nullable"
        string creator_id FK
        datetime due_date "nullable"
        datetime created_at
        datetime updated_at
    }

    comments {
        string id PK "UUID"
        string text
        string task_id FK
        string author_id FK "nullable"
        datetime created_at
        datetime updated_at
    }
    
    notifications {
        string id PK "UUID"
        string recipient_id FK
        string text
        boolean is_read
        string source_url nullable
        string task_id FK "nullable"
        datetime created_at
        datetime updated_at
    }

    users ||--o{ projects : "владеет"
    users }o--o{ project_members : "участвует_в"
    users ||--o{ tasks : "создатель"
    users ||..o{ tasks : "исполнитель"
    users ||--o{ comments : "автор"
    users ||--o{ notifications : "получатель"
    
    projects }o--o{ project_members : "имеет_участников"
    projects ||--o{ columns : "содержит"
    projects ||--o{ tasks : "содержит"
    projects ||--o{ project_task_types : "определяет"
    
    columns ||--o{ tasks : "содержит"
    
    tasks ||--o{ comments : "имеет"
    tasks ||..o{ notifications : "связана_с"
```

## 2. Описание таблиц и правил

| Таблица / Поле             | Тип данных         | Ограничения / Индексы                               | Описание                                                                  |
| -------------------------- | ------------------ | --------------------------------------------------- | ------------------------------------------------------------------------- |
| **users**                  |                    |                                                     | Пользователи системы.                                                     |
| `id`                       | `string` (UUID)    | `PRIMARY KEY`                                       | Уникальный ID пользователя.                                               |
| `email`                    | `string`           | `UNIQUE`, `NOT NULL`                                | Электронная почта.                                                        |
| `name`                     | `string?`          | `NULLABLE`                                          | Имя пользователя.                                                         |
| `password_hash`            | `string`           | `NOT NULL`                                          | Хеш пароля.                                                               |
| `role`                     | `string`           | `NOT NULL`, `DEFAULT 'user'`, `INDEX`               | Глобальная роль пользователя (например, 'admin', 'user').                 |
| **projects**               |                    |                                                     | Проекты или Kanban-доски.                                                 |
| `id`                       | `Int`              | `PRIMARY KEY`, `SERIAL`                             | Уникальный числовой ID проекта.                                           |
| `task_prefix`              | `string`           | `UNIQUE`, `NOT NULL`                                | Короткий префикс для задач проекта (например, "PHX").                     |
| `last_task_number`         | `Int`              | `DEFAULT 0`                                         | Счетчик последнего номера задачи в проекте.                               |
| `owner_id`                 | `string` (UUID)    | `FK to users(id)`, `ON DELETE RESTRICT`             | Владелец проекта.                                                         |
| **project_members**        |                    |                                                     | Связующая таблица для участников проекта.                                  |
| `project_id`               | `Int`              | `PK`, `FK to projects(id)`, `ON DELETE CASCADE`      | ID проекта.                                                             |
| `user_id`                  | `string` (UUID)    | `PK`, `FK to users(id)`, `ON DELETE CASCADE`, `INDEX` | ID пользователя.                                                          |
| `role`                     | `string`           | `NOT NULL`                                          | Роль пользователя в проекте.                                              |
| **project_task_types**     |                    |                                                     | Справочник кастомных типов задач для проекта.                               |
| `id`                       | `Int`              | `PRIMARY KEY`, `SERIAL`                             | ID типа задачи.                                                           |
| `name`                     | `string`           | `UK (name, project_id)`                             | Название типа (e.g., Bug, Feature).                                       |
| `project_id`               | `Int`              | `FK to projects(id)`, `ON DELETE CASCADE`           | Связь с проектом.                                                         |
| **columns**                |                    |                                                     | Колонки на Kanban-доске (они же статусы задач).                             |
| `id`                       | `string` (UUID)    | `PRIMARY KEY`                                       | Уникальный ID колонки.                                                    |
| `name`                     | `string`           | `UK (name, project_id)`                             | Название колонки, уникальное в рамках проекта.                            |
| `position`                 | `Int`              | `NOT NULL`                                          | Порядковый номер для сортировки.                                          |
| `project_id`               | `Int`              | `FK to projects(id)`, `ON DELETE CASCADE`           | Связь с проектом.                                                         |
| **tasks**                  |                    |                                                     | Атомарные задачи.                                                         |
| `id`                       | `string` (UUID)    | `PRIMARY KEY`                                       | Внутренний ID.                                                          |
| `human_readable_id`        | `string`           | `UNIQUE`                                            | Человеко-понятный ID (например, "PHX-1").                                 |
| `task_number`              | `Int`              | `UK(project_id, task_number)`                       | Номер задачи, уникальный в рамках проекта.                                |
| `type`                     | `string?`          | `NULLABLE`                                          | Тип задачи (e.g., Bug, Feature). Валидируется по таблице `project_task_types`. |
| `column_id`                | `string` (UUID)    | `FK to columns(id)`, `ON DELETE CASCADE`, `INDEX`     | Связь с колонкой.                                                         |
| `assignee_id`              | `string?` (UUID)   | `FK to users(id)`, `ON DELETE SET NULL`, `INDEX`      | Исполнитель.                                                              |
| **comments**               |                    |                                                     | Комментарии к задачам.                                                    |
| `id`                       | `string` (UUID)    | `PRIMARY KEY`                                       | Уникальный ID комментария.                                                |
| `author_id`                | `string?` (UUID)   | `FK to users(id)`, `ON DELETE SET NULL`             | Автор. При удалении становится NULL.                                     |
| **notifications**          |                    |                                                     | Уведомления для пользователей.                                            |
| `id`                       | `string` (UUID)    | `PRIMARY KEY`                                       | Уникальный ID уведомления.                                                |
| `recipient_id`             | `string` (UUID)    | `FK to users(id)`, `ON DELETE CASCADE`, `INDEX`       | Получатель уведомления.                                                   |
| `task_id`                  | `string?` (UUID)   | `FK to tasks(id)`, `ON DELETE CASCADE`, `NULLABLE`  | Опциональная ссылка на связанную задачу.                                   |


================================================
FILE: docs/Dependencies Map.md
================================================
# Dependencies Map: Mutabor

## 1. Внутренние зависимости (Коммуникация между модулями)

Система строится как модульный монолит. Модули взаимодействуют через DI-контейнер Nest.js.

```mermaid
graph TD
    subgraph "Mutabor Backend (Модульный Монолит)"
        AuthService
        ProfileController
        ProjectsController
        TasksController
        NotificationsController
        
        ProjectsService
        TasksService
        CommentsService
        NotificationsService
        
        PoliciesGuard
        EventsGateway

        subgraph "CASL (Authorization)"
            PoliciesGuard -- "Проверяет права" --> ProjectsService
            PoliciesGuard -- "Проверяет права" --> TasksService
        end

        ProjectsController -- "Использует" --> ProjectsService
        TasksController -- "Использует" --> TasksService
        ProfileController -- "Использует" --> AuthService
        NotificationsController -- "Использует" --> NotificationsService

        TasksService -- "Проверяет валидность типа" --> ProjectsService
        TasksService -- "Управляет комментариями" --> CommentsService
        
        CommentsService -- "Создает уведомления" --> NotificationsService
        CommentsService -- "Отправляет события" --> EventsGateway

        NotificationsService -- "Отправляет события" --> EventsGateway
        
        ProjectsController -- "Защищен" --> PoliciesGuard
        TasksController -- "Защищен" --> PoliciesGuard
    end

    subgraph "Внешний мир"
      AI_Provider[External AI API]
      subgraph "Frontend"
        Browser
      end
    end

    Browser -- "HTTP" --> ProjectsController
    Browser -- "HTTP" --> TasksController
    Browser -- "HTTP" --> ProfileController
    Browser -- "HTTP" --> NotificationsController
    Browser -- "WebSocket" --> EventsGateway

    %% AIService -- "API-вызов" --> AI_Provider
```

- **`PoliciesGuard` (Гард Авторизации):** Центральный элемент проверки прав. Зависит от `ProjectsService` и `TasksService` для получения контекста (проекта, задачи) и определения роли пользователя.
- **`ProjectsService` / `TasksService`:** Ядра бизнес-логики. Теперь они не содержат логику проверки прав, а просто предоставляют данные для `PoliciesGuard`.
- **`CommentsService`:** Делегирует создание уведомлений об упоминаниях в `NotificationsService`.
- **`NotificationsService`:** Новый, изолированный сервис. Отвечает за создание записей об уведомлениях в БД и отправку real-time событий через `EventsGateway`.

## 2. Новые компоненты (что создано)

### Backend:
- `ProfileController`: Эндпоинты для управления профилем (`/profile/me`, `/profile/change-password`).
- `NotificationsService` & `NotificationsController`: CRUD и бизнес-логика для уведомлений.
- `PoliciesGuard`: Глобальный гвард для проверки ролевой модели доступа.
- `@CheckPolicies` & `PolicyHandler`: Декораторы и обработчики для декларативного описания правил доступа.

### Frontend (что потребуется создать):
- `ProfilePage`: Страница для редактирования имени и смены пароля.
- `NotificationBell`: Компонент с иконкой-колокольчиком, который слушает WebSocket-событие `notification:new`.
- **Обработка ошибок 403 Forbidden:** UI должен корректно реагировать, если пользователь пытается выполнить действие, на которое у него нет прав (например, скрывать кнопки "Настройки" для `editor`).


================================================
FILE: docs/Design System.md
================================================
# Design System: Mutabor

## 1. Руководящие принципы

"Mutabor" — это профессиональный инструмент, созданный для максимальной продуктивности. Дизайн должен быть чистым, сдержанным и предсказуемым. Каждый элемент интерфейса служит одной цели — помочь пользователю сфокусироваться на задачах, а не на самом интерфейсе.

-   **Минимум визуального шума:** Мы избегаем лишних украшений, градиентов и кричащих анимаций.
-   **Функциональность превыше всего:** Эстетика важна, но она никогда не должна мешать удобству использования.
-   **Предсказуемость:** Пользователь должен интуитивно понимать, как работает каждый элемент управления.

## 2. Цветовая палитра (Design Tokens)

Цвета определены как CSS-переменные (токены) для обеспечения глобальной консистентности.

```mermaid
graph TD
    subgraph "Палитра токенов"
        A["--color-primary: #6D28D9"]
        B["--color-text-main: #1F2937"]
    end
    subgraph "Компоненты"
        C[Button Component]
        D[Link Component]
        E[Heading Component]
    end
    A --> C
    A --> D
    B --> E
```

-   **Primary (Accent):** `var(--color-primary)`
    -   **HEX:** `#6D28D9` (Глубокий, спокойный фиолетовый)
    -   **Назначение:** Основные кнопки, ссылки, активные поля ввода, иконки.

-   **Semantic Colors:**
    -   **Success:** `var(--color-success)` - `#10B981` (Зеленый)
    -   **Error/Danger:** `var(--color-error)` - `#EF4444` (Красный)
    -   **Warning:** `var(--color-warning)` - `#F59E0B` (Янтарный)
    -   **Info:** `var(--color-info)` - `#3B82F6` (Синий)

-   **Neutral Palette (Greys):**
    -   `--color-background-page`: `#F9FAFB` (Почти белый, легкий оттенок)
    -   `--color-background-element`: `#FFFFFF` (Чистый белый для карточек и модальных окон)
    -   `--color-border`: `#E5E7EB` (Светло-серые границы)
    -   `--color-text-main`: `#1F2937` (Основной текст, почти черный)
    -   `--color-text-secondary`: `#6B7280` (Второстепенный текст, серый)
    -   `--color-text-disabled`: `#D1D5DB` (Текст для неактивных элементов)

## 3. Типографика

-   **Основной шрифт:** **Системный стек**. Это обеспечивает максимальную производительность и "родное" отображение на всех платформах.
    -   `font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;`
-   **Моноширинный шрифт:** **Системный стек моноширинных шрифтов**. Используется для отображения кода и технических данных.
    -   `font-family: "SF Mono", "Menlo", "Consolas", "Courier New", monospace;`
-   **Шкала размеров (Type Scale):**
    -   H1: `32px`, `font-weight: 700`
    -   H2: `24px`, `font-weight: 600`
    -   H3: `20px`, `font-weight: 600`
    -   Body (p): `16px`, `font-weight: 400`
    -   Caption: `14px`, `font-weight: 400`

## 4. Сетка и отступы (Spacing System)

-   **Базовая единица (Base Unit):** `8px`.
-   **Правило:** Все отступы (margin, padding) и размеры элементов должны быть кратны базовой единице (например, `padding: 16px 24px`). Это создает предсказуемый визуальный ритм.

## 5. UI Kit: Основные компоненты

Здесь описывается внешний вид и состояния ключевых компонентов. Это основа для библиотеки компонентов в React.

-   **Button:**
    -   **Variants:** `primary` (заливка `var(--color-primary)`), `secondary` (прозрачный фон, рамка `var(--color-border)`), `danger`.
    -   **States:** `default`, `hover` (легкое осветление/затемнение), `focus` (добавление `outline`), `disabled` (цвет `var(--color-text-disabled)`).
    -   **Border Radius:** `6px`.

-   **Input:**
    -   **States:**
        -   `default`: Рамка `1px solid var(--color-border)`.
        -   `focus`: Рамка `2px solid var(--color-primary)`.
        -   `error`: Рамка `2px solid var(--color-error)`.
        -   `disabled`: Фон `var(--color-background-page)`.
    -   **Border Radius:** `6px`.

-   **Modal:**
    -   **Elevation:** Используется мягкая, рассеянная тень для создания ощущения высоты.
        -   `box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);`
    -   **Border Radius:** `8px`.

-   **Card (Карточка задачи):**
    -   **Background:** `var(--color-background-element)`.
    -   **Border:** `1px solid var(--color-border)`.
    -   **Border Radius:** `8px`.
    -   **Hover State:** Легкое поднятие с помощью тени, чтобы показать интерактивность.


================================================
FILE: docs/Implementation Plan.md
================================================
# Implementation Plan: Mutabor

Этот документ описывает последовательность разработки и внедрения функционала. Он служит дорожной картой для команды.

## Этап 1: Базовый MVP и настройка окружения (ЗАВЕРШЕНО)
- **Статус:** ✅ Выполнено

## Этап 2: Стабилизация и Устранение Технического Долга (ЗАВЕРШЕНО)
- **Статус:** ✅ Выполнено

## Этап 3: Повышение Покрытия Тестами (ОТЛОЖЕНО)
- **Статус:** ⏸️ Отложено
- **Цель:** Достичь приемлемого уровня покрытия тестами для основных частей системы.
- **Примечание:** Эта задача будет выполняться параллельно с разработкой нового функционала или после завершения Этапа 5.

---

## Этап 4: Внедрение Платформы Автоматизации (ТЕКУЩИЙ)
- **Статус:** ⏳ В работе
- **Цель:** Превратить Mutabor из таск-трекера в платформу для автоматизации разработки путем интеграции с Git, AI и CI/CD.

### Блок 4.1: Основы Git-интеграции и "Артефакты"
**Цель блока:** Научить систему работать с файлами в репозитории проекта.

| Исполнитель | Задача                                                                              | Статус |
|:-----------:|:------------------------------------------------------------------------------------|:------:|
|   Backend   | `[DB]` Создать миграцию для добавления полей `git_repository_url` и `encrypted_git_pat` в `projects`. |  `[ ]` |
|   Backend   | `[API]` Реализовать эндпоинты в `ProjectSettingsController` для CRUD-операций с настройками Git.     |  `[ ]` |
|  Frontend   | `[UI]` В настройках проекта добавить поля для ввода URL репозитория и Personal Access Token. |  `[ ]` |
|   Backend   | `[CORE]` Создать `GitService` для клонирования/пулла репозиториев и коммита/пуша изменений. |  `[ ]` |
|   Backend   | `[API]` Создать эндпоинты для чтения/записи файлов в привязанном репозитории.       |  `[ ]` |
|  Frontend   | `[UI]` Создать виджет `ArtifactEditor` для отображения и редактирования файлов из Git.     |  `[ ]` |

### Блок 4.2: AI-Агенты
**Цель блока:** Внедрить сущность "Агент" и научить систему выполнять LLM-запросы от его имени.

| Исполнитель | Задача                                                                              | Статус |
|:-----------:|:------------------------------------------------------------------------------------|:------:|
|   Backend   | `[DB]` Создать миграцию для таблицы `agent_configs` и добавить `role='agent'` в `users`. |  `[ ]` |
|   Backend   | `[CORE]` Создать `AgentsService` для управления агентами.                               |  `[ ]` |
|   Backend   | `[API]` Модифицировать `AiService` для работы с конфигурацией конкретного агента.     |  `[ ]` |
|  Frontend   | `[UI]` Создать вкладку "Agents" в настройках проекта для CRUD-операций с агентами.    |  `[ ]` |

### Блок 4.3: Ядро Автоматизации
**Цель блока:** Создать движок для выполнения цепочек действий по триггерам.

| Исполнитель | Задача                                                                              | Статус |
|:-----------:|:------------------------------------------------------------------------------------|:------:|
|   Backend   | `[DB]` Создать миграции для таблиц `automations` и `automation_actions`.            |  `[ ]` |
|   Backend   | `[CORE]` Создать `AutomationService` для выполнения цепочек действий.                   |  `[ ]` |
|   Backend   | `[CORE]` В `TasksService` интегрировать вызов `AutomationService` при смене колонки.    |  `[ ]` |
|  Frontend   | `[UI]` Создать вкладку "Automations" в настройках проекта с конструктором цепочек.    |  `[ ]` |

### Блок 4.4: Интеграция с CI/CD
**Цель блока:** Реализовать безопасный запуск тестов через внешние системы.

| Исполнитель | Задача                                                                              | Статус |
|:-----------:|:------------------------------------------------------------------------------------|:------:|
|   Backend   | `[CORE]` В `AutomationService` реализовать действие `RUN_CI_PIPELINE` (отправка вебхука). |  `[ ]` |
|   Backend   | `[API]` Создать эндпоинт для приема колбэков от CI/CD систем.                         |  `[ ]` |
|   Backend   | `[CORE]` Реализовать логику обработки колбэка (комментарий в задачу, перемещение).   |  `[ ]` |
|  Frontend   | `[UI]` В конструкторе автоматизаций добавить настройку для действия `RUN_CI_PIPELINE`. |  `[ ]` |


================================================
FILE: docs/Layer Guides.md
================================================
# Layer Guides: Mutabor

Этот документ — "Конституция" нашего проекта. Он определяет правила и обязанности каждого архитектурного слоя.

## Backend (Nest.js)

Архитектура следует принципам чистой архитектуры и лучших практик Nest.js.

```mermaid
graph TD
    subgraph "Global Middleware & Pipes"
        A[GlobalExceptionFilter]
        B[GlobalValidationPipe]
    end
    
    subgraph "Framework Layer (Внешний)"
        C[Controllers]
        D[Realtime Gateway]
        E[PoliciesGuard]
    end

    subgraph "Application Layer (Бизнес-логика)"
        F[Services]
        G[DTOs]
    end

    subgraph "Data Layer (Доступ к данным)"
        H[Knex.js / Liquibase]
    end
    
    A --> C
    B --> C
    C -- "Защищен" --> E
    E -- "Использует" --> F
    C -- "Использует" --> F
    D -- "Использует" --> F
    F -- "Использует" --> H
    C -- "Принимает / Возвращает" --> G
```

### 0. Глобальный уровень
- **`GlobalExceptionFilter`:** Единственная точка обработки всех ошибок. Форматирует ответы в стандартный JSON. Отвечает за логирование ошибок.
- **`GlobalValidationPipe`:** Единственная точка валидации всех входящих DTO. Гарантирует, что до контроллеров доходят только валидные данные.

### 1. Controller & Guard Layer (`*.controller.ts`, `*.guard.ts`)
- **Назначение:** Точка соприкосновения с миром HTTP и авторизации.
- **Принципы:**
    - **Ультра-тонкий контроллер:** Не содержит бизнес-логики. Его задача — распарсить запрос, вызвать **один** метод в сервисе и вернуть результат.
    - **Декларативная авторизация:** Права доступа **не проверяются** внутри контроллера. Вместо этого используется гвард `PoliciesGuard` и декоратор `@CheckPolicies` для декларативного описания необходимых прав.
    - **Строгая работа с DTO:** Все входящие и исходящие данные — это DTO.

### 2. Service Layer Guide (`*.service.ts`)
- **Назначение:** Сердце приложения. Здесь инкапсулирована вся бизнес-логика.
- **Принципы:**
    - **Независимость от фреймворка:** Сервис ничего не знает о `request`, `response` и HTTP.
    - **Владелец данных:** Только сервисы имеют право обращаться к базе данных.
    - **Оркестрация:** Сервис может вызывать другие сервисы (`NotificationsService`, `ProjectsService`) для выполнения сложных бизнес-процессов.
    - **Транзакционность:** Все операции, изменяющие несколько сущностей, должны быть обернуты в транзакцию.
    - **Не содержит логики прав доступа:** Сервис может предоставлять методы для получения роли пользователя (как `getProjectAndRole`), но финальное решение "можно/нельзя" принимает `PoliciesGuard`.

## Frontend (React)
Архитектура фронтенда строится по методологии **Feature-Sliced Design (FSD)**.

- **Структура папок:**
    ```
    /src
      /app        # Инициализация (роутер, стор, провайдеры)
      /pages      # Компоновка виджетов и фич
      /widgets    # Сложные UI-блоки (Header, ProjectSidebar)
      /features   # Бизнес-логика (AuthByEmail, CreateTask, AddComment)
      /entities   # Бизнес-сущности (User, Task, Project)
      /shared     # Переиспользуемый код (UI-кит, конфиг API, lib)
    ```

- **Правило импортов (The Slices Rule):** Слои могут импортировать только из слоев, находящихся строго ниже.
    -   ✅ `pages` могут импортировать из `widgets`, `features`, `entities`, `shared`.
    -   ❌ `features` **не могут** импортировать из `widgets` или `pages`.


================================================
FILE: docs/Solution Design.md
================================================
# Solution Design: "Mutabor"

## 1. Цель

Создать интеллектуальную платформу для автоматизации разработки (Developer Platform), построенную вокруг Kanban-доски. Продукт предназначен для небольших команд (2-15 человек), которые хотят не просто отслеживать задачи, а автоматизировать рутинные процессы разработки, тестирования и документирования с помощью настраиваемых AI-агентов и Git-интеграции.

## 2. Ключевые особенности и УТП

### 2.1. Kanban-доска как центр управления
- **Проекты (Доски):** Пространства для организации задач, каждый из которых привязан к собственному Git-репозиторию.
- **Колонки (Статусы):** Настраиваемые этапы жизненного цикла задачи.
- **Задачи (Карточки):** Атомарные рабочие элементы, являющиеся контейнерами для "артефактов".

### 2.2. GitOps: Репозиторий как единственный источник истины
- **Артефакты в Git:** Весь контекст задачи (ТЗ, код, документация, тесты) хранится не в базе данных, а в файлах Git-репозитория проекта. Mutabor работает с этими файлами напрямую.
- **Коммиты от имени агентов:** Все изменения, внесенные AI-агентами, коммитятся в репозиторий, обеспечивая полную прозрачность и историю изменений.

### 2.3. УТП: Настраиваемая AI-автоматизация
- **Системные AI-агенты:** В Mutabor "агент" — это системный пользователь с настраиваемым AI-профилем (провайдер, модель, ключ, системный промпт). Агенты могут быть назначены на задачи, оставлять комментарии и изменять артефакты в Git.
- **Конструктор автоматизаций:** Пользователи могут без кода настраивать цепочки "Триггер -> Действия" для каждой колонки на доске.
- **Безопасная интеграция с CI/CD:** Запуск тестов и других пайплайнов делегируется внешней CI/CD системе (например, GitLab CI) через механизм вебхуков, что обеспечивает безопасность и гибкость.

## 3. Ограничения

- **Платформа:** Веб-приложение.
- **Производительность:** Отклик интерфейса < 200 мс. Операции с Git и AI выполняются асинхронно в фоновом режиме.
- **Надежность:** Uptime сервиса — 99.8%. Данные не должны теряться.

## 4. Ожидаемый результат

- **Функциональное веб-приложение** с Kanban-доской, интегрированной с Git.
- **Модульная система** для определения и запуска автоматизаций.
- **Интерфейс для управления** проектами, репозиториями, агентами и автоматизациями.
- **Четкий, версионированный RESTful API (`/api/v1`)** с документацией (Swagger).
- **Real-time обновления** через WebSockets для отслеживания статуса автоматизаций.

## 5. Архитектура и Технологии

- **Frontend:** React.
- **Backend:** Nest.js.
- **База данных:** PostgreSQL (миграции через Liquibase).
- **Real-time:** Socket.IO.
- **Git-интеграция:** Библиотека `simple-git` на бэкенде.
- **CI/CD Интеграция:** Webhooks (приоритетная поддержка для GitLab CI).

## 6. Ключевые сущности данных (Data Model)

Актуальная и единственно верная схема базы данных и ERD-диаграмма находятся в документе **[Database Schema.md](./Database%20Schema.md)**. Этот подход исключает рассинхронизацию между документами.

## 7. Основные флоу (User & System Flows)

### Флоу: Автоматическое тестирование и деплой кода

**Цель:** Продемонстрировать полный цикл автоматизации от написания кода до его тестирования.

```mermaid
graph TD
    subgraph "Mutabor UI"
        A[Разработчик перемещает задачу из 'In Development' в 'Ready for Test']
    end

    subgraph "Mutabor Backend"
        B(AutomationService: Сработал триггер 'ON_ENTER' для колонки 'Ready for Test')
        C{Найдено действие 'RUN_CI_PIPELINE'}
        D[Отправляет POST-запрос на Webhook URL пользователя в GitLab CI]
    end

    subgraph "GitLab CI/CD (инфраструктура пользователя)"
        E[Получает Webhook. Запускает CI пайплайн]
        F[1. Checkout ветки<br/>2. npm install<br/>3. npm test]
        G{Тесты прошли успешно?}
        H[Отправляет POST-запрос на Callback URL в Mutabor с результатом 'success']
        I[Отправляет POST-запрос на Callback URL в Mutabor с результатом 'failure' и логами]
    end
    
    subgraph "Mutabor Backend (реакция на Callback)"
       J[Получает результат от CI/CD]
       K[Агент 'QA Bot' оставляет комментарий в задаче: '✅ Тесты успешно пройдены.']
       L[Агент 'QA Bot' оставляет комментарий: '❌ Тесты провалены.' и прикрепляет лог]
       M[Автоматически перемещает задачу в 'Ready for Deploy']
       N[Автоматически перемещает задачу обратно в 'In Development']
    end

    A --> B --> C --> D --> E --> F --> G;
    G -- Да --> H --> J --> K --> M;
    G -- Нет --> I --> J --> L --> N;
```


================================================
FILE: docs/User Flow Diagrams.md
================================================
## User Flow Diagrams

### 1. Путь нового пользователя (Onboarding)

**Цель:** Провести пользователя от лендинга до его первой пустой доски максимально быстро и безболезненно, создав ощущение легкости и контроля.

```mermaid
graph TD
    subgraph "Сценарий: Первый контакт и регистрация"
        A[Пользователь заходит на лендинг-страницу] --> B[Нажимает кнопку 'Начать бесплатно' или 'Зарегистрироваться'];
        B --> C[Переходит на страницу /register];
        C --> D{Вводит email, имя и пароль};
        D --> E[Нажимает 'Создать аккаунт'];
        E --> F[API: Создает пользователя в БД];
        F --> G{Успешно?};
        G -- Да --> I[Автоматически логинит пользователя и перенаправляет на /dashboard];
        G -- Нет (например, email уже занят) --> H[Показывает ошибку под формой: 'Пользователь с таким email уже существует'];
        I --> J["'Aha!' момент: Пользователь видит пустой дашборд с текстом 'У вас пока нет проектов' и заметной кнопкой '+ Создать проект'"];
        J --> K[Нажимает '+ Создать проект'];
        K --> L{В модальном окне вводит название проекта};
        L --> M[Нажимает 'Создать'];
        M --> N["API: Создает проект. Перенаправляет на /projects/{id}"];
        N --> O[Пользователь видит свою первую, пустую доску со стандартными колонками: 'To Do', 'In Progress', 'Done'];
    end
```
**Пошаговое описание:**
1.  **Вход:** Пользователь попадает на лендинг и инициирует регистрацию.
2.  **Регистрация:** Происходит в один шаг на странице `/register`. Валидация происходит на стороне сервера.
3.  **Первый вход:** В случае успеха пользователь сразу попадает в приложение, минуя страницу логина.
4.  **"Чистый лист":** Ему показывают пустую панель, что дает ощущение контроля и не перегружает информацией.
5.  **Создание проекта:** Простой и понятный шаг для создания первого рабочего пространства.
6.  **Результат:** Пользователь оказывается на своей Kanban-доске, готовый к работе. Весь путь занимает меньше минуты.

---

### 2. Ежедневная работа с задачей (Основной цикл)

**Цель:** Определить стандартный, интуитивно понятный и эффективный процесс создания и редактирования задачи.

```mermaid
graph TD
    subgraph "Сценарий: Жизненный цикл задачи"
        A[Пользователь находится на доске проекта] --> B[Нажимает кнопку '+ Добавить задачу' в нужной колонке];
        B --> C[Открывается модальное окно создания задачи];
        C --> D{"Заполняет поля: Название (обязательно), Описание. Выбирает исполнителя из выпадающего списка участников проекта."};
        D --> E[Нажимает 'Создать задачу'];
        E --> F[API: Создает задачу. WebSocket-событие 'task:created' рассылается всем участникам проекта];
        F --> G[Модальное окно закрывается. Новая карточка задачи плавно появляется в колонке у всех на глазах];
        
        G --> H[Позже пользователь кликает на существующую задачу];
        H --> I[Открывается то же самое модальное окно, но уже с заполненными данными задачи];
        I --> J{Редактирует нужные поля};
        J --> K[Нажимает 'Сохранить'];
        K --> L[API: Обновляет задачу. WebSocket-событие 'task:updated' рассылается всем];
        L --> M[Модальное окно закрывается. Карточка задачи на доске обновляется];
    end
```
**Пошаговое описание:**
1.  **Инициация:** Создание задачи начинается с явного действия пользователя — нажатия на кнопку.
2.  **Единый интерфейс:** Одно и то же модальное окно используется и для создания, и для редактирования. Это упрощает интерфейс и код.
3.  **Коллаборация:** Выбор исполнителя доступен сразу, что подчеркивает командную работу.
4.  **Real-time:** Каждое важное действие (создание, обновление) немедленно отражается у всех участников благодаря WebSocket, создавая ощущение "живого" пространства.

---

### 3. Взаимодействие с AI (Ключевое преимущество)

**Цель:** Сделать использование AI-помощника максимально простым, понятным и безопасным, давая пользователю финальное слово.

```mermaid
graph TD
    subgraph "Сценарий: Декомпозиция задачи с помощью AI"
        A[Пользователь открыл модальное окно задачи] --> B[Нажимает на иконку '✨ Улучшить с AI' рядом с полем 'Описание'];
        B --> C[Поле 'Описание' и кнопка 'Сохранить' блокируются. Появляется анимированная надпись: 'Mutabor анализирует вашу задачу...'];
        C --> D["Frontend отправляет запрос на API: POST /tasks/{id}/decompose"];
        D --> E[Backend вызывает внешний AI API с промптом на декомпозицию];
        E --> F{AI вернул успешный результат?};
        
        F -- Да --> G[UI разблокируется. Под полем 'Описание' появляется новый блок 'Предложения от AI'];
        G --> H["В блоке отображается сгенерированный чек-лист и две кнопки: 'Применить' и 'Отклонить'"];
        H -- Нажимает 'Отклонить' --> I[Блок с предложениями исчезает. Никаких изменений не происходит];
        H -- Нажимает 'Применить' --> J[API: Отправляется запрос на обновление задачи с новым описанием];
        J --> K[Описание задачи обновляется, блок с предложениями исчезает. У всех участников доски задача обновляется через WebSocket];

        F -- Нет (ошибка сети, API недоступен) --> L[UI разблокируется. Появляется короткое сообщение об ошибке: 'Не удалось связаться с AI. Пожалуйста, попробуйте позже'];
    end
```
**Пошаговое описание:**
1.  **Точка входа:** AI активируется в контексте конкретной задачи, что интуитивно понятно.
2.  **Обратная связь:** Пользователь всегда знает, что происходит (состояние загрузки, анализ).
3.  **Безопасность и контроль:** Ключевой шаг — **подтверждение**. AI не действует за спиной у пользователя, а предлагает варианты. Пользователь остается главным.
4.  **Обработка ошибок:** Продуман путь на случай, если "магия" не сработает. Это сохраняет доверие пользователя.


================================================
FILE: package.json
================================================
{
  "name": "smart-tinker-mutabor-monorepo",
  "private": true,
  "workspaces": [
    "api",
    "client"
  ],
  "scripts": {
    "prod:up": "docker compose --project-name mutabor-prod -f docker-compose.yml up -d --build",
    "prod:down": "docker compose --project-name mutabor-prod -f docker-compose.yml down",
    "prod:clean": "docker compose --project-name mutabor-prod -f docker-compose.yml down -v --remove-orphans",
    "prod:logs": "docker compose --project-name mutabor-prod -f docker-compose.yml logs -f",
    "dev:up": "docker compose --project-name mutabor-dev -f docker-compose.dev.yml up -d --build",
    "dev:down": "docker compose --project-name mutabor-dev -f docker-compose.dev.yml down",
    "dev:clean": "docker compose --project-name mutabor-dev -f docker-compose.dev.yml down -v --remove-orphans",
    "dev:logs": "docker compose --project-name mutabor-dev -f docker-compose.dev.yml logs -f",
    "test:api": "docker compose --project-name mutabor-test -f docker-compose.test.yml up --build --exit-code-from api-test && docker compose --project-name mutabor-test -f docker-compose.test.yml down -v --remove-orphans",
    "test:client": "npm test -w client",
    "test:all": "npm run test:api && npm run test:client"
  }
}

================================================
FILE: README.md
================================================
# Mutabor: Интеллектуальный Таск-менеджер

[![CI/CD Status](https://img.shields.io/badge/CI%2FCD-passing-brightgreen)](https://github.com/your-repo/mutabor/actions)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

"Mutabor" — это веб-приложение для управления задачами с Kanban-доской, созданное для небольших команд. Ключевая особенность — встроенный AI-ассистент, который помогает автоматизировать рутинные задачи, такие как декомпозиция и анализ.

Продукт спроектирован как платформа, позволяющая пользователям подключать свои собственные ключи к AI-провайдерам для персонализации и контроля над расходами.

## Оглавление (Table of Contents)

- [🚀 Установка и Запуск (Installation and Startup)](#-установка-и-запуск-installation-and-startup)
  - [Предварительные требования (Prerequisites)](#предварительные-требования-prerequisites)
  - [Общая первоначальная настройка (Common Initial Setup)](#общая-первоначальная-настройка-common-initial-setup)
  - [Режим локальной разработки (Manual Local Development Setup)](#режим-локальной-разработки-manual-local-development-setup)
  - [Локальный запуск через Docker Compose (Full Stack Docker Compose Setup)](#локальный-запуск-через-docker-compose-full-stack-docker-compose-setup)
- [🛠️ Основные команды для разработки (Key Development Commands)](#основные-команды-для-разработки-key-development-commands)
- [🏛️ Архитектура и Ключевые особенности (Architecture and Key Features)](#архитектура-и-ключевые-особенности-architecture-and-key-features)
- [🔌 API Документация (API Documentation)](#api-документация-api-documentation)
- [💡 Точки расширения (Extension Points)](#точки-расширения-extension-points)
- [✅ Тестирование (Testing)](#тестирование-testing)


## 🚀 Установка и Запуск (Installation and Startup)

В этом разделе описываются различные способы установки и запуска проекта для локальной разработки.

### Предварительные требования (Prerequisites)
- [Node.js](https://nodejs.org/) (v20.x или выше)
- [Docker](https://www.docker.com/) и [Docker Compose](https://docs.docker.com/compose/)

### Общая первоначальная настройка (Common Initial Setup)

1.  **Клонировать репозиторий**:
    ```bash
    git clone https://github.com/your-repo/mutabor.git
    cd mutabor
    ```

2.  **Создать и настроить файл `.env` для API**:
    Скопируйте `api/.env.example` в `api/.env` (`cp api/.env.example api/.env`) и проверьте переменные.

    **Ключевые моменты конфигурации:**
    - **`PORT`**: Мы рекомендуем установить `PORT=3001`, чтобы избежать конфликтов с фронтенд-сервером разработки, который обычно занимает порт `3000`.
    - **`DATABASE_URL`**: Используется приложением Nest.js для подключения к базе данных. Формат зависит от способа запуска БД (см. ниже).
    - **`DB_*` переменные**: **Обязательны** для скрипта миграций Liquibase (`npm run migrate`). Они должны точно соответствовать настройкам вашей базы данных.
    - **`JWT_SECRET`**: Замените значение по умолчанию на ваш собственный секретный ключ.

### Режим локальной разработки (Manual Local Development Setup)

Этот режим идеален для разработки, так как позволяет запускать сервисы по отдельности.

**1. Запуск базы данных в Docker**

Мы рекомендуем запускать PostgreSQL через Docker Compose, даже при ручном запуске остальных сервисов.

   1. Убедитесь, что у вас есть файл `docker-compose.yml` в корне проекта.
   2. Запустите только сервис базы данных `db` в фоновом режиме:
      ```bash
      docker compose up -d db
      ```
   3. **Настройте `api/.env`**: В вашем файле `api/.env` должны быть следующие значения для подключения к БД, запущенной в Docker:
      ```env
      # Используется приложением Nest.js
      DATABASE_URL="postgresql://user:password@localhost:54321/mutabor?schema=public"
      
      # Используется скриптом миграций Liquibase
      DB_HOST=localhost
      DB_PORT=54321
      DB_NAME=mutabor
      DB_USER=user
      DB_PASSWORD=password
      ```
      *Примечание: Порт `54321` используется, так как он проброшен из контейнера в `docker-compose.yml`. Если у вас локально установлен PostgreSQL на порту `5432`, измените эти значения соответственно.*

   4. **Примените миграции БД**: После первого запуска или при изменениях схемы выполните:
      ```bash
      npm run migrate -w api
      ```
      *Эта команда использует переменные `DB_HOST`, `DB_PORT` и т.д. из вашего `.env` файла.*

**2. Запуск сервисов вручную**

Откройте два терминала:

*   **Терминал 1: Запуск Бэкенда (API)**
    ```bash
    npm run start:dev -w api
    ```
    API будет доступен по адресу `http://localhost:3001` (или на порту, указанном в `PORT`).

*   **Терминал 2: Запуск Фронтенда (Client)**
    ```bash
    npm run dev -w client
    ```
    Фронтенд будет доступен по адресу `http://localhost:3000`.

### Локальный запуск через Docker Compose (Full Stack Docker Compose Setup)

Этот метод запускает всё приложение (фронтенд, бэкенд, БД) одной командой.

1.  Убедитесь, что ваш файл `api/.env` создан и в нем установлен `JWT_SECRET`.
2.  Запустите все сервисы:
    ```bash
    docker compose up --build
    ```
    - **Фронтенд (Client)** будет доступен по адресу: `http://localhost:3000`
    - **Бэкенд (API)** будет доступен по адресу: `http://localhost:3001`

## 🛠️ Основные команды для разработки

- `npm run start:dev -w <workspace>`: Запустить `client` или `api` в режиме разработки с hot-reload.
- `npm run build -w <workspace>`: Собрать продакшн-версию `client` или `api`.
- `npm run test -w api`: Запустить тесты (unit и интеграционные) для backend.
- `npm run test -w client`: Запустить тесты для frontend.
- `npm run lint`: Проверить код всего проекта на соответствие стандартам стиля.
- `npm run migrate -w api`: Применить новые миграции схемы базы данных Liquibase.

## 🏛️ Архитектура и Ключевые особенности

Проект построен как монорепозиторий с двумя основными частями: `/api` (backend на Nest.js) и `/client` (frontend на React).

-   **Модульность:** Бэкенд строго разделен на модули (`auth`, `projects`, `tasks`, `notifications`).
-   **Строгие слои:** Архитектура следует принципам `Layer Guides`, где контроллеры "тонкие", а бизнес-логика находится в сервисах.
-   **Человеко-понятные ID:** Система использует легко читаемые идентификаторы для задач (`PHX-1`, `PROJ-10`).
-   **Контракты:** Все взаимодействие происходит по строгим контрактам (DTO, OpenAPI), что гарантирует предсказуемость.

## 🔌 API Документация

Автоматически генерируемая интерактивная документация API (Swagger) доступна после запуска бэкенда по адресу:

**`http://localhost:3001/api/v1/api-docs`**

Используйте её для изучения и тестирования эндпоинтов.

## 💡 Точки расширения

### 1. Добавление новой AI-функции

**Пример: Добавление функции "AI-генерация тегов для задачи"**

1.  **`ai.service.ts`**: Добавьте новый метод в сервис-адаптер.
2.  **`tasks.controller.ts`**: Создайте новый эндпоинт, который вызывает сервис.
3.  **`tasks.service.ts`**: Оркестрируйте вызов `AiService` и сохранение результата.

### 2. Интеграция с Git-репозиторием (Стратегическое направление)

- **Шаг 1: Модель данных.** Расширить модель `Project`, добавив поля для URL репозитория и токена доступа.
- **Шаг 2: Сервис-адаптер.** Создать `GitService` для работы с репозиторием.
- **Шаг 3: Расширение AI.** Научить `AiService` использовать контекст из файлов кода.

## ✅ Тестирование

- **Backend:** Мы используем Jest. Запуск: `npm run test -w api`.
- **Frontend:** Мы используем Vitest. Запуск: `npm run test -w client`.

Вы можете запустить генерацию отчетов о покрытии, используя команды `test:cov`.
