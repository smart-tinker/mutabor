# Implementation Plan: Mutabor

## Общие принципы
- **Стек:** Nest.js (Backend), React (Frontend), PostgreSQL (DB), Knex.js (Query Builder), Liquibase (Schema Migration), Socket.IO (Real-time).
- **Подход:** Разработка ведется "вертикальными срезами" (feature slicing). Каждая фича реализуется сквозным образом (DB -> Backend API -> Frontend UI).
- **Real-time:** Каждый API-эндпоинт, изменяющий состояние доски, немедленно сопровождается реализацией WebSocket-события для синхронизации всех клиентов.

---

## Фаза 1: Фундамент и Аутентификация (Срок: 1 неделя)

**Цель:** Заложить основу проекта и реализовать базовый, но полный цикл аутентификации.

1.  **DevOps & Setup:**
    - Создать монорепозиторий (например, через `npm/yarn/pnpm workspaces`).
    - Инициализировать Nest.js приложение (`/api`) и React приложение (`/client`).
    - Для локальной разработки базы данных рекомендуется использовать Docker Compose для запуска PostgreSQL контейнера, как описано в основном `README.md`.

2.  **Фича: Регистрация пользователя:**
    - **DB (Liquibase/Knex.js):** Определить модель `User` (`id`, `email`, `name`, `password_hash`, `createdAt`) используя миграции Liquibase и Knex.js для запросов.
    - **Backend (Nest.js):**
        - Создать `AuthModule`.
        - Реализовать `POST /auth/register` эндпоинт в `AuthController`.
        - В `AuthService` реализовать логику: проверка существования email, хеширование пароля (`bcrypt`), сохранение пользователя в БД.
    - **Frontend (React):**
        - Создать страницу `/register`.
        - Создать компонент `RegistrationForm` с валидацией полей.
        - Реализовать функцию, отправляющую данные формы на бэкенд.

3.  **Фича: Вход пользователя:**
    - **Backend (Nest.js):**
        - Установить `@nestjs/jwt` и `@nestjs/passport`.
        - Реализовать `POST /auth/login` эндпоинт. Логика в сервисе: найти пользователя, сравнить хеш пароля, сгенерировать JWT.
        - Реализовать `JwtStrategy` (Passport.js) и `JwtAuthGuard` для защиты будущих эндпоинтов.
    - **Frontend (React):**
        - Создать страницу `/login`.
        - Создать компонент `LoginForm`.
        - Реализовать логику входа, сохранения JWT в `localStorage` и настройки `axios` interceptor для автоматического добавления `Authorization` заголовка во все последующие запросы.

**Контрольная точка:** Пользователь может зарегистрироваться, войти, и после перезагрузки страницы остаться залогиненным. Доступ к защищенным роутам без токена запрещен.

---

## Фаза 2: Ядро Kanban (Срок: 2 недели)

**Цель:** Создать полнофункциональную личную Kanban-доску.

1.  **Фича: Создание и просмотр проектов (досок):**
    - **DB (Liquibase/Knex.js):** Определить модели `Project` и `Column` используя миграции Liquibase. Установить связи: `User` -> `Project` (один ко многим, владелец), `Project` -> `Column` (один ко многим). Knex.js будет использоваться для запросов.
    - **Backend (Nest.js):**
        - Создать `ProjectModule`.
        - Реализовать эндпоинты: `POST /projects`, `GET /projects`, `GET /projects/:id` (с вложенными колонками и задачами).
        - Использовать `JwtAuthGuard` для защиты всех эндпоинтов.
    - **Frontend (React):**
        - Создать страницу `DashboardPage`, где отображается список проектов.
        - Создать страницу `BoardPage` (`/projects/:id`), которая будет получать и отображать данные конкретной доски.

2.  **Фича: Управление задачами:**
    - **DB (Liquibase/Knex.js):** Определить модель `Task` используя миграции Liquibase. Связи: `Column` -> `Task`, `User` -> `Task` (исполнитель). Knex.js будет использоваться для запросов.
    - **Backend (Nest.js):**
        - Создать `TaskModule`.
        - Реализовать `POST /tasks` (создание задачи). После создания — эмитить событие `task:created` через WebSocket-шлюз.
    - **Frontend (React):**
        - В `BoardPage`, добавить UI для создания задачи в колонке.
        - Настроить `socket.io-client` для прослушивания событий и динамического добавления новой задачи на доску.

3.  **Фича: Перемещение задач (Drag-and-Drop):**
    - **Backend (Nest.js):**
        - Реализовать эндпоинт `PATCH /tasks/:id/move`. Он принимает новый `columnId` и `order`.
        - После обновления в БД — эмитить событие `task:moved` с данными о перемещении.
    - **Frontend (React):**
        - Интегрировать библиотеку `dnd-kit`.
        - Настроить логику перетаскивания. При завершении (`onDragEnd`) — отправлять запрос на бэкенд.
        - Реализовать оптимистичное обновление UI (переместить карточку сразу, не дожидаясь ответа сервера).
        - Обработчик события `task:moved` должен обновить доску, если изменение пришло от другого пользователя.

**Контрольная точка:** Пользователь может создавать доски, колонки, задачи и перемещать их. Все изменения мгновенно синхронизируются через WebSockets.

---

## Фаза 3: Совместная работа (Срок: 1.5 недели)

**Цель:** Превратить личную доску в командный инструмент.

1.  **Фича: Приглашение и участники:**
    - **DB (Liquibase/Knex.js):** Создать связующую таблицу `ProjectMember` используя миграции Liquibase. Knex.js будет использоваться для запросов.
    - **Backend (Nest.js):** Реализовать API для приглашения пользователя в проект и отображения списка участников.
    - **Frontend (React):** Создать UI для управления участниками.

2.  **Фича: Комментарии и @упоминания:**
    - **DB (Liquibase/Knex.js):** Создать модели `Comment` и `Notification` используя миграции Liquibase. Knex.js будет использоваться для запросов.
    - **Backend (Nest.js):**
        - Реализовать `POST /tasks/:id/comments`. В сервисе — логика парсинга `@упоминаний`, создание комментария и записи в `Notification`.
        - Эмитить события `comment:created` и `notification:new`.
        - Реализовать `GET /notifications`.
    - **Frontend (React):**
        - В модальном окне задачи добавить блок комментариев.
        - Реализовать компонент `NotificationBell` в шапке сайта.

**Контрольная точка:** Несколько пользователей могут работать на одной доске, общаться в комментариях и получать уведомления об упоминаниях в реальном времени.

---

## Фаза 4: Интеграция AI (После MVP)

**Цель:** Внедрить ключевое УТП. Эта фаза выполняется после того, как основной функционал отлажен и стабилен.

1.  **Фича: Декомпозиция задачи:**
    - **Backend (Nest.js):**
        - Создать `AiModule`.
        - В `AiService` инкапсулировать логику запросов к внешнему AI API (например, OpenAI SDK). API-ключ хранить в переменных окружения.
        - Создать `POST /tasks/:id/decompose` эндпоинт.
        - Эмитить `task:updated` после успешной декомпозиции.
    - **Frontend (React):**
        - Добавить кнопку "✨ Улучшить с AI" в модальное окно задачи.
        - Реализовать отправку запроса и отображение состояния загрузки.
        - Обновлять описание задачи при получении события `task:updated`.

**Контрольная точка:** Пользователь может автоматически разбивать сложные задачи на подзадачи, используя AI.
